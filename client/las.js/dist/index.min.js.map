{"version":3,"sources":["webpack://Las/webpack/universalModuleDefinition","webpack://Las/webpack/bootstrap","webpack://Las/./src/core/events.ts","webpack://Las/./src/utils/log.ts","webpack://Las/./src/core/errors.ts","webpack://Las/./src/demux/flv/flv.ts","webpack://Las/./src/polyfills/object-assign.js","webpack://Las/./src/utils/browser.ts","webpack://Las/./node_modules/events/events.js","webpack://Las/./src/core/observer.ts","webpack://Las/./src/types/remux.ts","webpack://Las/./src/polyfills/number-isFinite.js","webpack://Las/./src/remux/aac-helper.ts","webpack://Las/./src/remux/mp4-generator.ts","webpack://Las/./src/remux/mp4-remuxer.ts","webpack://Las/./src/demux/asc.ts","webpack://Las/./src/demux/get-audio-config.ts","webpack://Las/./src/demux/exp-golomb.ts","webpack://Las/./src/demux/sps-parser.ts","webpack://Las/./src/utils/decodeUTF8.ts","webpack://Las/./src/demux/flv/amf.ts","webpack://Las/./src/demux/flv/avc-helper.ts","webpack://Las/./src/demux/flv/flv-demuxer.ts","webpack://Las/./src/demux/flv/flv-demuxer-inline.ts","webpack://Las/./node_modules/webworkify-webpack/index.js","webpack://Las/./node_modules/url-parse/index.js","webpack://Las/(webpack)/buildin/global.js","webpack://Las/./node_modules/requires-port/index.js","webpack://Las/./node_modules/querystringify/index.js","webpack://Las/./src/demux/flv/flv-demuxer-worker.ts","webpack://Las/./src/config.ts","webpack://Las/./src/core/media.ts","webpack://Las/./src/utils/mediasource-helper.ts","webpack://Las/./src/core/mse-controller.ts","webpack://Las/./src/abr/abr-get-url.ts","webpack://Las/./src/abr/abr-level.ts","webpack://Las/./src/abr/abr-manifest.ts","webpack://Las/./src/utils/matrix.ts","webpack://Las/./src/abr/abr-algorithm.ts","webpack://Las/./src/abr/multirate.ts","webpack://Las/./src/io/cache.ts","webpack://Las/./src/io/xhr.ts","webpack://Las/./src/demux/flv/flv-tag-dump.ts","webpack://Las/./src/io/fetch.ts","webpack://Las/./src/io/loader.ts","webpack://Las/./src/core/report-types.ts","webpack://Las/./src/core/trans-flv.ts","webpack://Las/./src/utils/get-error-code.ts","webpack://Las/./src/monitor/fps.ts","webpack://Las/./src/monitor/stream-monitor.ts","webpack://Las/./src/monitor/monitor.ts","webpack://Las/./src/types/monitor-data.ts","webpack://Las/./src/index.ts","webpack://Las/./src/utils/is-supported.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","LasEvents","MEDIA_INFO","PARSING_INIT_SEGMENT","PARSING_DATA","PARSED_DATA","SCRIPT_PARSED","LOAD_END","DISCONTINUITY","ERROR","LEVEL_SWITCH_FAILED","LEVEL_SWITCHING","LEVEL_SWITCHED","MANIFEST_PARSED","BUFFER_FLUSHING","INIT_PTS_FOUND","FLV_HEAD","REPORT","HEARTBEAT","LOG_LEVEL","formatter","tag","msg","length","unshift","Log","level","ENABLE_ERROR","ENABLE_WARN","ENABLE_INFO","ENABLE_DEBUG","ENABLE_VERBOSE","LEVEL_WARN","LEVEL_INFO","LEVEL_DEBUG","LEVEL_VERBOSE","e","out","console","error","warn","log","apply","w","info","debug","v","ErrorTypes","ErrorDetails","FlvTagType","FlvSize","FLV_HEAD_LEN","FLV_TAG_HEAD_LEN","FLV_TAG_SIZE_LEN","AVC_KEY_FRAME_CHECK_LEN","FlvTag","tagType","VIDEO","dataSize","timestamp","size","cts","frameType","codecId","body","fill","ObjectAssign","assign","target","varArgs","TypeError","to","index","arguments","nextSource","nextKey","Browser","ua","self","navigator","userAgent","toLowerCase","match","exec","indexOf","platform_match","matched","browser","version","majorVersion","platform","versionArray","split","major","parseInt","string","minor","build","chrome","opr","safari","webkit","rv","iemobile","edge","android","detect","ReflectOwnKeys","R","Reflect","ReflectApply","receiver","args","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","that","_addListener","type","listener","prepend","events","existing","warning","newListener","emit","push","warned","Error","String","emitter","count","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","copy","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","err","message","context","handler","len","listeners","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","shift","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","Observer","trigger","event","TrackType","RemuxerTrackIdConfig","isFiniteNumber","isFinite","AAC","getSilentFrame","codec","channelCount","Uint8Array","UINT32_MAX","Math","pow","MP4","types","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","video","audio","dref","stco","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","hev1Brand","minorVersion","FTYP_AVC","box","ftyp","FTYP_HEVC","DINF","dinf","payload","result","byteLength","hdlr","mdat","data","mdhd","timescale","duration","upperWordDuration","floor","lowerWordDuration","mdia","track","minf","mfhd","sequenceNumber","smhd","stbl","vmhd","moof","sn","baseMediaDecodeTime","traf","moov","tracks","boxes","trak","mvhd","mvex","trex","bytes","sdtp","flags","samples","dependsOn","isDependedOn","hasRedundancy","stsd","stts","stsc","stsz","avc1","sps","pps","slice","avcc","avcC","width","height","hSpacing","pixelRatio","vSpacing","btrt","pasp","hev1","hvcc","codecWidth","codecHeight","hvcC","esds","configlen","config","mp4a","samplerate","mp3","isAAC","tkhd","id","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","tfhd","tfdt","trun","offset","sample","arraylen","array","isLeading","paddingValue","isNonSync","degradPrio","initSegment","movie","MP4Remuxer","observer","typeSupported","vendor","_observer","_config","_typeSupported","_isSafari","_forceFirstIDR","_stash","_stashInfo","_stashLastVideoSample","_ISGenerated","_videoTime","_extra","_nextAudioPts","_nextAvcDts","_initPTS","_initDTS","_initSegment","gopRemux","_resetVideoTime","setStat","stat","ISGenerated","nextAudioPts","nextAvcDts","initPTS","initDTS","nbSamples","videoTime","firstDTS","sampleDuration","vLastPTS","aLastPTS","endDts","getStat","destroy","setExtra","resetTimeStamp","defaultTimeStamp","resetInitSegment","resetStash","getLastPTS","flush","audioTrackLength","videoData","remuxVideo","timeOffset","accurateTimeOffset","remux","audioTrack","videoTrack","contiguous","isFlush","generateIS","pts","dts","nbVideoStashSamples","nbAudioSamples","nbVideoSamples","audioTimeOffset","videoTimeOffset","audiovideoDeltaDts","inputTimeScale","max","audioData","remuxAudio","endPTS","startPTS","startDTS","endDTS","remuxEmptyAudio","audioSamples","videoSamples","computePTSDTS","container","Infinity","mpeg","metadata","audioSampleRate","fps","profile","chromaFormat","min","MUX_ERROR","details","PARSING_ERROR","fatal","reason","lastPTS","lastDTS","timeScale","inputSamples","outputSamples","ptsNormalize","_PTSNormalize","streamDTS","time","mp4SampleDuration","firstPTS","isSafari","abs","forEach","sort","a","b","deltadts","deltapts","PTSDTSshift","reduce","prev","curr","round","delta","nbNalu","naluLen","units","nbUnits","sampleLen","j","mdatSize","REMUX_ALLOC_ERROR","view","DataView","buffer","setUint32","avcSample","avcSampleUnits","mp4SampleLength","compositionTimeOffset","unit","unitData","unitDataLen","lastFrameDuration","refSampleDuration","stretchShortVideoTrack","maxBufferHole","gapTolerance","deltaToFrameEnd","fix","dropped","_mergeBoxes","hasAudio","hasVideo","nb","extra","mp4Sample","fillFrame","mp4timeScale","scaleFactor","inputSampleDuration","rawMPEG","resetPts","filter","maxAudioFramesDrift","nextPts","toFixed","splice","missing","newStamp","manifestCodec","subarray","audioSample","numMissingFrames","unitLen","lastSampleDuration","start","end","frameDuration","ceil","silentFrame","stamp","reference","cur","initTrackConfig","audioCodec","extensionSampleingIndex","objectType","sampleingIndex","chanelConfig","sampleingRates","test","getAudioConfig","parseData","ExpGolomb","uint8array","_buffer","_buffer_index","_total_bytes","_total_bits","_current_word","_current_word_bits_left","_fillCurrentWord","buffer_bytes_left","bytes_read","word","getUint32","readBits","bits","bits_need_left","bits_read_next","result2","readBool","readUByte","readUShort","readUInt","readByte","_skipLeadingZero","zero_count","readUEG","leading_zeros","readSEG","readSliceType","getBitsLeft","HEVC_MAIN","1","2","3","4","HEVC_LEVELS","30","60","63","90","93","120","123","150","153","156","180","183","186","255","SPSParser","_ebsp2rbsp","src","src_length","dst","dst_idx","parseHEVCSPS","rbsp","gb","ptl","general_ptl","sub_layer_ptl","max_sub_layers","_parsePTL","chroma_format_idc","chroma_format_string","profile_string","level_string","max_num_sub_layers","_decodeProfileTierLevel","level_idc","getHEVCLevelString","sub_layer_profile_present_flag","sub_layer_level_present_flag","profile_space","tier_flag","profile_idc","profile_compatibility_flag","progressive_source_flag","interlaced_source_flag","non_packed_constraint_flag","frame_only_constraint_flag","getHEVCProfileString","parseSPS","getProfileString","getLevelString","chroma_format","bit_depth","scaling_list_count","_skipScalingList","pic_order_cnt_type","num_ref_frames_in_pic_order_cnt_cycle","pic_width_in_mbs_minus1","pic_height_in_map_units_minus1","frame_mbs_only_flag","frame_crop_left_offset","frame_crop_right_offset","frame_crop_top_offset","frame_crop_bottom_offset","sar_width","sar_height","fps_fixed","fps_num","fps_den","aspect_ratio_idc","num_units_in_tick","time_scale","sarScale","crop_unit_x","crop_unit_y","codec_width","codec_height","present_width","getChromaFormatString","frame_rate","fixed","sar_ratio","codec_size","present_size","last_scale","next_scale","chroma","checkContinuation","checkLength","decodeUTF8","input","fromCharCode","ucs4","join","AMF","parseMetadata","parseScript","toString","parseObject","arrayBuffer","dataOffset","parseString","isObjectEnd","objectEnd","parseVariable","parseLongString","parseDate","getFloat64","localTimeOffset","getInt16","Date","getUint16","dv","getUint8","amfstr","amfobj","amfvar","strictArrayLength","val","date","amfLongStr","configBody","frameI","AVC","getFlvVideoTag","FlvDemux","remuxer","_remuxer","_duration","_naluLengthSize","_hasVideo","_hasAudio","_videoTrack","_audioTrack","_remuxStat","_currentTimestamp","_aLastDTS","_vLastDTS","_nonMonotonousCache","_fillAtStart","enabled","avcConfig","pid","append","tags","_fillFrame","_parseVideoData","AUDIO","_parseAudioData","SCRIPT","_parseScriptTag","st","ed","_remux","flvHead","scriptData","onMetaData","framerate","spec","packetType","_parseAVCDecoderConfigurationRecord","_parseAVCVideoData","avcProfile","spsCount","spsList","codecArray","codecString","h","ppsCount","ignoreNonMonotonous","lengthSize","keyframe","_onNonMonotonous","_flushNonMonotonousCache","naluSize","unitType","aacFrameLen","ASC","aacData","dtsDiff","sampleDts","aacSample","cache","lastPts","ptsSync","nonMonotonousCache","audiotrack","videotrack","REMUX_ERROR","sec","FlvDemuxerInline","extraData","_extraData","_demuxer","_bitrate","_vendor","bitrate","Mp4Remuxer","mp4","demuxer","FlvDemuxer","discontinuity","webpackBootstrapFunc","configurable","oe","f","ENTRY_MODULE","default","dependencyRegExp","quoteRegExp","str","replace","getModuleDependencies","sources","queueName","retval","fnString","wrapperSignature","webpackRequireName","re","RegExp","hasValuesInQueues","queues","hasValues","options","main","requiredModules","all","modulesQueue","seenModules","moduleToCheck","newModules","newModulesKeys","getRequiredModules","entryModule","JSON","stringify","map","blob","window","Blob","bare","workerUrl","URL","webkitURL","mozURL","msURL","createObjectURL","worker","Worker","objectURL","required","qs","slashes","protocolre","left","trimLeft","rules","address","NaN","ignore","hash","query","lolcation","loc","location","global","finaldestination","protocol","Url","unescape","pathname","href","extractProtocol","rest","parser","relative","extracted","parse","instruction","instructions","url","charAt","base","path","last","up","resolve","port","host","hostname","username","password","auth","origin","part","fn","char","ins","g","has","decode","decodeURIComponent","obj","prefix","pairs","encodeURIComponent","flv","forwardMessage","ev","postMessage","addEventListener","cmd","URL_REG","DEFAULT_CONFIG","webWorker","autoCleanupMaxBackwardDuration","autoCleanupMinBackwardDuration","appendErrorMaxRetry","credentials","defaultSpts","LEVEL_ERROR","connectionTimeout","transmissionTimeout","ConfigHelper","processConfig","userConfig","setSrc","detectStreamingMux","opera","manifest","Media","_video","_mse","_streamTime","_localTime","reset","attachVideo","attachMSE","mse","isTimeinBuffered","buffered","bufferedSec","currentTime","bufferedSecByType","bufferedEndByType","mseBufferedSecByType","bufferedByType","bufferSliceNumByType","pendingNum","pendingSecByType","currentBuffer","nextBuffer","updateStreamTime","streamTime","localTime","getLocalTime","readyState","getMediaSource","MediaSource","WebKitMediaSource","MSEController","_sourceBuffer","_mediaSource","_mimeCodec","_cleanUpTask","_appendQueue","_endOfData","_appendEnabled","_appendError","_appendBufferError","_sbHandler","_souceBufferLocked","_onSourceOpen","removeEventListener","_checkSourceBuffer","refresh","_onSourceEnded","_onSourceClose","_onSourceBufferUpdateEnd","_update","_endOfStream","_onSourceBufferError","MSE_ERROR","SOURCEBUFFER_ERROR","audiovideo","attach","MediaSourceDef","ms","load","setTimeout","MEDIASOURCE_ERROR","trackInfo","mediaInfo","hasSourceBuffer","updateend","videoCodec","expected","codecs","_addSourceBuffer","addSourceBuffer","ADDSOURCEBUFFER_ERROR","sb","_hasPendingData","_doAppend","_getBufferQueueSize","APPENDBUFFER_ERROR","updating","_appendBuffer","mediaSegment","segment","queue","current","num","_calculateRemoveRange","seeking","task","_cleanUpRange","range","bufStart","firefox","bufEnd","removeStart","removeEnd","remove","appendBuffer","code","conf","useless","MIN_CLEANUP_DURATION","hasCleanUpTask","_cleanUp","startSec","endSec","flushType","POSITIVE_INFINITY","setAppendEnabled","getAppendEnabled","endOfData","ended","endOfStream","ENDOFSTREAM_ERROR","removeSourceBuffer","getBufferQueueSec","prevDuration","currentSeg","item","abrGetUrl","spts","urlparse","lasSpts","AbrLevel","maxBitrate","avgBitrate","qualityType","qualityLabel","hidden","enableAdaptive","defaultSelect","AbrManifest","_levels","_abrLevels","_default","verify","adaptationSet","representation","disableAdaptive","isArray","Matrix","Float32Array","shape","_init","add","subtract","augment","multiply","zeros","identity","ArrayBuffer","BYTES_PER_ELEMENT","constructor","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Uint8ClampedArray","Float64Array","flatten","acc","next","matrix","r1","c1","r2","c2","k","sum","d1","d2","x","alpha","equilateral","equidimensional","l1","transpose","inverse","gauss","right","equals","pivot","leadValue","lead","swap","check","copyWithin","D","s1","s2","every","dim","l2","CONFIG","beacon","predictStep","minBuffer","bufferOffset","smoothRatioToTarget","speedSmoothRatio","switchPenalty","slidingWindowSize","kalmanR","kalmanQ","initBitrateLevel","speedPredictNum","AbrAlgorithm","MATRIX_E","MATRIX_G","_conf","_xPrev","_PPrev","_pastBuffer","_pastThroughput","_availableList","_current","_next","_processConfig","levels","setAvailableBitrates","onGOP","speed","_nextRateIndex","_recentSpeed","onLevelLoad","_quantization","_nextRateBySpeedAndBuffered","_resetAlgorithm","_recentBuffer","_adjustedTargetBuffer","targetBuffer","_rateChangeArray","switchPenaltyArray","estimatedThroughput","Bk","br","targetBufferArray","_printFirstColumn","matrixG","predictedBufferArray","matrixF","_diag","futureThroughput","_multistepPred","rateChangeArray","_printFirstRow","dist","pastThroughput","pastThroughputClone","bandwidthSum","nonzeroCnt","_multistepKalmanfilter","xLast","z","PLast","Q","xPrev","PPrev","xRet","PRet","PMinus","K","predX","P","Multirate","media","_media","_downloadSize","_downloadStartTime","_keyCount","_index","_alg","_manifest","_autoLevelEnabled","abrLevels","performance","now","nextLevel","currentLevel","destory","onLoaderChunk","onKeyFrame","_getRequestUrl","Cache","_size","_readOffset","_writeOffset","_storage","_cache","DEFAULT_CACHE_SIZE","put","chunk","_collateCache","expandCache","byteOffset","read","skip","clear","MAX_CACHE_SIZE","_transfer","remain","source","sourceView","destView","XHR_TYPE","FlvTagDump","onAbr","_tag","_result","_parseLen","_parseFunc","_onAbr","_parseFlvHead","abr","unreadLen","_parseFlvTagHead","_detectKeyFrame","_parseFlvTag","FetchLoader","_context","_callbacks","_controller","_reader","_abort","isSupport","fetch","ReadableStream","callbacks","reqHeaders","Headers","headers","element","header","params","method","referrerPolicy","signal","_getAbortSignal","then","res","responseUrl","responseHeader","onConnect","status","ok","getReader","cancel","responseType","progress","_pump","responseData","_onEnd","text","statusText","_onError","catch","abort","_onProgress","onProgress","onEnd","onError","reader","done","AbortController","ChunkLoader","XHR","_xhr","_msBufferOffset","_msBufferUpper","_progress","UNKNOW","isSupportChunk","supportChunk","xhr","XMLHttpRequest","open","MOZ_CHUNK","UNSUPPORT","MS_STREAM","MSStreamReader","onprogress","_msrOnProgress","onload","_onLoadEnd","onerror","onreadystatechange","_onReadyStateChange","withCredentials","setRequestHeader","send","responseURL","getAllResponseHeaders","readAsArrayBuffer","response","Loader","_loader","_loaderCallback","_stats","_retryDelay","_loading","_aborted","_requestTimeout","_transTimer","_retryTimeout","_rangeStart","_continuedTransmissionRetry","_progressTime","useFetch","maxRetry","retryDelay","_onConnect","_getInternalLoader","msie","msedge","_loadInternal","_stopTimer","_abortInternal","_destroyLoader","rangeStart","trequest","retry","loaded","output","tfirst","tload","total","tsload","tstart","stats","clearTimeout","_onTimeout","rangeEnd","onAbort","_stopTransmissionTimer","_startTransmissionTimer","tmp","_callProgress","timeout","setInterval","clearInterval","REPORT_TYPES","TransFLV","_w","_flv","_loaderConf","_loaderCallbacks","_multirate","_contiguous","_remuxId","_discontinuity","_accurateTimeOffset","_baseTimeSec","_tagDump","_currentUrl","_lastDTS","_isAbr","_onKeyframe","smooth","_onMessage","remuxId","framesInfo","_onLoaderError","_onLoaderEnd","_onAbort","onMessage","_onWorkMessage","work","loadSource","mr","_load","OTHER_ERROR","terminate","sync","_append","timeCost","errInfo","NETWORK_ERROR","LOAD_ERROR","statusCode","_refreshRemuxId","autoLevelEnabled","ErrorCodeList","400","401","403","404","other4xx","serverError","timeoutOpen","timeoutIO","200","206","FPS","_lastDroppedFrames","_lastDecodedFrames","_isVideoPlaybackQualityAvailable","_lastTime","_decoded","_dropped","attachMedia","HTMLVideoElement","getVideoPlaybackQuality","videoPlaybackQuality","totalVideoFrames","droppedVideoFrames","webkitDecodedFrameCount","webkitDroppedFrameCount","checkFPSInterval","decoded","currentPeriod","currentDropped","currentDecoded","droppedFPS","decodedFPS","parseFloat","StreamMonitor","_qos","traffic","streams","download","keyFrame","onStreamOpen","startPos","loadTimeCost","videoDataRate","audioDataRate","segments","onMediaInfo","loadingInfo","onDataReceive","onMediaSegment","qos","stream","totalLen","getInfoByTime","updateStartPos","tsEnd","ts","Monitor","_fps","_data","_playing","_sm","_hbTimer","_heartbeat","_refresh","sm","hb","totalReceive","downloadSpeed","decodedFrames","droppedFrames","loadStartTime","firstFrameTime","blockDuration","blockCount","downloadedBytes","onReport","_stopHeartbeat","onLoad","_startHeartbeat","onSegmentInit","onLoadeddata","_onFirstFrame","_waitingEnd","onCanplay","onPlaying","onWaiting","block","_waitingStart","onStopLoad","onSegment","bufferingStartMS","STAT","Las","_trans","_stat","INIT","_seekOnCanplay","_audioCodecSwap","_error","_audioCodec","_recoverMediaErrorTime","_mainTimer","_nextLevel","_mediaInfo","_bufferThreshold","_loadStopped","_seekOnUpdateEnd","_playingLevel","_startLevel","_monitor","_onVideoPlay","_onVideoEnded","_resetMSE","revokeObjectURL","removeAttribute","_destroyMSE","_initMSE","_mainLoop","WAITING","SEEK","SELECT_BITRATE","jumpTo","_internalSeek","_checkLevelChange","_onVideoLoadeddata","_onVideoCanplay","NONE","_detectSeekOnCanplay","paused","_onVideoPlaying","_onVideoWaiting","_onVideoError","_recoverMediaError","_recoverSwapAudioCodec","MEDIA_ERROR","VIDEO_ERROR","_startMainTimer","_initMonitor","UNSUPPORTED","CONFIG_ERROR","mediaSource","sourceBuffer","SourceBuffer","WebKitSourceBuffer","isTypeSupported","sourceBufferValidAPI","streaming","__VERSION__","_bindVideoEvents","resume","play","_stopMonitor","_stopMainTimer","_unbindVideoEvents","_stopVideo","_initTrans","stopLoad","_destroyTrans","getMediaInfo","_unbindMediaSourceEvent","errorMessage","_verifyLevel","_transmuxerEvent","trans","manifestAudioCodec","EPS","errorCode","detail","httpStatusCode","getErrorCode","TransFlv","audioCodecSwap"],"mappings":"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,IAAjBC,EACA,OAAO,IAAIC,WAAW,CAAC,EAAM,IAAM,EAAM,IAAM,GAAM,MAClD,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAAC,GAAM,EAAM,GAAM,IAAM,EAAM,GAAM,EAAM,GAAM,MACpE,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,MAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,IACA,EACA,EACA,KAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,EACA,IACA,EACA,GACA,IACA,EACA,KAED,GAAqB,IAAjBD,EACP,OAAO,IAAIC,WAAW,CAClB,EACA,IACA,EACA,IACA,GACA,IACA,EACA,GACA,GACA,EACA,IACA,EACA,IACA,GACA,EACA,IACA,EACA,GACA,IACA,EACA,EACA,IACA,EACA,GACA,EACA,MAIR,MAEJ,QACI,GAAqB,IAAjBD,EAIA,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,GACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAED,GAAqB,IAAjBD,EAIP,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAED,GAAqB,IAAjBD,EAIP,OAAO,IAAIC,WAAW,CAClB,EACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAKhB,OAAO,M,eFjTHR,K,cAAAA,E,eAAAA,M,cAKAC,O,iBAAAA,I,kBAAAA,M,KGDZ,IAAMQ,EAAaC,KAAKC,IAAI,EAAG,IAAM,EAE/BC,E,kCAeKrF,KAAP,WA0CI,IAAIzJ,EACJ,IAAKA,KA1CL8O,EAAIC,MAAQ,CACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,OAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,GACR,KAAQ,IAIFD,EAAIC,MACND,EAAIC,MAAMlN,eAAe7B,KACzB8O,EAAIC,MAAM/O,GAAK,CAACA,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,GAAIhP,EAAEgP,WAAW,KAIxF,IAAMC,EAAY,IAAIP,WAAW,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGEQ,EAAY,IAAIR,WAAW,CAC7B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGJI,EAAIK,WAAa,CACbC,MAAOH,EACPI,MAAOH,GAGX,IAAMI,EAAO,IAAIZ,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,EACA,EACA,EACA,IAGEa,EAAO,IAAIb,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJI,EAAIU,KAAOV,EAAIW,KAAOX,EAAIY,KAAOH,EAEjCT,EAAIa,KAAO,IAAIjB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEJI,EAAIc,KAAO,IAAIlB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAEJI,EAAIe,KAAO,IAAInB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJI,EAAIgB,KAAO,IAAIpB,WAAW,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGJ,IAAMqB,EAAa,IAAIrB,WAAW,CAAC,IAAK,IAAK,IAAK,MAC5CsB,EAAY,IAAItB,WAAW,CAAC,GAAI,IAAK,GAAI,KACzCuB,EAAY,IAAIvB,WAAW,CAAC,IAAK,IAAK,IAAK,KAC3CwB,EAAe,IAAIxB,WAAW,CAAC,EAAG,EAAG,EAAG,IAE9CI,EAAIqB,SAAWrB,EAAIsB,IAAItB,EAAIC,MAAMsB,KAAMN,EAAYG,EAAcH,EAAYC,GAC7ElB,EAAIwB,UAAYxB,EAAIsB,IAAItB,EAAIC,MAAMsB,KAAMN,EAAYG,EAAcH,EAAYE,GAC9EnB,EAAIyB,KAAOzB,EAAIsB,IAAItB,EAAIC,MAAMyB,KAAM1B,EAAIsB,IAAItB,EAAIC,MAAMO,KAAMA,K,EAGxDc,IAAP,SAAWlG,GAA0C,2BAAvBuG,EAAuB,iCAAvBA,EAAuB,kBAMjD,IALA,IAGIC,EAHA/K,EAAO,EACP3F,EAAIyQ,EAAQnN,OACZuJ,EAAM7M,EAGHA,KACH2F,GAAQ8K,EAAQzQ,GAAG2Q,WAUvB,KAPAD,EAAS,IAAIhC,WAAW/I,IACjB,GAAKA,GAAQ,GAAK,IACzB+K,EAAO,GAAK/K,GAAQ,GAAK,IACzB+K,EAAO,GAAK/K,GAAQ,EAAI,IACxB+K,EAAO,GAAY,IAAP/K,EACZ+K,EAAOzE,IAAI/B,EAAM,GAEZlK,EAAI,EAAG2F,EAAO,EAAG3F,EAAI6M,EAAK7M,IAE3B0Q,EAAOzE,IAAIwE,EAAQzQ,GAAI2F,GACvBA,GAAQ8K,EAAQzQ,GAAG2Q,WAEvB,OAAOD,G,EAGJE,KAAP,SAAY1G,GACR,OAAO4E,EAAIsB,IAAItB,EAAIC,MAAM6B,KAAM9B,EAAIK,WAAWjF,K,EAG3C2G,KAAP,SAAYC,GACR,OAAOhC,EAAIsB,IAAItB,EAAIC,MAAM8B,KAAMC,I,EAG5BC,KAAP,SAAYC,EAAmBC,GAC3BA,GAAYD,EACZ,IAAME,EAAoBtC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxDyC,EAAoBxC,KAAKuC,MAAMF,GAAYtC,EAAa,IAC9D,OAAOG,EAAIsB,IACPtB,EAAIC,MAAMgC,KACV,IAAIrC,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAsC,GAAa,GAAK,IAClBA,GAAa,GAAK,IAClBA,GAAa,EAAI,IACL,IAAZA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACA,GACA,IACA,EACA,M,EAKLC,KAAP,SAAYC,GACR,OAAOxC,EAAIsB,IACPtB,EAAIC,MAAMsC,KACVvC,EAAIiC,KAAKO,EAAMN,UAAWM,EAAML,UAChCnC,EAAI8B,KAAKU,EAAMpH,MACf4E,EAAIyC,KAAKD,K,EAIVE,KAAP,SAAYC,GACR,OAAO3C,EAAIsB,IACPtB,EAAIC,MAAMyC,KACV,IAAI9C,WAAW,CACX,EACA,EACA,EACA,EACA+C,GAAkB,GAClBA,GAAkB,GAAK,IACvBA,GAAkB,EAAI,IACL,IAAjBA,M,EAKLF,KAAP,SAAYD,GACR,MAAmB,UAAfA,EAAMpH,KACC4E,EAAIsB,IAAItB,EAAIC,MAAMwC,KAAMzC,EAAIsB,IAAItB,EAAIC,MAAM2C,KAAM5C,EAAIe,MAAOf,EAAIyB,KAAMzB,EAAI6C,KAAKL,IAElFxC,EAAIsB,IAAItB,EAAIC,MAAMwC,KAAMzC,EAAIsB,IAAItB,EAAIC,MAAM6C,KAAM9C,EAAIc,MAAOd,EAAIyB,KAAMzB,EAAI6C,KAAKL,K,EAGlFO,KAAP,SAAYC,EAAYC,EAA6BT,GACjD,OAAOxC,EAAIsB,IAAItB,EAAIC,MAAM8C,KAAM/C,EAAI0C,KAAKM,GAAKhD,EAAIkD,KAAKV,EAAOS,K,EAK1DE,KAAP,SAAYC,GAIR,IAHA,IAAIlS,EAAIkS,EAAO5O,OACX6O,EAAQ,GAELnS,KACHmS,EAAMnS,GAAK8O,EAAIsD,KAAKF,EAAOlS,IAE/B,OAAO8O,EAAIsB,IAAJ,MAAAtB,EAAG,CACNA,EAAIC,MAAMkD,MADJ,OAEH,CAACnD,EAAIuD,KAAKH,EAAO,GAAGlB,UAAWkB,EAAO,GAAGjB,WAAW7H,OAAO+I,GAAO/I,OAAO0F,EAAIwD,KAAKJ,O,EAItFI,KAAP,SAAYJ,GAIR,IAHA,IAAIlS,EAAIkS,EAAO5O,OACT6O,EAAQ,GAEPnS,KACHmS,EAAMnS,GAAK8O,EAAIyD,KAAKL,EAAOlS,IAG/B,OAAO8O,EAAIsB,IAAJ,MAAAtB,EAAG,CAAKA,EAAIC,MAAMuD,MAAf,OAAwBH,K,EAG/BE,KAAP,SAAYrB,EAAmBC,GAC3BA,GAAYD,EACZ,IAAME,EAAoBtC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxDyC,EAAoBxC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxD6D,EAAQ,IAAI9D,WAAW,CACzB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAsC,GAAa,GAAK,IAClBA,GAAa,GAAK,IAClBA,GAAa,EAAI,IACL,IAAZA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,MAEJ,OAAOtC,EAAIsB,IAAItB,EAAIC,MAAMsD,KAAMG,I,EAG5BC,KAAP,SAAYnB,GACR,IAEIoB,EACA1S,EAHA2S,EAAUrB,EAAMqB,SAAW,GAC3BH,EAAQ,IAAI9D,WAAW,EAAIiE,EAAQrP,QAKvC,IAAKtD,EAAI,EAAGA,EAAI2S,EAAQrP,OAAQtD,IAC5B0S,EAAQC,EAAQ3S,GAAG0S,MACnBF,EAAMxS,EAAI,GAAK0S,EAAME,WAAa,EAAIF,EAAMG,cAAgB,EAAIH,EAAMI,cAG1E,OAAOhE,EAAIsB,IAAItB,EAAIC,MAAM0D,KAAMD,I,EAG5Bb,KAAP,SAAYL,GACR,OAAOxC,EAAIsB,IACPtB,EAAIC,MAAM4C,KACV7C,EAAIiE,KAAKzB,GACTxC,EAAIsB,IAAItB,EAAIC,MAAMiE,KAAMlE,EAAIU,MAC5BV,EAAIsB,IAAItB,EAAIC,MAAMkE,KAAMnE,EAAIW,MAC5BX,EAAIsB,IAAItB,EAAIC,MAAMmE,KAAMpE,EAAIa,MAC5Bb,EAAIsB,IAAItB,EAAIC,MAAMQ,KAAMT,EAAIY,Q,EAI7ByD,KAAP,SAAY7B,GACR,IAEItR,EACA8Q,EACAjE,EAJAuG,EAAW,GACXC,EAAW,GAMf,IAAKrT,EAAI,EAAGA,EAAIsR,EAAM8B,IAAI9P,OAAQtD,IAE9B6M,GADAiE,EAAOQ,EAAM8B,IAAIpT,IACN2Q,WACXyC,EAAI1I,KAAKmC,IAAQ,EAAI,KACrBuG,EAAI1I,KAAW,IAANmC,GAGTuG,EAAMA,EAAIhK,OAAOwC,MAAMhK,UAAU0R,MAAMnT,KAAK2Q,IAIhD,IAAK9Q,EAAI,EAAGA,EAAIsR,EAAM+B,IAAI/P,OAAQtD,IAE9B6M,GADAiE,EAAOQ,EAAM+B,IAAIrT,IACN2Q,WACX0C,EAAI3I,KAAKmC,IAAQ,EAAI,KACrBwG,EAAI3I,KAAW,IAANmC,GAETwG,EAAMA,EAAIjK,OAAOwC,MAAMhK,UAAU0R,MAAMnT,KAAK2Q,IAGhD,IAAMyC,EAAOzE,EAAIsB,IACTtB,EAAIC,MAAMyE,KACV,IAAI9E,WACA,CACI,EACA0E,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAO9B,EAAM8B,IAAI9P,QAEhB8F,OAAOgK,GACPhK,OAAO,CACJkI,EAAM+B,IAAI/P,SAEb8F,OAAOiK,KAGpBI,EAAQnC,EAAMmC,MACdC,EAASpC,EAAMoC,OACfC,EAAWrC,EAAMsC,WAAW,GAC5BC,EAAWvC,EAAMsC,WAAW,GAEhC,OAAO9E,EAAIsB,IACPtB,EAAIC,MAAMoE,KACV,IAAIzE,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA+E,GAAS,EAAI,IACL,IAARA,EACAC,GAAU,EAAI,IACL,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,KAEJH,EACAzE,EAAIsB,IACAtB,EAAIC,MAAM+E,KACV,IAAIpF,WAAW,CACX,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,OAGRI,EAAIsB,IACAtB,EAAIC,MAAMgF,KACV,IAAIrF,WAAW,CACXiF,GAAY,GACZA,GAAY,GAAK,IACjBA,GAAY,EAAI,IACL,IAAXA,EACAE,GAAY,GACZA,GAAY,GAAK,IACjBA,GAAY,EAAI,IACL,IAAXA,O,EAMTG,KAAP,SAAY1C,GACR,IAAM2C,EAAO3C,EAAM2C,KACbR,EAAQnC,EAAM4C,WAChBR,EAASpC,EAAM6C,YACbrD,EAAO,IAAIpC,WAAW,CACxB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA+E,IAAU,EAAI,IACN,IAARA,EACAC,IAAW,EAAI,IACN,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,MAEJ,OAAO5E,EAAIsB,IAAItB,EAAIC,MAAMiF,KAAMlD,EAAMhC,EAAIsB,IAAItB,EAAIC,MAAMqF,KAAMH,K,EAG1DI,KAAP,SAAY/C,GACR,IAAMgD,EAAYhD,EAAMiD,OAAOjR,OAC/B,OAAO,IAAIoL,WACP,CACI,EACA,EACA,EACA,EAEA,EACA,GAAO4F,EACP,EACA,EACA,EAEA,EACA,GAAOA,EACP,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,GAEClL,OAAO,CAACkL,IACRlL,OAAOkI,EAAMiD,QACbnL,OAAO,CAAC,EAAM,EAAM,M,EAI1BoL,KAAP,SAAYlD,GACR,IAAMmD,EAAanD,EAAMmD,WACzB,OAAO3F,EAAIsB,IACPtB,EAAIC,MAAMyF,KACV,IAAI9F,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA4C,EAAM7C,aACN,EACA,GACA,EACA,EACA,EACA,EACAgG,GAAc,EAAI,IACL,IAAbA,EACA,EACA,IAEJ3F,EAAIsB,IAAItB,EAAIC,MAAMsF,KAAMvF,EAAIuF,KAAK/C,M,EAIlCoD,IAAP,SAAWpD,GACP,IAAMmD,EAAanD,EAAMmD,WACzB,OAAO3F,EAAIsB,IACPtB,EAAIC,MAAM,QACV,IAAIL,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA4C,EAAM7C,aACN,EACA,GACA,EACA,EACA,EACA,EACAgG,GAAc,EAAI,IACL,IAAbA,EACA,EACA,M,EAKL1B,KAAP,SAAYzB,GACR,OAAIA,EAAMpH,OAASgE,EAAUmB,MACXiC,EAAOqD,OAAyB,QAAhBrD,EAAM9C,MAI7BM,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAI0F,KAAalD,IAH/CxC,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAI4F,IAAYpD,IAK7B,IAAhCA,EAAM9C,MAAMrH,QAAQ,QACb2H,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAIkF,KAAa1C,IAEvDxC,EAAIsB,IAAItB,EAAIC,MAAMgE,KAAMjE,EAAIgB,KAAMhB,EAAIqE,KAAa7B,K,EAGvDsD,KAAP,SAAYtD,GACR,IAAMuD,EAAKvD,EAAMuD,GACb5D,EAAWK,EAAML,SAAWK,EAAMN,UAClCE,EAAoBtC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxDyC,EAAoBxC,KAAKuC,MAAMF,GAAYtC,EAAa,IACxD8E,EAAQ,EACRC,EAAS,EAOb,OANIpC,EAAMzP,eAAe,WACrB4R,EAAQnC,EAAMmC,OAEdnC,EAAMzP,eAAe,YACrB6R,EAASpC,EAAMoC,QAEZ5E,EAAIsB,IACPtB,EAAIC,MAAM6F,KACV,IAAIlG,WAAW,CACX,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAmG,GAAM,GAAK,IACXA,GAAM,GAAK,IACXA,GAAM,EAAI,IACL,IAALA,EACA,EACA,EACA,EACA,EACA3D,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACAE,GAAqB,GACrBA,GAAqB,GAAK,IAC1BA,GAAqB,EAAI,IACL,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACAqC,GAAS,EAAI,IACL,IAARA,EACA,EACA,EACAC,GAAU,EAAI,IACL,IAATA,EACA,EACA,M,EAKL1B,KAAP,SAAYV,EAAcS,GACtB,IAAM+C,EAAwBhG,EAAI2D,KAAKnB,GACnCuD,EAAKvD,EAAMuD,GACXE,EAA+BnG,KAAKuC,MAAMY,GAAuBpD,EAAa,IAC9EqG,EAA+BpG,KAAKuC,MAAMY,GAAuBpD,EAAa,IAClF,OAAOG,EAAIsB,IACPtB,EAAIC,MAAMiD,KACVlD,EAAIsB,IACAtB,EAAIC,MAAMkG,KACV,IAAIvG,WAAW,CACX,EACA,EACA,EACA,EACAmG,GAAM,GACNA,GAAM,GAAK,IACXA,GAAM,EAAI,IACL,IAALA,KAGR/F,EAAIsB,IACAtB,EAAIC,MAAMmG,KACV,IAAIxG,WAAW,CACX,EACA,EACA,EACA,EACAqG,GAAgC,GAChCA,GAAgC,GAAK,IACrCA,GAAgC,EAAI,IACL,IAA/BA,EACAC,GAAgC,GAChCA,GAAgC,GAAK,IACrCA,GAAgC,EAAI,IACL,IAA/BA,KAGRlG,EAAIqG,KACA7D,EACAwD,EAAsBxR,OACpB,GACA,GACA,EACA,GACA,EACI,GAEVwR,I,EASD1C,KAAP,SAAYd,GAGR,OAAOxC,EAAIsB,IAAItB,EAAIC,MAAMqD,KAAMtD,EAAI8F,KAAsBtD,GAAQxC,EAAIuC,KAAKC,K,EAGvEiB,KAAP,SAAYjB,GACR,IAAMuD,EAAKvD,EAAMuD,GACjB,OAAO/F,EAAIsB,IACPtB,EAAIC,MAAMwD,KACV,IAAI7D,WAAW,CACX,EACA,EACA,EACA,EACAmG,GAAM,GACNA,GAAM,GAAK,IACXA,GAAM,EAAI,IACL,IAALA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,M,EAKLM,KAAP,SAAY7D,EAAc8D,GACtB,IAIIpV,EACAqV,EACApE,EACAtL,EACA+M,EACA9M,EATA+M,EAAUrB,EAAMqB,SAAW,GAC3B9F,EAAM8F,EAAQrP,OACdgS,EAAW,GAAK,GAAKzI,EACrB0I,EAAQ,IAAI7G,WAAW4G,GAyB3B,IAlBAF,GAAU,EAAIE,EACdC,EAAMtJ,IACF,CACI,EACA,EACA,GACA,EACAY,IAAQ,GAAK,IACbA,IAAQ,GAAK,IACbA,IAAQ,EAAI,IACN,IAANA,EACAuI,IAAW,GAAK,IAChBA,IAAW,GAAK,IAChBA,IAAW,EAAI,IACN,IAATA,GAEJ,GAECpV,EAAI,EAAGA,EAAI6M,EAAK7M,IAEjBiR,GADAoE,EAAS1C,EAAQ3S,IACCiR,SAClBtL,EAAO0P,EAAO1P,KACd+M,EAAQ2C,EAAO3C,MACf9M,EAAMyP,EAAOzP,IACb2P,EAAMtJ,IACF,CACIgF,IAAa,GAAK,IAClBA,IAAa,GAAK,IAClBA,IAAa,EAAI,IACN,IAAXA,EACAtL,IAAS,GAAK,IACdA,IAAS,GAAK,IACdA,IAAS,EAAI,IACN,IAAPA,EACA+M,EAAM8C,WAAa,EAAI9C,EAAME,UAC7BF,EAAMG,cAAgB,EAChBH,EAAMI,eAAiB,EACvBJ,EAAM+C,cAAgB,EACtB/C,EAAMgD,UACO,MAAnBhD,EAAMiD,WACa,GAAnBjD,EAAMiD,WACN/P,IAAQ,GAAK,IACbA,IAAQ,GAAK,IACbA,IAAQ,EAAI,IACN,IAANA,GAEJ,GAAK,GAAK5F,GAGlB,OAAO8O,EAAIsB,IAAItB,EAAIC,MAAMoG,KAAMI,I,EAG5BK,YAAP,SAAoC1D,GAC3BpD,EAAIC,OACLD,EAAIrF,OAIR,IAFA,IAAI4G,EAAOvB,EAAIqB,SACXnQ,EAAIkS,EAAO5O,OACRtD,KACoB,UAAnBkS,EAAOlS,GAAGkK,MAAwD,IAApCgI,EAAOlS,GAAGwO,MAAMrH,QAAQ,UACtDkJ,EAAOvB,EAAIwB,WAGnB,IAAMuF,EAAQ/G,EAAImD,KAAKC,GACjBxB,EAAS,IAAIhC,WAAW2B,EAAKM,WAAakF,EAAMlF,YAGtD,OAFAD,EAAOzE,IAAIoE,GACXK,EAAOzE,IAAI4J,EAAOxF,EAAKM,YAChBD,G,KArrCT5B,EACKC,W,EADLD,EAEKK,gB,EAFLL,EAIKU,U,EAJLV,EAKKW,U,EALLX,EAMKY,U,EANLZ,EAOKa,U,EAPLb,EAQKc,U,EARLd,EASKe,U,EATLf,EAUKgB,U,EAVLhB,EAWKqB,c,EAXLrB,EAYKwB,e,EAZLxB,EAaKyB,U,EA4qCIzB,Q,sKC9qCf,IAwkCegH,E,WA1hCX,WAAYC,EAAoBxB,EAAwByB,EAA8BC,QAAqB,IAArBA,MAAiB,IAAI,KAzBnGC,eAyBmG,OAxBnGC,aAwBmG,OAvBnGC,oBAuBmG,OAtBnGC,eAsBmG,OArBnGC,oBAqBmG,OApBnGC,YAoBmG,OAnBnGC,gBAmBmG,OAlBnGC,2BAkBmG,OAjBnGC,cAAwB,EAiB2E,KAhBnGC,gBAgBmG,OARnGC,YAQmG,OANnGC,mBAMmG,OALnGC,iBAKmG,OAJnGC,cAImG,OAHnGC,cAGmG,OAFnGC,aAA2C,GAG/CrX,KAAKsW,UAAYH,EACjBnW,KAAKuW,QAAU5B,EACf3U,KAAKwW,eAAiBJ,EACtB,IAAMjP,EAAYD,UAAUC,UAC5BnH,KAAKyW,cAAeJ,GAAUA,EAAO9O,QAAQ,UAAY,GAAKJ,IAAcA,EAAUE,MAAM,UAC5FrH,KAAK8W,cAAe,EACpB9W,KAAK2W,QAAUhC,EAAO2C,SAEtBtX,KAAKuX,kBACLvX,KAAK4W,WAAwB,GACxB1H,EAAIC,OACLD,EAAIrF,OAIR7J,KAAK0W,kBACD3P,IAAQsB,UACHtB,IAAQY,QAAQK,MAAQ,IAAiC,KAA1BjB,IAAQY,QAAQK,OAAgBjB,IAAQY,QAAQS,MAAQ,O,iCAS7FoP,QAAP,SAAeC,GACPA,IACAzX,KAAK8W,aAAeW,EAAKC,YACzB1X,KAAKiX,cAAgBQ,EAAKE,aAC1B3X,KAAKkX,YAAcO,EAAKG,WACxB5X,KAAKmX,SAAWM,EAAKI,QACrB7X,KAAKoX,SAAWK,EAAKK,QACrB9X,KAAK+W,WAAWgB,UAAYN,EAAKO,UAAUD,UAC3C/X,KAAK+W,WAAWkB,SAAWR,EAAKO,UAAUC,SAC1CjY,KAAK+W,WAAWmB,eAAiBT,EAAKO,UAAUE,eAChDlY,KAAK+W,WAAWoB,SAAWV,EAAKO,UAAUG,SAC1CnY,KAAK+W,WAAWqB,SAAWX,EAAKO,UAAUI,SAC1CpY,KAAK+W,WAAWsB,OAASZ,EAAKO,UAAUK,S,EAGzCC,QAAP,WACI,MAAO,CACHZ,YAAa1X,KAAK8W,aAClBa,aAAc3X,KAAKiX,cACnBW,WAAY5X,KAAKkX,YACjBW,QAAS7X,KAAKmX,SACdW,QAAS9X,KAAKoX,SACdY,UAAW,CACPD,UAAW/X,KAAK+W,WAAWgB,UAC3BE,SAAUjY,KAAK+W,WAAWkB,SAC1BC,eAAgBlY,KAAK+W,WAAWmB,eAChCC,SAAUnY,KAAK+W,WAAWoB,SAC1BC,SAAUpY,KAAK+W,WAAWqB,SAC1BC,OAAQrY,KAAK+W,WAAWsB,U,EAKpCE,QAAA,a,EAEAC,SAAA,SAAStH,GACLlR,KAAKgX,OAAS9F,G,EAGlBuH,eAAA,SAAeC,GACX1Y,KAAKmX,SAAWnX,KAAKoX,SAAWsB,EAChC1Y,KAAKuX,mB,EAGToB,iBAAA,WACI3Y,KAAK8W,cAAe,EACpB9W,KAAKqX,aAAe,GACpBrX,KAAK4Y,c,EAGTC,WAAA,WACI,MAAO,CAAErJ,MAAOxP,KAAK+W,WAAWoB,SAAU1I,MAAOzP,KAAK+W,WAAWqB,W,EAGrEU,MAAA,SAAMC,QAAsB,IAAtBA,MAAmB,GACrB,IAAIC,EAAY,KAChB,GAAIhZ,KAAK2W,QAAU3W,KAAK6W,sBAAuB,CAC3C,IAAM9R,EAAO/E,KAAK4W,WAClB7R,EAAK2M,MAAMqB,QAAU,CAAC/S,KAAK6W,uBAC3B7W,KAAK6W,sBAAwB,KAC7B9R,EAAK8M,gBAAkB,EACvBmH,EAAYhZ,KAAKiZ,WAAWlU,EAAK2M,MAAO3M,EAAKmU,YAAY,EAAMH,EAAkBhU,EAAKoU,oBAG1F,OADAnZ,KAAK4Y,aACEI,G,EAGXJ,WAAA,WACI5Y,KAAK6W,sBAAwB,KAC7B7W,KAAK4W,WAAwB,I,EAGjCwC,MAAA,SACIC,EACAC,EACAJ,EACAK,EACAJ,EACAK,GAYA,QAXF,IADEA,OAAmB,GAGdxZ,KAAK8W,cACN9W,KAAKyZ,WAAWJ,EAAYC,EAAYJ,IAIvCK,GAAcD,EAAWvG,QAAQrP,SAClC4V,EAAWvG,QAAQ,GAAG2G,IAAMJ,EAAWvG,QAAQ,GAAG4G,KAGlD3Z,KAAK8W,aAAc,CACnB,IAAM8C,EAAsBJ,GAAWxZ,KAAK6W,sBAAwB,EAAI,EAClEgD,EAAiBR,EAAWtG,QAAQrP,OACpCoW,EAAiBR,EAAWvG,QAAQrP,OACtCqW,EAAkBb,EAClBc,EAAkBd,EACtB,GAAIW,GAAkBC,EAClB,IAAKP,GAAcJ,GAEf,GAAIE,EAAWtG,QAAQ,GAAG2G,IAAMJ,EAAWvG,QAAQ,GAAG2G,IAAM,EAAG,CAC3D,IAAMjE,EAAS3U,OAAA,IAAAA,CAAc,GAAIwY,EAAWvG,QAAQ,IACpD0C,EAAOkE,IAAMlE,EAAOiE,IAAML,EAAWtG,QAAQ,GAAG2G,IAChDJ,EAAWvG,QAAQpP,QAAQ8R,QAE5B,CAKH,IAAMwE,GACDZ,EAAWtG,QAAQ,GAAG2G,IAAMJ,EAAWvG,QAAQ,GAAG2G,KAAOJ,EAAWY,eACzEH,GAAmB/K,KAAKmL,IAAI,EAAGF,GAC/BD,GAAmBhL,KAAKmL,IAAI,GAAIF,GAMxC,GAAIJ,EAAgB,CAEXR,EAAWjI,YACZxN,IAAIkB,EAAE,4CACN9E,KAAKyZ,WAAWJ,EAAYC,EAAYJ,IAE5C,IAEIH,EAFEqB,EAAYpa,KAAKqa,WAAWhB,EAAYU,EAAiBR,EAAYJ,GAGvEiB,IACArB,EAAmBqB,EAAUE,OAASF,EAAUG,UAEhDT,GAEKR,EAAWlI,YACZxN,IAAIkB,EAAE,4CACN9E,KAAKyZ,WAAWJ,EAAYC,EAAYJ,IAE5ClZ,KAAKiZ,WACDK,EACAU,EACAT,EACAR,EACAI,EACAK,IAGJxZ,KAAK8Y,MAAMC,OAEZ,CAEH,IAAIC,EAAY,KACZc,EACAd,EAAYhZ,KAAKiZ,WACbK,EACAU,EACAT,EACA,EACAJ,EACAK,GAEGI,IACPZ,EAAYhZ,KAAK8Y,SAGjBE,GACAK,EAAWzK,OACX,EAAgBoK,EAAUwB,WAC1B,EAAgBxB,EAAUyB,SAE1Bza,KAAK0a,gBAAgBrB,EAAYU,EAAiBR,EAAYP,M,EAM9ES,WAAA,SAAWJ,EAAoBC,EAAoBJ,GAC/C,IAQIrB,EACAC,EATE3B,EAAWnW,KAAKsW,UAClBqE,EAAetB,EAAWtG,QAC1B6H,EAAetB,EAAWvG,QAC1BqD,EAAgBpW,KAAKwW,eACrBlE,EAAc,GACdpB,EAAO,CAAEoB,OAAQA,GACjBuI,OAAyC,IAAlB7a,KAAKmX,SAC5B2D,EAAY,YAyChB,GArCID,IACAhD,EAAUC,EAAUiD,KAGpB1B,EAAW1E,QAAUgG,EAAajX,SAKlC2V,EAAWjI,UAAYiI,EAAWxE,WAClCjR,IAAIqB,EAAJ,yBAA+BoU,EAAWxE,YACrCwE,EAAWtE,QACRqB,EAAc4E,MAEdF,EAAY,aACZzB,EAAWzK,MAAQ,IACZwH,EAActB,MAErBuE,EAAWzK,MAAQ,QAG3B5O,KAAKqX,aAAa5H,OACb4J,EAAWtE,OAASqB,EAAc4E,KAAO,IAAIlM,WAAeI,EAAI8G,YAAY,CAACqD,IAClF/G,EAAO7C,MAAQ,CACXqL,UAAWA,EACXlM,MAAOyK,EAAWzK,MAClBqM,SAAU,CACNpM,aAAcwK,EAAWxK,aACzBqM,gBAAiB7B,EAAWxE,aAGhCgG,IAEAhD,EAAUC,EAAU6C,EAAa,GAAGjB,IAAML,EAAWa,eAAiBhB,IAI1EI,EAAW9F,KAAO8F,EAAW7F,KAAOmH,EAAalX,OAAQ,CAGzD,IAAMwW,EAAiBZ,EAAWY,eAClCZ,EAAWlI,UAAY8I,EACvBla,KAAKqX,aAAa7H,MAAQN,EAAI8G,YAAY,CAACsD,IAC3ChH,EAAO9C,MAAQ,CACXsL,UAAW,YACXlM,MAAO0K,EAAW1K,MAClBqM,SAAU,CACNpH,MAAOyF,EAAWzF,MAClBC,OAAQwF,EAAWxF,OACnBqH,IAAK7B,EAAW6B,IAChBC,QAAS9B,EAAW8B,QACpBvX,MAAOyV,EAAWzV,MAClBwX,aAAc/B,EAAW+B,eAG7BR,IACAhD,EAAU7I,KAAKsM,IAAIzD,GAAoBkD,IAAUH,EAAa,GAAGlB,IAAMQ,EAAiBhB,GACxFpB,EAAU9I,KAAKsM,IAAIxD,GAAoBiD,IAAUH,EAAa,GAAGjB,IAAMO,EAAiBhB,GACxFlZ,KAAKsW,UAAUlI,QAAQhM,IAAUc,eAAgB,CAAE2U,QAASA,KAIhE/W,OAAOkN,KAAKsE,GAAQ5O,QACpByS,EAAS/H,QAAQhM,IAAUE,qBAAsB4O,GACjDlR,KAAK8W,cAAe,EAChB+D,IACA7a,KAAKmX,SAAWU,EAChB7X,KAAKoX,SAAWU,IAGpB3B,EAAS/H,QAAQhM,IAAUQ,MAAO,CAC9B0H,KAAMpF,IAAWqW,UACjBC,QAASrW,IAAasW,cACtBC,OAAO,EACPC,OAAQ,kC,EAKpB1C,WAAA,SACIvH,EACAwH,EACAK,EACAR,EACAI,EACAK,QACF,IAFEL,OAA8B,QAEhC,IADEK,OAAmB,GAEnB,IAUIvI,EACAgB,EAGA2J,EACAC,EAfEC,EAAYpK,EAAMN,UACpB2K,EAAerK,EAAMqB,QACrBiJ,EAAgB,GAChBC,EAAejc,KAAKkc,cACpBrE,EAAU7X,KAAKmX,SACfgF,EAAYJ,EAAa,GAAGI,UAAY,IACxCxa,EAAMoa,EAAa,GAAGpa,IACtBya,EAAOpc,KAAK+W,WACZvB,EAAS,EACT6G,EAAoB,EAGpBC,EAAW,EACXrE,EAAW,EAGXF,EAAYgE,EAAarY,OAC7B,QAAuB,IAAZmU,EAAX,CAiBA,IAAID,EAAa5X,KAAKkX,YAEhBqF,EAAWvc,KAAKyW,UACtB,GAAkB,IAAdsB,GAAuC,IAApBrG,EAAMN,UACzB,OAAO,KA0BX,GArBImL,IAMAhD,EACIA,MAEIwC,EAAarY,QACbkU,IACEuB,GAAsBnK,KAAKwN,IAAItD,EAAatB,EAAakE,GAAa,IACpE9M,KAAKwN,IAAIT,EAAa,GAAGrC,IAAM9B,EAAaC,GAAWiE,EAAY,KAI9EvC,IAED3B,EAAasB,EAAa4C,EAC1B9b,KAAKuX,wBAEiB,IAAfK,EAAX,CAKAmE,EAAaU,SAAQ,SAAUhH,GAC3BA,EAAOiE,IAAMuC,EAAaxG,EAAOiE,IAAM7B,EAASD,GAChDnC,EAAOkE,IAAMsC,EAAaxG,EAAOkE,IAAM9B,EAASD,MAIpDmE,EAAaW,MAAK,SAAUC,EAAGC,GAC3B,IAAMC,EAAWF,EAAEhD,IAAMiD,EAAEjD,IACrBmD,EAAWH,EAAEjD,IAAMkD,EAAElD,IAC3B,OAAOmD,GAAaC,GAAYH,EAAE1H,GAAK2H,EAAE3H,MAI7C,IAAM8H,EAAchB,EAAaiB,QAC7B,SAACC,EAAMC,GAAP,OAAgBlO,KAAKmL,IAAInL,KAAKsM,IAAI2B,EAAMC,EAAKxD,IAAMwD,EAAKvD,MAAO,QAC/D,GAEJ,GAAIoD,EAAc,EAAG,CACjBnZ,IAAIkB,EAAJ,wDAC4DkK,KAAKmO,MACzDJ,EAAc,IAFtB,8BAKA,IAAK,IAAI3c,EAAI,EAAGA,EAAI2b,EAAarY,OAAQtD,IACrC2b,EAAa3b,GAAGuZ,KAAOoD,EAI3B/c,KAAK2W,SACL3W,KAAK4W,WAAWsC,WAAaA,EAC7BlZ,KAAK4W,WAAWuC,mBAAqBA,EACrCnZ,KAAK4W,WAAWlF,MAAQA,EACpB1R,KAAK6W,wBACLkB,IACAgE,EAAapY,QAAQ3D,KAAK6W,uBAC1B7W,KAAK6W,sBAAwB,MAE7BkF,EAAarY,OAAS,IAAM8V,IAC5BxZ,KAAK6W,sBAAwBkF,EAAanO,MAC1CmK,MAIR,IAAItC,EAASsG,EAAa,GAC1B9D,EAAWjJ,KAAKmL,IAAI1E,EAAOkE,IAAK,GAChC2C,EAAWtN,KAAKmL,IAAI1E,EAAOiE,IAAK,GAGhC,IAAM0D,EAAQpO,KAAKmO,OAAOlF,EAAWL,GAAc,IAE/C2B,GACI6D,IACIA,EAAQ,EACRxZ,IAAIqB,EAAJ,OAAamY,EAAb,kDACOA,GAAS,GAChBxZ,IAAIqB,EAAJ,QAAcmY,EAAd,8CAGJd,EAAWtN,KAAKmL,IAAImC,GAAYrE,EAAWL,GAAaA,GAExDK,EAAWL,EACXmE,EAAa,GAAGpC,IAAM1B,EAEtB8D,EAAa,GAAGrC,IAAM4C,EACtB1Y,IAAIqB,EAAJ,2BAC+B+J,KAAKmO,MAAMb,EAAW,IADrD,IAC4DtN,KAAKmO,MACzDlF,EAAW,IAFnB,UAGemF,EAHf,QASR3H,EAASsG,EAAaA,EAAarY,OAAS,GAC5CmY,EAAU7M,KAAKmL,IAAI1E,EAAOkE,IAAK,GAC/BiC,EAAU5M,KAAKmL,IAAI1E,EAAOiE,IAAK,EAAGmC,GAK9BU,IACAF,EAAoBrN,KAAKmO,OAAOtB,EAAU5D,IAAa8D,EAAarY,OAAS,KAKjF,IAFA,IAAI2Z,EAAS,EACTC,EAAU,EACLld,EAAI,EAAGA,EAAI2X,EAAW3X,IAAK,CAMhC,IAJA,IAAMqV,EAASsG,EAAa3b,GACxBmd,EAAQ9H,EAAO8H,MACfC,EAAUD,EAAM7Z,OAChB+Z,EAAY,EACPC,EAAI,EAAGA,EAAIF,EAASE,IACzBD,GAAaF,EAAMG,GAAGxM,KAAKxN,OAG/B4Z,GAAWG,EACXJ,GAAUG,EACV/H,EAAO/R,OAAS+Z,EAKZhI,EAAOkE,IAFP4C,EAEatE,EAAW7X,EAAIic,EAGfrN,KAAKmL,IAAI1E,EAAOkE,IAAK1B,GAGtCxC,EAAOiE,IAAM1K,KAAKmL,IAAI1E,EAAOiE,IAAKjE,EAAOkE,KAK7C,IAAMgE,EAAWL,EAAU,EAAID,EAAS,EACxC,IACIpM,EAAO,IAAInC,WAAW6O,GACxB,MAAO9Q,GAQL,OAPA7M,KAAKsW,UAAUlI,QAAQhM,IAAUQ,MAAO,CACpC0H,KAAMpF,IAAWqW,UACjBC,QAASrW,IAAayY,kBACtBlC,OAAO,EACP9I,MAAO+K,EACPhC,OAAQ,8BAA8BgC,IAEnC,KAEX,IAAME,EAAO,IAAIC,SAAS7M,EAAK8M,QAC/BF,EAAKG,UAAU,EAAGL,GAClB1M,EAAK5E,IAAI6C,EAAIC,MAAM8B,KAAM,GAEzB,IAAK,IAAI7Q,EAAI,EAAGA,EAAI2X,EAAW3X,IAAK,CAMhC,IALA,IAAM6d,EAAYlC,EAAa3b,GAC3B8d,EAAiBD,EAAUV,MAC3BY,EAAkB,EAClBC,OAAqB,EAEhBV,EAAI,EAAGF,EAAUU,EAAexa,OAAQga,EAAIF,EAASE,IAAK,CAC/D,IAAMW,EAAOH,EAAeR,GACxBY,EAAWD,EAAKnN,KAChBqN,EAAcF,EAAKnN,KAAKH,WAC5B8M,EAAKG,UAAUxI,EAAQ+I,GACvB/I,GAAU,EACVvE,EAAK5E,IAAIiS,EAAU9I,GACnBA,GAAU+I,EACVJ,GAAmB,EAAII,EAG3B,GAAKhC,EAkDD6B,EAAwBpP,KAAKmL,IACzB,EACAkC,EAAoBrN,KAAKmO,OAAOc,EAAUvE,IAAMuE,EAAUtE,KAAO0C,QApD1D,CAEX,GAAIjc,EAAI2X,EAAY,EAChBsE,EAAoBN,EAAa3b,EAAI,GAAGuZ,IAAMsE,EAAUtE,QACrD,CACH,IAAMhF,EAAS3U,KAAKuW,QAChBiI,GAAoB,EAUxB,GARIA,GADAxe,KAAK6W,sBACe7W,KAAK6W,sBAAsB8C,IAAMsE,EAAUtE,IAG3DjI,EAAM+M,mBACNrC,EAAKlE,gBACL+F,EAAUtE,IAAMoC,EAAa3b,EAAI,EAAIA,EAAI,EAAIA,GAAGuZ,IAExD6E,GAAyD,GAArCxP,KAAKuC,MAAMiN,GAAoB,IAC/C7J,EAAO+J,wBAA0B1e,KAAKiX,cAAe,CAOrD,IAAM0H,GAAgBhK,EAAOgK,cACzBC,GAAe5P,KAAKuC,MAAMoN,GAAgB7C,GAC1C+C,IACK9F,EAAmBuD,EAAWvD,EAAmB+C,EAAY9b,KAAKiX,eACnEgH,EAAUvE,IACdmF,GAAkBD,KAGlBvC,EAAoBwC,GAAkBL,IACd,IACpBnC,EAAoBmC,IAGxB5a,IAAIqB,EAAJ,uBAC2B4Z,GACvB,GAFJ,2CAEiDxC,EAC7C,GAHJ,kCAMAA,EAAoBmC,QAGxBnC,EAAoBmC,GAG5BJ,EAAwBpP,KAAKmO,MAAMc,EAAUvE,IAAMuE,EAAUtE,KASjE,GAAI0C,EAAoB,GAAK1S,MAAM0S,GAAoB,CACnD,IAAIyC,GAAM,EACNvF,GAAcwC,EAAarY,OAAS,IACpCob,GAAc,GAAR1B,GAEVf,EAAoBrN,KAAKmL,KAAKzI,EAAM+M,mBAAqBrC,EAAKlE,gBAAkB4G,GAAK,IAGzF9C,EAAclR,KAAK,CACf/E,KAAMoY,EAEN9M,SAAUgL,EACVrW,IAAKoY,EACLtL,MAAO,CACH8C,UAAW,EACX3C,aAAc,EACdC,cAAe,EACf6C,WAAY,EACZ/C,UAAWiL,EAAUtc,IAAM,EAAI,EAC/BmU,UAAWmI,EAAUtc,IAAM,EAAI,KAM3C3B,KAAKkX,YAAc2E,EAAUQ,EAC7B,IAAM0C,GAAUrN,EAAMqN,QAEtB,GADArN,EAAMqN,QAAU,EACZ/C,EAActY,QAAU1D,KAAK0W,eAAgB,CAC7C,IAAM5D,GAAQkJ,EAAc,GAAGlJ,MAG/BA,GAAME,UAAY,EAClBF,GAAMgD,UAAY,EAEtBpE,EAAMqB,QAAUiJ,EAChB/J,EAAO/C,EAAI+C,KAAKP,EAAMG,iBAAkBoG,EAAUvG,GAClDA,EAAMqB,QAAU,GAEhB,IAAM7B,GAAY,CACdL,QAAS7Q,KAAKgf,YAAY,QAAS/M,EAAMhB,GACzCsJ,SAAU+B,EAAWR,EACrBxB,QAASsB,EAAUS,GAAqBP,EACxCtB,SAAUvC,EAAW6D,EACrBrB,OAAQza,KAAKkX,YAAc4E,EAC3BxR,KAAM,QACN2U,UAAU,EACVC,UAAU,EACVC,GAAInD,EAActY,OAClBqb,QAASA,GACT5C,YACAxa,MACAyd,MAAOpf,KAAKgX,QAahB,OAXAhX,KAAK+W,WAAWoB,SAAWjH,GAAKoJ,OAChCta,KAAKsW,UAAUlI,QAAQhM,IAAUG,aAAc2O,IAGxB,IAAnBkL,EAAKrE,YACLqE,EAAKnE,SAAWA,GAEpBmE,EAAKrE,WAAaA,EAClBqE,EAAKlE,eAAiBlJ,KAAKmO,OAAOnd,KAAKkX,YAAckF,EAAKnE,UAAYmE,EAAKrE,WAC3EqE,EAAK/D,OAASrY,KAAKkX,YAEZhG,M,EAGXmJ,WAAA,SAAW3I,EAAewH,EAAoBK,EAAqBJ,GAC/D,QADoG,IAArCA,OAA8B,IACxFzH,EAAMqB,QAAQrP,OACf,OAAO,KAEX,IAWI2b,EACAC,EACArO,EACAgB,EACAqK,EACAV,EAhBE1B,EAAiBxI,EAAMwI,eACzBqF,EAAe7N,EAAMN,UACrBoO,EAActF,EAAiBqF,EAC/BlD,EAAoB3K,EAAMqD,MAAQ,KAAO,KACzC0K,EAAsBpD,EAAoBmD,EAC1CvD,EAAejc,KAAKkc,cACpBrE,EAAU7X,KAAKmX,SACfuI,GAAWhO,EAAMqD,OAAS/U,KAAKwW,eAAewE,KAC9CgB,EAAgB,GAChBG,EAAYzK,EAAMqB,QAAQ,GAAGoJ,UAAY,IACzC3G,EAASkK,EAAU,EAAI,EAOvB3D,EAAerK,EAAMqB,QACrB4E,EAAe3X,KAAKiX,cACpB0I,GAAW,EACf,QAAuB,IAAZ9H,EAAX,CAiCA,GAtBA0B,EACIA,MAEIwC,EAAarY,QACbiU,IACEwB,GAAsBnK,KAAKwN,IAAItD,EAAavB,EAAeuC,GAAkB,IAC3ElL,KAAKwN,IAAIT,EAAa,GAAGrC,IAAM/B,EAAeE,GAAW,GAAK4H,IAI1E1D,EAAaU,SAAQ,SAAUhH,GAC3BA,EAAOiE,IAAMjE,EAAOkE,IAAMsC,EAAaxG,EAAOiE,IAAM7B,EAASqB,EAAagB,MAWlD,KAL5B6B,EAAeA,EAAa6D,QAAO,SAAUnK,GACzC,OAAOA,EAAOiE,KAAO,MAIRhW,OACb,OAAO,KAkBX,GAhBK6V,QAAsC,IAAjB5B,IAOlBA,EANCwB,EAMcD,EAAagB,EAHb6B,EAAa,GAAGrC,IAKnCiG,GAAW,QAOa,IAAjBhI,EAAX,CAGA,GAAIjG,EAAMqD,MAEN,IADA,IAAM8K,EAAsB7f,KAAKuW,QAAQsJ,oBAChCzf,EAAI,EAAG0f,EAAUnI,EAAcvX,EAAI2b,EAAarY,QAAS,CAE9D,IAAM+R,EAASsG,EAAa3b,GAExBgd,EADM3H,EAAOiE,IACCoG,EAEZzO,EAAWrC,KAAKwN,IAAK,IAAOY,EAASlD,GAG3C,GAAIkD,IAAUyC,EAAsBJ,EAChC7b,IAAIkB,EAAJ,6BACiCgb,EAAU5F,GAAgB6F,QAAQ,GADnE,YACiF/Q,KAAKmO,MAC9E9L,GAFR,gBAKA0K,EAAaiE,OAAO5f,EAAG,QAQtB,GACDgd,GAASyC,EAAsBJ,GAC/BpO,EA1xBc,KA2xBdyO,EACF,CACE,IAAMG,EAAUjR,KAAKmO,MAAMC,EAAQqC,GACnC7b,IAAIkB,EAAJ,aACiBmb,EADjB,mBAC2CH,EAAU5F,GAAgB6F,QAC7D,GAFR,YAGiB/Q,KAAKmO,MAAO,IAAOC,EAASlD,GAH7C,YAKA,IAAK,IAAIwD,EAAI,EAAGA,EAAIuC,EAASvC,IAAK,CAC9B,IAAMwC,EAAWlR,KAAKmL,IAAI2F,EAAS,IACnCR,EAAY5Q,EAAIC,eAAe+C,EAAMyO,eAAiBzO,EAAM9C,MAAO8C,EAAM7C,iBAErEjL,IAAIqB,EAAE,qFACNqa,EAAY7J,EAAO4I,KAAK+B,YAE5BrE,EAAaiE,OAAO5f,EAAG,EAAG,CAAEie,KAAMiB,EAAW5F,IAAKwG,EAAUvG,IAAKuG,IACjEJ,GAAWL,EACXrf,IAIJqV,EAAOiE,IAAMjE,EAAOkE,IAAMmG,EAC1BA,GAAWL,EACXrf,SAGI4O,KAAKwN,IAAIY,GAOb3H,EAAOiE,IAAMjE,EAAOkE,IAAMmG,EAC1BA,GAAWL,EACXrf,IAQZ,IAFA,IAAI2X,EAAYgE,EAAarY,OACzBia,EAAW,EACR5F,KACH4F,GAAY5B,EAAahE,GAAWsG,KAAKtN,WAG7C,IAAK,IAAI2M,EAAI,EAAG3F,EAAYgE,EAAarY,OAAQga,EAAI3F,EAAW2F,IAAK,CACjE,IAAM2C,EAActE,EAAa2B,GAC3BW,EAAOgC,EAAYhC,KACrB3E,EAAM2G,EAAY3G,IAItB,QAAuB,IAAZkC,GAA2ByD,EAClCA,EAAUhO,SAAWrC,KAAKmO,OAAOzD,EAAMkC,GAAW4D,OAC/C,CACH,IAAMpC,EAAQpO,KAAKmO,MAAO,KAAQzD,EAAM/B,GAAiBuC,GACrDoG,EAAmB,EAIvB,GAAI/G,GAAc7H,EAAMqD,OAEhBqI,EAAO,CACP,GAAIA,EAAQ,GAAKA,EA51BP,IA61BNkD,EAAmBtR,KAAKmO,OAAOzD,EAAM/B,GAAgB8H,GACrD7b,IAAIqB,EAAKmY,EAAT,oDACIkD,EAAmB,KACnBhB,EAAY5Q,EAAIC,eAAe+C,EAAMyO,eAAiBzO,EAAM9C,MAAO8C,EAAM7C,iBAErEyQ,EAAYjB,EAAK+B,YAGrBzC,GAAY2C,EAAmBhB,EAAU5b,aAG1C,GAAI0Z,GAAS,GAAI,CAEpBxZ,IAAIqB,EAAJ,uDAEQ0S,EAAeuC,GACjB6F,QAAQ,GAHd,MAGsBrG,EAAMQ,GAAgB6F,QAAQ,GAHpD,MAG4D3C,EAH5D,MAKAO,GAAYU,EAAKtN,WACjB,SAGJ2I,EAAM/B,EAKd,GADA2E,EAAW5C,IACPiE,EAAW,GAsBX,OAFAjM,EAAMqB,QAAU,GAET,KArBP4K,GAAYnI,EACZ,IACIvE,EAAO,IAAInC,WAAW6O,GACxB,MAAO9Q,GAQL,OAPA7M,KAAKsW,UAAUlI,QAAQhM,IAAUQ,MAAO,CACpC0H,KAAMpF,IAAWqW,UACjBC,QAASrW,IAAayY,kBACtBlC,OAAO,EACP9I,MAAO+K,EACPhC,OAAQ,8BAA8BgC,IAEnC,KAEN+B,IACY,IAAI5B,SAAS7M,EAAK8M,QAC1BC,UAAU,EAAGL,GAClB1M,EAAK5E,IAAI6C,EAAIC,MAAM8B,KAAM,IAOjC,IAAK,IAAI7Q,EAAI,EAAGA,EAAIkgB,EAAkBlgB,KAClCkf,EAAY5Q,EAAIC,eAAe+C,EAAMyO,eAAiBzO,EAAM9C,MAAO8C,EAAM7C,iBAErEjL,IAAIqB,EAAE,qFACNqa,EAAYjB,EAAK+B,YAErBnP,EAAK5E,IAAIiT,EAAW9J,GACpBA,GAAU8J,EAAUvO,WACpBsO,EAAY,CACRtZ,KAAMuZ,EAAUvO,WAChB/K,IAAK,EACLqL,SAAU,KACVyB,MAAO,CACH8C,UAAW,EACX3C,aAAc,EACdC,cAAe,EACf6C,WAAY,EACZ/C,UAAW,IAGnBgJ,EAAclR,KAAKuU,GAG3B,IAAKpO,EACD,OAEJA,EAAK5E,IAAIgS,EAAM7I,GACf,IAAM+K,EAAUlC,EAAKtN,WACrByE,GAAU+K,EAEVlB,EAAY,CACRtZ,KAAMwa,EACNva,IAAK,EACLqL,SAAU,EACVyB,MAAO,CACH8C,UAAW,EACX3C,aAAc,EACdC,cAAe,EACf6C,WAAY,EACZ/C,UAAW,IAGnBgJ,EAAclR,KAAKuU,GACnBzD,EAAUlC,EAEd,IAAI8G,EAAqB,EAEzB,GADAzI,EAAYiE,EAActY,OACrB2b,EAAL,CAQA,GAJItH,GAAa,IACbyI,EAAqBxE,EAAcjE,EAAY,GAAG1G,SAClDgO,EAAUhO,SAAWmP,GAErBzI,GAAgC,iBAAZ6D,GAAwB3K,EAAM,CAC9CoO,GAAoC,IAAvBA,EAAUhO,WACvBgO,EAAUhO,SAAWK,EAAMqD,MAAQ,KAAO,MAG9C/U,KAAKiX,cAAgBU,EAAeiE,EAAU4D,GAAegB,GAAsBnE,GAEnF3K,EAAMqB,QAAUiJ,EAEZ/J,EADAyN,EACO,IAAI5Q,WAEJI,EAAI+C,KAAKP,EAAMG,iBAAkByK,EAAWkD,EAAa9N,GAGpEA,EAAMqB,QAAU,GAChB,IAAM0N,EAAQnE,EAAWpC,EACnBwG,EAAM/I,EAAeuC,EACrBE,EAAY,CACdvJ,QAAS7Q,KAAKgf,YAAY,QAAS/M,EAAMhB,GACzCsJ,SAAUkG,EACVnG,OAAQoG,EACRlG,SAAUiG,EACVhG,OAAQiG,EACRpW,KAAM,QACN2U,UAAU,EACVC,UAAU,EACVC,GAAIpH,EACJoE,YACAiD,MAAOpf,KAAKgX,QAIhB,OAFAhX,KAAK+W,WAAWqB,SAAWgC,EAAUE,OACrCta,KAAKsW,UAAUlI,QAAQhM,IAAUG,aAAc6X,GACxCA,EAMX,OAJIuF,UACO3f,KAAKiX,cAEhBvF,EAAMqB,QAAU,GACT,S,EAGX2H,gBAAA,SAAgBhJ,EAAewH,EAAoBK,EAAqBP,GACpE,QAA6B,IAAlBhZ,KAAKoX,SAAhB,CAGA,IAAM8C,EAAiBxI,EAAMwI,eAEzBsF,EAActF,GADCxI,EAAMmD,WAAanD,EAAMmD,WAAaqF,GAErDvC,EAAe3X,KAAKiX,cAEpBuD,QAC6B,IAAjB7C,EAA+BA,EAAeqB,EAAUwB,SAAWN,GAC3Ela,KAAKoX,SACTqD,EAASzB,EAAUyB,OAASP,EAAiBla,KAAKoX,SAGlDuJ,EADiB,KACDnB,EAEhBzH,EAAY/I,KAAK4R,MAAMnG,EAASD,GAAYmG,GAE5CE,EAAcnS,EAAIC,eAAe+C,EAAMyO,eAAiBzO,EAAM9C,MAAO8C,EAAM7C,cAI/E,GAFAjL,IAAIkB,EAAE,qBAED+b,EAAL,CAMA,IADA,IAAM9N,EAAU,GACP3S,EAAI,EAAGA,EAAI2X,EAAW3X,IAAK,CAChC,IAAM0gB,EAAQtG,EAAWpa,EAAIugB,EAC7B5N,EAAQjI,KAAK,CAAEuT,KAAMwC,EAAanH,IAAKoH,EAAOnH,IAAKmH,IAEvDpP,EAAMqB,QAAUA,EAEhB/S,KAAKqa,WAAW3I,EAAOwH,EAAYK,QAX/B3V,IAAIlD,EAAE,iG,EAcdwb,cAAA,SAAc7a,EAAe0f,GACzB,IAAIvL,EACJ,QAAyB,IAAduL,EACP,OAAO1f,EAaX,IARImU,EAFAuL,EAAY1f,GAEF,WAGD,WAKN2N,KAAKwN,IAAInb,EAAQ0f,GAAa,YACjC1f,GAASmU,EAGb,OAAOnU,G,EAGXkW,gBAAA,WACIvX,KAAK+W,WAAa,CAAEgB,UAAW,EAAGE,SAAU,EAAGC,eAAgB,IAAMC,SAAU,EAAGC,SAAU,I,EAGxF4G,YAAR,SAAoB1U,GAAgD,2BAA/BwB,EAA+B,iCAA/BA,EAA+B,kBAC5D9L,KAAKqX,aAAa/M,KAClBwB,EAAInI,QAAQ3D,KAAKqX,aAAa/M,WACvBtK,KAAKqX,aAAa/M,IAE7B,IAAM2C,EAAMnB,EAAIkR,QAAO,SAACC,EAAM+D,GAC1B,OAAIA,EACO/D,EAAO+D,EAAIjQ,WAEfkM,IACR,GACGnM,EAAS,IAAIhC,WAAW7B,GAC1BtG,EAAQ,EAOZ,OANAmF,EAAI2Q,SAAQ,SAAAuE,GACJA,IACAlQ,EAAOzE,IAAI2U,EAAKra,GAChBA,GAASqa,EAAIjQ,eAGdD,G,0CA9/BP,OAAO9Q,KAAK8W,kB,gCC3Eb,SAASmK,EAAgBvP,EAAeyE,EAAoBjF,EAAkBsE,EAAgB0L,GACjG,QAD0H,IAAzBA,MAAqB,KACjHxP,EAAMmD,WAAY,CACnB,IAAMF,ECKP,SAAwBwB,EAAoBpR,EAAemc,QAA2C,IAA3CA,MAAqB,IACnF,IAAIC,EACAxM,EACAyM,EAAarc,EAAKqc,WAClBC,EAAiBtc,EAAKsc,eACtBC,EAAevc,EAAKuc,aAClBna,EAAYD,UAAUC,UAAUC,cAClC+Y,EAAgBe,EAChBK,EAAiB,CAAC,KAAO,MAAO,KAAO,KAAO,MAAO,KAAO,KAAO,MAAO,KAAO,KAAO,MAAO,IAAM,MAEzG,OAAIF,EAAiB,GAAKA,GAAkBE,EAAe7d,QACvDyS,EAAS/H,QAAQhM,IAAUQ,MAAO,CAC9B0H,KAAMpF,IAAWqW,UACjBC,QAASrW,IAAasW,cACtBC,OAAO,EACPC,OAAQ,0BAA0B0F,IAE/B,MAEPC,EAAe,GAAKA,GAAgB,GACpCnL,EAAS/H,QAAQhM,IAAUQ,MAAO,CAC9B0H,KAAMpF,IAAWqW,UACjBC,QAASrW,IAAasW,cACtBC,OAAO,EACPC,OAAQ,wBAAwB2F,IAE7B,OAGX1d,IAAIqB,EAAJ,kBACsBic,EADtB,cAC8CE,EAD9C,mBAC2EC,EAD3E,IAEQE,EAAeF,GAFvB,qBAGyBC,GAGpB,WAAYE,KAAKra,GACdka,GAAkB,GAClBD,EAAa,EACbzM,EAAS,IAAI3I,MAAM,GAInBmV,EAA0BE,EAAiB,IAE3CD,EAAa,EACbzM,EAAS,IAAI3I,MAAM,GACnBmV,EAA0BE,IAGW,IAAlCla,EAAUI,QAAQ,YACzB6Z,EAAa,EACbzM,EAAS,IAAI3I,MAAM,GACnBmV,EAA0BE,IAM1BD,EAAa,EACbzM,EAAS,IAAI3I,MAAM,GAGfkV,KAAqD,IAAtCA,EAAW3Z,QAAQ,gBAA6D,IAArC2Z,EAAW3Z,QAAQ,gBACzE2Z,GAAcG,GAAkB,EAKpCF,EAA0BE,EAAiB,IAQvCH,IAC4C,IAArCA,EAAW3Z,QAAQ,eAClB8Z,GAAkB,GAAsB,IAAjBC,GAAuB,WAAYE,KAAKra,MACnE+Z,GAA+B,IAAjBI,KAElBF,EAAa,EACbzM,EAAS,IAAI3I,MAAM,IAEvBmV,EAA0BE,IAqClC1M,EAAO,GAAKyM,GAAc,EAE1BzM,EAAO,KAAwB,GAAjB0M,IAA0B,EACxC1M,EAAO,KAAwB,EAAjB0M,IAA0B,EAExC1M,EAAO,IAAM2M,GAAgB,EACV,IAAfF,IAEAzM,EAAO,KAAiC,GAA1BwM,IAAmC,EACjDxM,EAAO,IAAgC,EAA1BwM,IAAmC,EAGhDxM,EAAO,IAAM,EACbA,EAAO,GAAK,GAET,CACHA,OAAQA,EACRE,WAAY0M,EAAeF,GAC3BxS,aAAcyS,EACd1S,MAAO,WAAawS,EACpBjB,cAAeA,IDlJAsB,CAAetL,EAV/B,SAAmBjF,EAAkBsE,GACxC,MAAO,CACH4L,WAAYlQ,EAAKsE,EAAS,KAAO,EACjC6L,gBAAoC,EAAnBnQ,EAAKsE,EAAS,KAAc,EAAItE,EAAKsE,EAAS,KAAO,EACtE8L,cAAkC,IAAnBpQ,EAAKsE,EAAS,MAAe,GAMJkM,CAAUxQ,EAAMsE,GAAS0L,GAC7DvM,IACAjD,EAAMiD,OAASA,EAAOA,OACtBjD,EAAMN,UAAYM,EAAMmD,WAAaF,EAAOE,WAC5CnD,EAAM7C,aAAe8F,EAAO9F,aAC5B6C,EAAM9C,MAAQ+F,EAAO/F,MACrB8C,EAAMyO,cAAgBxL,EAAOwL,cAC7BzO,EAAMqD,OAAQ,I,0KEiIX4M,E,WA3HX,WAAYC,GAAwB,KAP5BC,aAO4B,OAN5BC,mBAM4B,OAL5BC,kBAK4B,OAJ5BC,iBAI4B,OAH5BC,mBAG4B,OAF5BC,6BAE4B,EAChCliB,KAAK6hB,QAAUD,EACf5hB,KAAK8hB,cAAgB,EACrB9hB,KAAK+hB,aAAeH,EAAW7Q,WAC/B/Q,KAAKgiB,YAAsC,EAAxBJ,EAAW7Q,WAC9B/Q,KAAKiiB,cAAgB,EACrBjiB,KAAKkiB,wBAA0B,E,iCAGnC3J,QAAA,WACIvY,KAAK6hB,QAAU,M,EAGnBM,iBAAA,WACI,IAAIC,EAAoBpiB,KAAK+hB,aAAe/hB,KAAK8hB,cACjD,GAAIM,GAAqB,IAAMpiB,KAAK6hB,QAChC,MAAM,IAAI7W,MAAM,wDAGpB,IAAIqX,EAAarT,KAAKsM,IAAI,EAAG8G,GACzBE,EAAO,IAAIxT,WAAW,GAC1BwT,EAAKjW,IAAIrM,KAAK6hB,QAAQzB,SAASpgB,KAAK8hB,cAAe9hB,KAAK8hB,cAAgBO,IACxEriB,KAAKiiB,cAAgB,IAAInE,SAASwE,EAAKvE,QAAQwE,UAAU,GAAG,GAE5DviB,KAAK8hB,eAAiBO,EACtBriB,KAAKkiB,wBAAuC,EAAbG,G,EAGnCG,SAAA,SAASC,GACL,GAAIA,EAAO,GACP,MAAM,IAAIzX,MAAM,mDAGpB,GAAIyX,GAAQziB,KAAKkiB,wBAAyB,CACtC,IAAIpR,EAAS9Q,KAAKiiB,gBAAmB,GAAKQ,EAG1C,OAFAziB,KAAKiiB,gBAAkBQ,EACvBziB,KAAKkiB,yBAA2BO,EACzB3R,EAGX,IAAIA,EAAS9Q,KAAKkiB,wBAA0BliB,KAAKiiB,cAAgB,EACjEnR,KAAqB,GAAK9Q,KAAKkiB,wBAC/B,IAAIQ,EAAiBD,EAAOziB,KAAKkiB,wBAEjCliB,KAAKmiB,mBACL,IAAIQ,EAAiB3T,KAAKsM,IAAIoH,EAAgB1iB,KAAKkiB,yBAE/CU,EAAU5iB,KAAKiiB,gBAAmB,GAAKU,EAK3C,OAJA3iB,KAAKiiB,gBAAkBU,EACvB3iB,KAAKkiB,yBAA2BS,EAEhC7R,EAAUA,GAAU6R,EAAkBC,G,EAI1CC,SAAA,WACI,OAA4B,IAArB7iB,KAAKwiB,SAAS,I,EAIzBM,UAAA,WACI,OAAO9iB,KAAKwiB,SAAS,I,EAGzBO,WAAA,WACI,OAAO/iB,KAAKwiB,SAAS,K,EAGzBQ,SAAA,WACI,OAAOhjB,KAAKwiB,SAAS,K,EAGzBS,SAAA,WACI,OAAOjjB,KAAKwiB,SAAS,I,EAGzBU,iBAAA,WACI,IAAIC,EACJ,IAAKA,EAAa,EAAGA,EAAanjB,KAAKkiB,wBAAyBiB,IAC5D,GAA2D,IAAtDnjB,KAAKiiB,cAAiB,aAAekB,GAGtC,OAFAnjB,KAAKiiB,gBAAkBkB,EACvBnjB,KAAKkiB,yBAA2BiB,EACzBA,EAIf,OADAnjB,KAAKmiB,mBACEgB,EAAanjB,KAAKkjB,oB,EAG7BE,QAAA,WAEI,IAAIC,EAAgBrjB,KAAKkjB,mBACzB,OAAOljB,KAAKwiB,SAASa,EAAgB,GAAK,G,EAG9CC,QAAA,WAEI,IAAIjiB,EAAQrB,KAAKojB,UACjB,OAAY,EAAR/hB,EACQA,EAAQ,IAAO,GAEf,GAAKA,IAAU,I,EAI/BkiB,cAAA,WAMI,OAJAvjB,KAAK8iB,YAEL9iB,KAAKojB,UAEEpjB,KAAKojB,W,EAGhBI,YAAA,WACI,OAAkD,GAA1CxjB,KAAK+hB,aAAe/hB,KAAK8hB,eAAqB9hB,KAAKkiB,yB,6CAI3D,OAAOliB,KAAK+hB,aAAe/hB,KAAK8hB,mB,gCC7HlC2B,EAAoC,CAAEC,EAAG,OAAQC,EAAG,UAAWC,EAAG,qBAAsBC,EAAG,QAC3FC,EAAsC,CACxCC,GAAI,EACJC,GAAI,EACJC,GAAI,IACJC,GAAI,EACJC,GAAI,IACJC,IAAK,EACLC,IAAK,IACLC,IAAK,EACLC,IAAK,IACLC,IAAK,IACLC,IAAK,EACLC,IAAK,IACLC,IAAK,IACLC,IAAK,KA0aMC,E,kCApYJC,WAAP,SAAkBlD,GAMd,IALA,IAAMmD,EAAMnD,EACNoD,EAAaD,EAAIhU,WACjBkU,EAAM,IAAInW,WAAWkW,GACvBE,EAAU,EAEL9kB,EAAI,EAAGA,EAAI4kB,EAAY5kB,IACxBA,GAAK,GAEU,IAAX2kB,EAAI3kB,IAA8B,IAAf2kB,EAAI3kB,EAAI,IAA8B,IAAf2kB,EAAI3kB,EAAI,KAI1D6kB,EAAIC,GAAWH,EAAI3kB,GACnB8kB,KAGJ,OAAO,IAAIpW,WAAWmW,EAAIlH,OAAQ,EAAGmH,I,EAGlCC,aAAP,SAAoBvD,GAChB,IAAMwD,EAAOP,EAAUC,WAAWlD,GAC9ByD,EAAuB,IAAI1D,EAAUyD,GACnCE,EAAW,CAAEC,YAAa,GAAIC,cAAe,IACnDH,EAAG7C,SAAS,IACZ6C,EAAG7C,SAAS,GACZ,IAAIiD,EAAiBJ,EAAG7C,SAAS,GAAK,EAGtC,GAFA6C,EAAG7C,SAAS,IAEPqC,EAAUa,UAAUL,EAAIC,EAAKG,GAC9B,OAAO,KAIX,GADeJ,EAAGjC,WAvFC,GAyFf,OAAO,KAEX,IAAIuC,EAAoBN,EAAGjC,UAEF,GAArBuC,IACmCN,EAAG7C,SAAS,KAE3CmD,EAAoB,IAI5B,IAAM9R,EAAQwR,EAAGjC,UACXtP,EAASuR,EAAGjC,UAIlB,OAHAiC,EAAG9M,UACH8M,EAAK,KAEE,CACHO,qBAA4C,IAAtBD,EAA0B,QAAU,QAC1DE,eAAgBP,EAAIC,YAAYM,eAChCC,aAAcR,EAAIC,YAAYO,aAC9BjS,MAAOA,EACPC,OAAQA,I,EAKT4R,UAAP,SAAiBL,EAAeC,EAAUS,GACtC,IACK/lB,KAAKgmB,wBAAwBX,EAAIC,EAAIC,cACtCF,EAAG7B,cAAgB,EAAI,IAASuC,EAAqB,EAAI,EAAI,EAAI,GAEjE,OAAO,EAGXT,EAAIC,YAAYU,UAAYZ,EAAG7C,SAAS,GACxC8C,EAAIC,YAAYO,aAAe9lB,KAAKkmB,mBAAmBZ,EAAIC,YAAYU,WACvEX,EAAIa,+BAAiC,GACrCb,EAAIc,6BAA+B,GACnC,IAAK,IAAIhmB,EAAI,EAAGA,EAAI2lB,EAAqB,EAAG3lB,IACxCklB,EAAIa,+BAA+B/lB,GAAKilB,EAAG7C,SAAS,GACpD8C,EAAIc,6BAA6BhmB,GAAKilB,EAAG7C,SAAS,GAGtD,GAAIuD,EAAqB,EAAI,EACzB,IAAK,IAAI3lB,EAAI2lB,EAAqB,EAAG3lB,EAAI,EAAGA,IACxCilB,EAAG7C,SAAS,GAGpB,IAAK,IAAIpiB,EAAI,EAAGA,EAAI2lB,EAAqB,EAAG3lB,IAAK,CAC7C,GAAIklB,EAAIa,+BAA+B/lB,IAAMJ,KAAKgmB,wBAAwBX,EAAIC,EAAIE,eAC9E,OAAO,EAEX,GAAIF,EAAIc,6BAA6BhmB,GAAI,CACrC,GAAIilB,EAAG7B,cAAgB,EACnB,OAAO,EACJ8B,EAAIE,cAAcplB,GAAG6lB,UAAYZ,EAAG7C,SAAS,IAG5D,OAAO,G,EAGJwD,wBAAP,SAA+BX,EAAeC,GAC1C,GAAID,EAAG7B,cAAgB,GACnB,OAAO,EAGX8B,EAAIe,cAAgBhB,EAAG7C,SAAS,GAChC8C,EAAIgB,UAAYjB,EAAG7C,SAAS,GAC5B8C,EAAIiB,YAAclB,EAAG7C,SAAS,GAC9B8C,EAAIkB,2BAA6B,GAEjC,IAAK,IAAIpmB,EAAI,EAAGA,EAAI,GAAIA,IACpBklB,EAAIkB,2BAA2BpmB,GAAKilB,EAAG7C,SAAS,GACzB,GAAnB8C,EAAIiB,aAAoBnmB,EAAI,GAAKklB,EAAIkB,2BAA2BpmB,KAAIklB,EAAIiB,YAAcnmB,GAW9F,OATAklB,EAAImB,wBAA0BpB,EAAG7C,SAAS,GAC1C8C,EAAIoB,uBAAyBrB,EAAG7C,SAAS,GACzC8C,EAAIqB,2BAA6BtB,EAAG7C,SAAS,GAC7C8C,EAAIsB,2BAA6BvB,EAAG7C,SAAS,GAE7C6C,EAAG7C,SAAS,IACZ6C,EAAG7C,SAAS,IACZ6C,EAAG7C,SAAS,IACZ8C,EAAIO,eAAiB7lB,KAAK6mB,qBAAqBvB,EAAIiB,cAC5C,G,EAGJO,SAAP,SAAgBlF,GACZ,IAAMwD,EAAOP,EAAUC,WAAWlD,GAC9ByD,EAAuB,IAAI1D,EAAUyD,GAEzCC,EAAGpC,WACH,IAAMsD,EAAclB,EAAGpC,WACvBoC,EAAGpC,WACH,IAAMgD,EAAYZ,EAAGpC,WACrBoC,EAAGjC,UAEH,IAAMyC,EAAiBhB,EAAUkC,iBAAiBR,GAC5CT,EAAejB,EAAUmC,eAAef,GAC1CN,EAAoB,EACpBsB,EAAgB,IAEhBC,EAAY,EAEhB,IACoB,MAAhBX,GACgB,MAAhBA,GACgB,MAAhBA,GACgB,MAAhBA,GACgB,KAAhBA,GACgB,KAAhBA,GACgB,KAAhBA,GACgB,MAAhBA,GACgB,MAAhBA,GACgB,MAAhBA,GACgB,MAAhBA,KAG0B,KAD1BZ,EAAoBN,EAAGjC,YAEnBiC,EAAG7C,SAAS,GAEZmD,GAAqB,IACrBsB,EArBoB,CAAC,EAAG,IAAK,IAAK,KAqBEtB,IAGxCuB,EAAY7B,EAAGjC,UAAY,EAC3BiC,EAAGjC,UACHiC,EAAG7C,SAAS,GACR6C,EAAGxC,YAGH,IADA,IAAMsE,EAA2C,IAAtBxB,EAA0B,EAAI,GAChDvlB,EAAI,EAAGA,EAAI+mB,EAAoB/mB,IAChCilB,EAAGxC,aAECziB,EAAI,EACJykB,EAAUuC,iBAAiB/B,EAAI,IAE/BR,EAAUuC,iBAAiB/B,EAAI,KAMnDA,EAAGjC,UACH,IAAMiE,EAAqBhC,EAAGjC,UAC9B,GAA2B,IAAvBiE,EACAhC,EAAGjC,eACA,GAA2B,IAAvBiE,EAA0B,CACjChC,EAAG7C,SAAS,GACZ6C,EAAG/B,UACH+B,EAAG/B,UAEH,IADA,IAAMgE,EAAwCjC,EAAGjC,UACxChjB,EAAI,EAAGA,EAAIknB,EAAuClnB,IACvDilB,EAAG/B,UAGX+B,EAAGjC,UACHiC,EAAG7C,SAAS,GAEZ,IAAM+E,EAA0BlC,EAAGjC,UAC7BoE,EAAiCnC,EAAGjC,UAEpCqE,EAAsBpC,EAAG7C,SAAS,GACZ,IAAxBiF,GACApC,EAAG7C,SAAS,GAEhB6C,EAAG7C,SAAS,GAEZ,IAAIkF,EAAyB,EACzBC,EAA0B,EAC1BC,EAAwB,EACxBC,EAA2B,EAEHxC,EAAGxC,aAE3B6E,EAAyBrC,EAAGjC,UAC5BuE,EAA0BtC,EAAGjC,UAC7BwE,EAAwBvC,EAAGjC,UAC3ByE,EAA2BxC,EAAGjC,WAGlC,IAAI0E,EAAY,EACZC,EAAa,EACb5M,EAAM,EACN6M,GAAY,EACZC,EAAU,EACVC,EAAU,EAGd,GADoC7C,EAAGxC,WACN,CAC7B,GAAIwC,EAAGxC,WAAY,CAEf,IAAMsF,EAAmB9C,EAAGpC,WAIxBkF,EAAmB,GAAKA,EAAmB,IAC3CL,EAJgB,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,EAAG,GAInDK,EAAmB,GAC3CJ,EAJgB,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAIjDI,EAAmB,IAChB,MAArBA,IACPL,EAAazC,EAAGpC,YAAc,EAAKoC,EAAGpC,WACtC8E,EAAc1C,EAAGpC,YAAc,EAAKoC,EAAGpC,YAqB/C,GAjBIoC,EAAGxC,YAEHwC,EAAGxC,WAEHwC,EAAGxC,aAEHwC,EAAG7C,SAAS,GACR6C,EAAGxC,YAEHwC,EAAG7C,SAAS,KAGhB6C,EAAGxC,aAEHwC,EAAGjC,UACHiC,EAAGjC,WAEHiC,EAAGxC,WAAY,CAEf,IAAMuF,EAAoB/C,EAAG7C,SAAS,IAChC6F,EAAahD,EAAG7C,SAAS,IAC/BwF,EAAY3C,EAAGxC,WAIf1H,GAFA8M,EAAUI,IACVH,EAA8B,EAApBE,IAKlB,IAAIE,EAAW,EACG,IAAdR,GAAkC,IAAfC,IACnBO,EAAWR,EAAYC,GAG3B,IAAIQ,EAAc,EACdC,EAAc,EACQ,IAAtB7C,GACA4C,EAAc,EACdC,EAAc,EAAIf,IAIlBc,EAFqC,IAAtB5C,EAA0B,EAAI,EAG7C6C,GAFqC,IAAtB7C,EAA0B,EAAI,IAErB,EAAI8B,IAGhC,IAAIgB,EAA8C,IAA/BlB,EAA0B,GACzCmB,EAAmF,IAAtClB,EAAiC,IAA9D,EAAIC,GAExBgB,IAAgBf,EAAyBC,GAA2BY,EACpEG,IAAiBd,EAAwBC,GAA4BW,EAErE,IAAMG,EAAgB3Z,KAAK4R,KAAK6H,EAAcH,GAK9C,OAHAjD,EAAG9M,UACH8M,EAAK,KAEE,CACHQ,iBACAC,eACAoB,YACAD,gBACArB,qBAAsBf,EAAU+D,sBAAsB3B,GAEtD4B,WAAY,CACRC,MAAOd,EACP7M,MACA+M,UACAD,WAGJc,UAAW,CACPlV,MAAOiU,EACPhU,OAAQiU,GAGZiB,WAAY,CACRnV,MAAO4U,EACP3U,OAAQ4U,GAGZO,aAAc,CACVpV,MAAO8U,EACP7U,OAAQ4U,K,EAKbtB,iBAAP,SAAwB/B,EAAela,GAInC,IAHA,IAAI+d,EAAa,EACbC,EAAa,EAER/oB,EAAI,EAAGA,EAAI+K,EAAO/K,IACJ,IAAf+oB,IAEAA,GAAcD,EADA7D,EAAG/B,UACwB,KAAO,KAEpD4F,EAA4B,IAAfC,EAAmBD,EAAaC,G,EAI9CpC,iBAAP,SAAwBR,GACpB,OAAQA,GACJ,KAAK,GACD,MAAO,WACX,KAAK,GACD,MAAO,OACX,KAAK,GACD,MAAO,WACX,KAAK,IACD,MAAO,OACX,KAAK,IACD,MAAO,SACX,KAAK,IACD,MAAO,UACX,KAAK,IACD,MAAO,UACX,QACI,MAAO,Y,EAIZS,eAAP,SAAsBf,GAClB,OAAQA,EAAY,IAAIlG,QAAQ,I,EAG7B6I,sBAAP,SAA6BQ,GACzB,OAAQA,GACJ,KAAK,IACD,MAAO,QACX,KAAK,IACD,MAAO,QACX,KAAK,IACD,MAAO,QACX,QACI,MAAO,Y,EAIZvC,qBAAP,SAA4BN,GACxB,OAAO9C,EAAU8C,I,EAGdL,mBAAP,SAA0BD,GACtB,OAAOnC,EAAYmC,I,KCnZ3B,SAASoD,EAAkBzH,EAAwBnB,EAAe6I,GAC9D,IAAI3T,EAAQiM,EACZ,GAAInB,EAAQ6I,EAAc3T,EAAMjS,OAAQ,CACpC,KAAO4lB,KACH,GAAgC,MAAV,IAAjB3T,IAAQ8K,IAAyB,OAAO,EAEjD,OAAO,EAEP,OAAO,EAGA8I,MAjEf,SAAoB3H,GAMhB,IALA,IAAMpd,EAAM,GACNglB,EAAQ5H,EACVxhB,EAAI,EACFsD,EAASke,EAAWle,OAEnBtD,EAAIsD,GACP,GAAI8lB,EAAMppB,GAAK,IACXoE,EAAIsG,KAAKG,OAAOwe,aAAaD,EAAMppB,OACjCA,MAFN,CAIO,GAAIopB,EAAMppB,GAAK,UAEf,GAAIopB,EAAMppB,GAAK,KAClB,GAAIipB,EAAkBG,EAAOppB,EAAG,GAAI,CAChC,IAAMspB,GAAoB,GAAXF,EAAMppB,KAAc,EAAqB,GAAfopB,EAAMppB,EAAI,GACnD,GAAIspB,GAAQ,IAAM,CACdllB,EAAIsG,KAAKG,OAAOwe,aAAoB,MAAPC,IAC7BtpB,GAAK,EACL,gBAGL,GAAIopB,EAAMppB,GAAK,KAClB,GAAIipB,EAAkBG,EAAOppB,EAAG,GAAI,CAChC,IAAMspB,GAAoB,GAAXF,EAAMppB,KAAa,IAAuB,GAAfopB,EAAMppB,EAAI,KAAc,EAAqB,GAAfopB,EAAMppB,EAAI,GAClF,GAAIspB,GAAQ,MAA6B,QAAZ,MAAPA,GAA2B,CAC7CllB,EAAIsG,KAAKG,OAAOwe,aAAoB,MAAPC,IAC7BtpB,GAAK,EACL,gBAGL,GAAIopB,EAAMppB,GAAK,KACdipB,EAAkBG,EAAOppB,EAAG,GAAI,CAChC,IAAIspB,GACa,EAAXF,EAAMppB,KAAa,IACJ,GAAfopB,EAAMppB,EAAI,KAAc,IACT,GAAfopB,EAAMppB,EAAI,KAAc,EACV,GAAfopB,EAAMppB,EAAI,GACf,GAAIspB,EAAO,OAAWA,EAAO,QAAU,CACnCA,GAAQ,MACRllB,EAAIsG,KAAKG,OAAOwe,aAAcC,IAAS,GAAM,QAC7CllB,EAAIsG,KAAKG,OAAOwe,aAAqB,KAAPC,EAAgB,QAC9CtpB,GAAK,EACL,UAIZoE,EAAIsG,KAAKG,OAAOwe,aAAa,UAC3BrpB,EAGN,OAAOoE,EAAImlB,KAAK,KC9CCC,E,kCAIVC,cAAP,SAAqB/d,GACjB,IAAIoF,EAAY,GAChB,IACI,IAAIvQ,EAAOipB,EAAIE,YAAYhe,EAAK,GAC5BzK,EAAQuoB,EAAIE,YAAYhe,EAAKnL,EAAKoF,MACtCmL,EAAKvQ,EAAKuQ,MAAQ7P,EAAM6P,KAC1B,MAAO3M,GACLX,IAAIW,EAAE,MAAOA,EAAEwlB,YAEnB,OAAO7Y,G,EAGJ8Y,YAAP,SAAmBC,EAA0BC,GACzC,IAAIvpB,EAAOipB,EAAIO,YAAYF,EAAaC,GACpC7oB,EAAQuoB,EAAIE,YAAYG,EAAaC,EAAavpB,EAAKoF,MACvDqkB,EAAc/oB,EAAMgpB,UAExB,MAAO,CACHnZ,KAAM,CACFvQ,KAAMA,EAAKuQ,KACX7P,MAAOA,EAAM6P,MAEjBnL,KAAM1E,EAAM0E,KACZskB,UAAWD,I,EAIZE,cAAP,SAAqBL,EAA0BC,GAC3C,OAAON,EAAII,YAAYC,EAAaC,I,EAEjCK,gBAAP,SAAuBN,EAA0BC,GAC7C,IACIxmB,EADI,IAAIoa,SAASmM,EAAaC,GACnB3H,UAAU,GASzB,MAAO,CACHrR,KAPAxN,EAAS,EACH6lB,EAAW,IAAIza,WAAWmb,EAAaC,EAAa,EAAGxmB,IAEvD,GAKNqC,KAAM,EAAIrC,I,EAGX8mB,UAAP,SAAiBP,EAA0BC,GACvC,IAAIjlB,EAAI,IAAI6Y,SAASmM,EAAaC,GAC9BpkB,EAAYb,EAAEwlB,WAAW,GACzBC,EAAkBzlB,EAAE0lB,SAAS,GAGjC,MAAO,CACHzZ,KAAM,IAAI0Z,KAHd9kB,GAA+B,GAAlB4kB,EAAuB,KAIhC3kB,KAAM,K,EAGPokB,YAAP,SAAmBF,EAA0BC,GACzC,IACIxmB,EADI,IAAIoa,SAASmM,EAAaC,GACnBW,UAAU,GAOzB,MAAO,CACH3Z,KANAxN,EAAS,EACH6lB,EAAW,IAAIza,WAAWmb,EAAaC,EAAa,EAAGxmB,IAEvD,GAINqC,KAAM,EAAIrC,I,EAIXomB,YAAP,SAAmBhe,EAAkBoe,GACjC,IAAIrkB,EAAWiG,EAAIiF,WACfyE,EAAS0U,EAETnM,EAASjS,EACTgf,EAAK,IAAIhN,SAASC,EAAQ,GAE1B1c,EAAa,KACbiJ,EAAOwgB,EAAGC,SAASvV,GACvBA,GAAU,EACV,IAAI6U,GAAY,EAEhB,OAAQ/f,GACJ,KAAK,EACDjJ,EAAQypB,EAAGL,WAAWjV,GACtBA,GAAU,EACV,MACJ,KAAK,EAGDnU,IADQypB,EAAGC,SAASvV,GAEpBA,GAAU,EACV,MAEJ,KAAK,EAED,IAAIwV,EAASpB,EAAIO,YAAYpM,EAAQvI,GACrCnU,EAAQ2pB,EAAO9Z,KACfsE,GAAUwV,EAAOjlB,KACjB,MAEJ,KAAK,EAED1E,EAAQ,GAKR,IAHkD,IAAhB,SAA7BypB,EAAGvI,UAAU1c,EAAW,KACd,EAER2P,EAAS3P,EAAW,GAAG,CAE1B,IAAIolB,EAASrB,EAAII,YAAYjM,EAAQvI,GAErC,GAAIyV,EAAOZ,UACP,MAEJhpB,EAAM4pB,EAAO/Z,KAAKvQ,MAAQsqB,EAAO/Z,KAAK7P,MAEtCmU,EAASyV,EAAOllB,KAEpB,GAAIyP,GAAU3P,EAAW,EAEN,KADyB,SAA3BilB,EAAGvI,UAAU/M,EAAS,MAE/BA,GAAU,GAGlB,MAEJ,KAAK,EAEDnU,EAAQ,GAERmU,GAAU,EAKV,IAHkD,IAAhB,SAA7BsV,EAAGvI,UAAU1c,EAAW,KACd,EAER2P,EAAS3P,EAAW,GAAG,CAE1B,IAAIqlB,EAAStB,EAAIU,cAAcvM,EAAQvI,GAEvC,GAAI0V,EAAOb,UACP,MAEJhpB,EAAM6pB,EAAOha,KAAKvQ,MAAQuqB,EAAOha,KAAK7P,MACtCmU,EAAS0V,EAAOnlB,KAEpB,GAAIyP,GAAU3P,EAAW,EAEN,KADyB,SAA3BilB,EAAGvI,UAAU/M,EAAS,MAE/BA,GAAU,GAGlB,MAEJ,KAAK,EACDnU,OAAQ0I,EACRyL,EAAS,EACT6U,GAAY,EACZ,MACJ,KAAK,GAGDhpB,EAAQ,GACR,IAAI8pB,EAAoBL,EAAGvI,UAAU/M,GACrCA,GAAU,EACV,IAAK,IAAIpV,EAAI,EAAGA,EAAI+qB,EAAmB/qB,IAAK,CACxC,IAAIgrB,EAAMxB,EAAIE,YAAY/L,EAAQvI,GAClCnU,EAAMyJ,KAAKsgB,EAAIla,MACfsE,EAAS4V,EAAIrlB,KAEjB,MAEJ,KAAK,GAED,IAAIslB,EAAOzB,EAAIY,UAAUzM,EAAQvI,EAAS,GAC1CnU,EAAQgqB,EAAKna,KACbsE,GAAU6V,EAAKtlB,KACf,MAEJ,KAAK,GAED,IAAIulB,EAAa1B,EAAIO,YAAYpM,EAAQvI,EAAS,GAClDnU,EAAQiqB,EAAWpa,KACnBsE,GAAU8V,EAAWvlB,KACrB,MAEJ,QAEIyP,EAAS3P,EACTjC,IAAIqB,EArMF,MAqMS,MAAO,8BAAgCqF,GAE1D,MAAO,CACH4G,KAAM7P,EACN0E,KAAMyP,EACN6U,c,YC5MNkB,EAAa,IAAIzc,WAAW,CAC9B,GACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,IACA,EACA,GACA,IACA,GACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,GACA,IACA,GACA,GACA,GACA,EACA,EACA,EACA,IACA,IACA,GACA,IACA,GACA,MAGE0c,EAAS,IAAI1c,WAAW,CAC1B,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,EACA,EACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,IACA,GACA,IACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,EACA,IACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,EACA,EACA,IACA,IACA,IACA,IACA,IACA,GACA,IACA,IACA,IACA,IACA,GACA,EACA,IACA,IACA,IACA,GACA,GACA,GACA,IACA,GACA,IACA,IACA,GACA,MAqBW2c,E,kCAjBJC,eAAP,SAAsB5lB,EAAmB6O,QAAiC,IAAjCA,OAAkB,GACvD,IAAMnR,EAAM,IAAIkC,IAYhB,OAXAlC,EAAImC,QAAUP,IAAWQ,MAErBpC,EAAI2C,KADJwO,EACW4W,EAEAC,EAEfhoB,EAAIqC,SAAWrC,EAAI2C,KAAK4K,WACxBvN,EAAIsC,UAAYkJ,KAAKmO,MAAMrX,GAC3BtC,EAAIyC,UAAY,EAChBzC,EAAI0C,QAAU,EACd1C,EAAI4C,MAAO,EACJ5C,G,2KChxBf,IA+lBemoB,E,WAlkBX,WAAYxV,EAAoByV,EAAmBjX,GAAwB,KArBnEnR,I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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Las\"] = factory();\n\telse\n\t\troot[\"Las\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n","const LasEvents = {\n    MEDIA_INFO: 'mediaInfo',\n    PARSING_INIT_SEGMENT: 'parsingInitSegment',\n    PARSING_DATA: 'parsingData',\n    PARSED_DATA: 'parsedData',\n    SCRIPT_PARSED: 'scriptParsed',\n    LOAD_END: 'loadEnd',\n    DISCONTINUITY: 'discontinuity',\n    ERROR: 'lasError',\n    LEVEL_SWITCH_FAILED: 'levelSwitchFailed',\n    LEVEL_SWITCHING: 'levelSwitching',\n    LEVEL_SWITCHED: 'levelSwitched',\n    MANIFEST_PARSED: 'manifestParsed',\n    BUFFER_FLUSHING: 'bufferFlushing',\n    INIT_PTS_FOUND: 'initPTSFound',\n    FLV_HEAD: 'flvHead',\n    REPORT: 'report',\n    HEARTBEAT: 'heartbeat',\n};\n\nexport default LasEvents;\n","const GLOBAL_TAG = 'kwai-k';\nconst FORCE_GLOBAL_TAG = true;\n\n/**\n * log\n * @param {string=} tag tag\n * @param {Array=} msg messages\n * @returns {Array} msg\n */\n/**\n * log\n * @param tag\n * @param msg\n */\nfunction formatter(tag: string, msg: any[]): any[] {\n    if (!msg || msg.length === 0) {\n        msg = [tag];\n        tag = '';\n    }\n    tag = FORCE_GLOBAL_TAG ? GLOBAL_TAG + (tag ? '::' + tag : '') : tag || GLOBAL_TAG;\n    msg.unshift('[' + tag + '] > ');\n\n    return msg;\n}\n\nenum LOG_LEVEL {\n    LEVEL_ERROR = 'e', // -errorerror\n    LEVEL_WARN = 'w', // -warnerrorwarn\n    LEVEL_INFO = 'i', // -infoerror, warn, info\n    LEVEL_DEBUG = 'd', // -debugerror, warn, info, debug\n    LEVEL_VERBOSE = 'v' // -verboseerror, warn, info, debug, verbose\n}\n\n/**\n * console\n * @class\n */\nclass Log {\n    public static ENABLE_ERROR: boolean = true;\n    public static ENABLE_WARN: boolean = false;\n    public static ENABLE_INFO: boolean = false;\n    public static ENABLE_DEBUG: boolean = false;\n    public static ENABLE_VERBOSE: boolean = false;\n\n    /**\n     * \n     * @param l \n     */\n    static level(l: LOG_LEVEL) {\n        Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = false;\n        switch (l) {\n            case LOG_LEVEL.LEVEL_WARN:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = true;\n                break;\n            case LOG_LEVEL.LEVEL_INFO:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = true;\n                break;\n            case LOG_LEVEL.LEVEL_DEBUG:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = true;\n                break;\n            case LOG_LEVEL.LEVEL_VERBOSE:\n                Log.ENABLE_ERROR = Log.ENABLE_WARN = Log.ENABLE_INFO = Log.ENABLE_DEBUG = Log.ENABLE_VERBOSE = true;\n                break;\n            default:\n                Log.ENABLE_ERROR = true;\n                break;\n        }\n    }\n\n    /**\n     * error\n     * @param tag tag\n     * @param msg \n     */\n    static e(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_ERROR) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.error || console.warn || console.log).apply(console, out);\n    }\n\n    /**\n     * warn\n     * @param tag tag\n     * @param msg \n     */\n    static w(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_WARN) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.warn || console.log).apply(console, out);\n    }\n\n    /**\n     * info\n     * @param tag tag\n     * @param msg \n     */\n    static i(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_INFO) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.info || console.log).apply(console, out);\n    }\n\n    /**\n     * debug\n     * @param tag tag\n     * @param msg \n     */\n    static d(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_DEBUG) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        (console.debug || console.log).apply(console, out);\n    }\n\n    /**\n     * verbose\n     * @param tag tag\n     * @param msg \n     */\n    static v(tag: string, ...msg: any[]) {\n        if (!Log.ENABLE_VERBOSE) {\n            return;\n        }\n        const out: any = formatter(tag, msg);\n        console.log.apply(console, out);\n    }\n}\n\nexport { Log, LOG_LEVEL };\n","export enum ErrorTypes {\n    // \n    NETWORK_ERROR = 'networkError',\n    // video\n    MEDIA_ERROR = 'mediaError',\n    // \n    MUX_ERROR = 'muxError',\n    // \n    OTHER_ERROR = 'otherError',\n    // MSE\n    MSE_ERROR = 'mseError'\n};\n\nexport enum ErrorDetails {\n    // NETWORK_ERROR < 100\n    LOAD_ERROR = 10,\n\n    VIDEO_ERROR = 101,\n    UNSUPPORTED = 102,\n    CONFIG_ERROR = 103,\n    MEDIASOURCE_ERROR = 200, // mediaSourceError MSEMediaSource\n    ADDSOURCEBUFFER_ERROR = 201, // addSourceBufferError MSESourceBuffer\n    SOURCEBUFFER_ERROR = 202, // sourceBufferError MSESourceBuffer\n    ENDOFSTREAM_ERROR = 203, // endOfStreamError MSE\n    APPENDBUFFER_ERROR = 204, // appendBufferError MSEbuffer\n    PARSING_ERROR = 301, // \n    REMUX_ERROR = 302, // \n    REMUX_ALLOC_ERROR = 303, // alloc mdat\n};\n","export enum FlvTagType {\n    AUDIO = 8,\n    VIDEO = 9,\n    SCRIPT = 18\n}\n\nexport const FlvSize = {\n    FLV_HEAD_LEN: 13,\n    FLV_TAG_HEAD_LEN: 11,\n    FLV_TAG_SIZE_LEN: 4,\n    AVC_KEY_FRAME_CHECK_LEN: 2\n}\n\nexport class FlvTag {\n    public tagType: FlvTagType = FlvTagType.VIDEO;\n    public dataSize: number = 0;\n    public timestamp: number = 0;\n    public size: number = 0;\n    public cts: number = 0;\n    public frameType: number = 0;\n    public codecId: number = 0;\n    public body: Uint8Array | null = null;\n    public fill?: boolean;\n}\n","/* eslint-disable */\nexport const ObjectAssign\n    = Object.assign\n    || function assign(target, varArgs) {\n        // .length of function is 2\n\n        if (target == null) {\n            // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        const to = Object(target);\n\n        for (let index = 1; index < arguments.length; index++) {\n            const nextSource = arguments[index];\n\n            if (nextSource != null) {\n                // Skip over if undefined or null\n                for (const nextKey in nextSource) {\n                    // Avoid bugs when hasOwnProperty is shadowed\n                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n        return to;\n    };\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nvar Browser: any = {};\n\nfunction detect() {\n    // modified from jquery-browser-plugin\n\n    const ua = self.navigator.userAgent.toLowerCase();\n\n    const match =\n        /(edge)\\/([\\w.]+)/.exec(ua) ||\n        /(opr)[\\/]([\\w.]+)/.exec(ua) ||\n        /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(iemobile)[\\/]([\\w.]+)/.exec(ua) ||\n        /(version)(applewebkit)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+).*(version)[ \\/]([\\w.]+).*(safari)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\n        /(msie) ([\\w.]+)/.exec(ua) ||\n        (ua.indexOf('trident') >= 0 && /(rv)(?::| )([\\w.]+)/.exec(ua)) ||\n        (ua.indexOf('compatible') < 0 && /(firefox)[ \\/]([\\w.]+)/.exec(ua)) ||\n        [];\n\n    const platform_match =\n        /(ipad)/.exec(ua) ||\n        /(ipod)/.exec(ua) ||\n        /(windows phone)/.exec(ua) ||\n        /(iphone)/.exec(ua) ||\n        /(kindle)/.exec(ua) ||\n        /(android)/.exec(ua) ||\n        /(windows)/.exec(ua) ||\n        /(mac)/.exec(ua) ||\n        /(linux)/.exec(ua) ||\n        /(cros)/.exec(ua) ||\n        [];\n\n    const matched = {\n        browser: match[5] || match[3] || match[1] || '',\n        version: match[2] || match[4] || '0',\n        majorVersion: match[4] || match[2] || '0',\n        platform: platform_match[0] || ''\n    };\n\n    const browser: any = {};\n    if (matched.browser) {\n        browser[matched.browser] = true;\n\n        const versionArray = matched.majorVersion.split('.');\n        browser.version = {\n            major: parseInt(matched.majorVersion, 10),\n            string: matched.version\n        };\n        if (versionArray.length > 1) {\n            browser.version.minor = parseInt(versionArray[1], 10);\n        }\n        if (versionArray.length > 2) {\n            browser.version.build = parseInt(versionArray[2], 10);\n        }\n    }\n\n    if (matched.platform) {\n        browser[matched.platform] = true;\n    }\n\n    if (browser.chrome || browser.opr || browser.safari) {\n        browser.webkit = true;\n    }\n\n    // MSIE. IE11 has 'rv' identifer\n    if (browser.rv || browser.iemobile) {\n        if (browser.rv) {\n            delete browser.rv;\n        }\n        const msie = 'msie';\n        matched.browser = msie;\n        browser[msie] = true;\n    }\n\n    // Microsoft Edge\n    if (browser.edge) {\n        delete browser.edge;\n        const msedge = 'msedge';\n        matched.browser = msedge;\n        browser[msedge] = true;\n    }\n\n    // Opera 15+\n    if (browser.opr) {\n        const opera = 'opera';\n        matched.browser = opera;\n        browser[opera] = true;\n    }\n\n    // Stock android browsers are marked as Safari\n    if (browser.safari && browser.android) {\n        const android = 'android';\n        matched.browser = android;\n        browser[android] = true;\n    }\n\n    browser.name = matched.browser;\n    browser.platform = matched.platform;\n\n    for (const key in Browser as any) {\n        if (Browser.hasOwnProperty(key)) {\n            delete Browser[key];\n        }\n    }\n    Browser = browser;\n    // Object.assign(Browser, browser);\n}\n\ndetect();\n\nexport default Browser;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","import { EventEmitter } from 'events';\n\nclass Observer extends EventEmitter {\n    trigger(event: string | symbol, ...args: any[]): boolean {\n        return super.emit(event, event, ...args);\n    };\n}\n\nexport default Observer;\n","export enum TrackType {\n    video = 'video',\n    audio = 'audio'\n}\n\nexport enum RemuxerTrackIdConfig {\n    video = 1,\n    audio\n}\n\nexport interface Track {\n    id: number;\n    type: TrackType;\n    codec: string;\n    manifestCodec?: string;\n    container: string;\n    timescale: number;\n    duration: number;\n    samples: any[];\n    inputTimeScale: number;\n    sequenceNumber: number;\n    pid: number;\n}\nexport interface ATrack extends Track {\n    config: number[];\n    isAAC: boolean;\n    samplerate: number;\n    channelCount: number;\n}\nexport interface VTrack extends Track {\n    width: number;\n    height: number;\n    codecWidth: number;\n    codecHeight: number;\n    sps: Uint8Array[];\n    pps: Uint8Array[];\n    pixelRatio: number[];\n    profile: string;\n    level: string;\n    chromaFormat: string;\n    fps: number;\n    dropped: number;\n    refSampleDuration: number;\n}\n\nexport interface Sample {\n    key: boolean;\n    pts: number;\n    dts: number;\n    units: [];\n    debug: string;\n}\n\nexport interface TypeSupported {\n    mp4: boolean;\n    mpeg: boolean;\n    mp3: boolean;\n}\n\nexport interface IRemuxer {\n    readonly ISGenerated: boolean;\n    destroy(): void;\n    setExtra(data: any): void;\n    resetTimeStamp(): void;\n    resetInitSegment(): void;\n    getLastPTS(): any;\n    flush(): any;\n    resetStash(): void;\n    remux(\n        audioTrack: ATrack,\n        videoTrack: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        accurateTimeOffset: boolean,\n        isFlush: boolean\n    ): void;\n}\n","export const isFiniteNumber\n    = Number.isFinite\n    || function (value) {\n        return typeof value === 'number' && isFinite(value);\n    };\n","/**\n *  AAC helper\n */\n\nclass AAC {\n    static getSilentFrame(codec: string, channelCount: number): Uint8Array | null {\n        switch (codec) {\n            case 'mp4a.40.2':\n                if (channelCount === 1) {\n                    return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n                } else if (channelCount === 2) {\n                    return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n                } else if (channelCount === 3) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x8e\n                    ]);\n                } else if (channelCount === 4) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x80,\n                        0x2c,\n                        0x80,\n                        0x08,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 5) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 6) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x00,\n                        0xb2,\n                        0x00,\n                        0x20,\n                        0x08,\n                        0xe0\n                    ]);\n                }\n\n                break;\n            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n            default:\n                if (channelCount === 1) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a\n                    4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x4e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x1c,\n                        0x6,\n                        0xf1,\n                        0xc1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 2) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a\n                        4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 3) {\n                    /* ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a\n                        4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                     */\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                }\n                break;\n        }\n        return null;\n    }\n}\n\nexport default AAC;\n","/**\n * Generate MP4 Box\n */\nimport { TrackType, Track, ATrack, VTrack } from '../types/remux';\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4 {\n    static types: Record<string, number[]>;\n    static HDLR_TYPES: Record<string, Uint8Array>;\n\n    static STTS: Uint8Array;\n    static STSC: Uint8Array;\n    static STCO: Uint8Array;\n    static STSZ: Uint8Array;\n    static VMHD: Uint8Array;\n    static SMHD: Uint8Array;\n    static STSD: Uint8Array;\n    static FTYP_AVC: Uint8Array;\n    static FTYP_HEVC: Uint8Array;\n    static DINF: Uint8Array;\n\n    static init() {\n        MP4.types = {\n            'avc1': [], // codingname\n            'avcC': [],\n            'btrt': [],\n            'dinf': [],\n            'dref': [],\n            'esds': [],\n            'ftyp': [],\n            'hdlr': [],\n            'mdat': [],\n            'mdhd': [],\n            'mdia': [],\n            'mfhd': [],\n            'minf': [],\n            'moof': [],\n            'moov': [],\n            'mp4a': [],\n            '.mp3': [],\n            'mvex': [],\n            'mvhd': [],\n            'pasp': [],\n            'sdtp': [],\n            'stbl': [],\n            'stco': [],\n            'stsc': [],\n            'stsd': [],\n            'stsz': [],\n            'stts': [],\n            'tfdt': [],\n            'tfhd': [],\n            'traf': [],\n            'trak': [],\n            'trun': [],\n            'trex': [],\n            'tkhd': [],\n            'vmhd': [],\n            'smhd': [],\n            'hev1': [],\n            'hvcC': []\n        };\n\n        let i;\n        for (i in MP4.types) {\n            if (MP4.types.hasOwnProperty(i)) {\n                MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n            }\n        }\n\n        const videoHdlr = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0x76,\n            0x69,\n            0x64,\n            0x65, // handler_type: 'vide'\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x56,\n            0x69,\n            0x64,\n            0x65,\n            0x6f,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'VideoHandler'\n        ]);\n\n        const audioHdlr = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0x73,\n            0x6f,\n            0x75,\n            0x6e, // handler_type: 'soun'\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x53,\n            0x6f,\n            0x75,\n            0x6e,\n            0x64,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'SoundHandler'\n        ]);\n\n        MP4.HDLR_TYPES = {\n            video: videoHdlr,\n            audio: audioHdlr\n        };\n\n        const dref = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01, // entry_count\n            0x00,\n            0x00,\n            0x00,\n            0x0c, // entry_size\n            0x75,\n            0x72,\n            0x6c,\n            0x20, // 'url' type\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x01 // entry_flags\n        ]);\n\n        const stco = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00 // entry_count\n        ]);\n\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n        MP4.STSZ = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00, // sample_size\n            0x00,\n            0x00,\n            0x00,\n            0x00 // sample_count\n        ]);\n        MP4.VMHD = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x01, // flags\n            0x00,\n            0x00, // graphicsmode\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00 // opcolor\n        ]);\n        MP4.SMHD = new Uint8Array([\n            0x00, // version\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00, // balance\n            0x00,\n            0x00 // reserved\n        ]);\n\n        MP4.STSD = new Uint8Array([\n            0x00, // version 0\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01\n        ]); // entry_count\n\n        const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n        const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n        const hev1Brand = new Uint8Array([104, 101, 118, 49]); // hev1\n        const minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n        MP4.FTYP_AVC = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.FTYP_HEVC = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, hev1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n\n    static box(type: number[], ...payload: Uint8Array[]) {\n        let size = 8,\n            i = payload.length,\n            len = i,\n            result;\n        // calculate the total size we need to allocate\n        while (i--) {\n            size += payload[i].byteLength;\n        }\n\n        result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for (i = 0, size = 8; i < len; i++) {\n            // copy payload[i] array @ offset size\n            result.set(payload[i], size);\n            size += payload[i].byteLength;\n        }\n        return result;\n    }\n\n    static hdlr(type: string) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n\n    static mdat(data: Uint8Array) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n\n    static mdhd(timescale: number, duration: number) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(\n            MP4.types.mdhd,\n            new Uint8Array([\n                0x01, // version 1\n                0x00,\n                0x00,\n                0x00, // flags\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x02, // creation_time\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x03, // modification_time\n                timescale >> 24 & 0xff,\n                timescale >> 16 & 0xff,\n                timescale >> 8 & 0xff,\n                timescale & 0xff, // timescale\n                upperWordDuration >> 24,\n                upperWordDuration >> 16 & 0xff,\n                upperWordDuration >> 8 & 0xff,\n                upperWordDuration & 0xff,\n                lowerWordDuration >> 24,\n                lowerWordDuration >> 16 & 0xff,\n                lowerWordDuration >> 8 & 0xff,\n                lowerWordDuration & 0xff,\n                0x55,\n                0xc4, // 'und' language (undetermined)\n                0x00,\n                0x00\n            ])\n        );\n    }\n\n    static mdia(track: Track) {\n        return MP4.box(\n            MP4.types.mdia,\n            MP4.mdhd(track.timescale, track.duration),\n            MP4.hdlr(track.type),\n            MP4.minf(track)\n        );\n    }\n\n    static mfhd(sequenceNumber: number) {\n        return MP4.box(\n            MP4.types.mfhd,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00,\n                0x00, // flags\n                sequenceNumber >> 24,\n                sequenceNumber >> 16 & 0xff,\n                sequenceNumber >> 8 & 0xff,\n                sequenceNumber & 0xff // sequence_number\n            ])\n        );\n    }\n\n    static minf(track: Track) {\n        if (track.type === 'audio') {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        }\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n\n    static moof(sn: number, baseMediaDecodeTime: number, track: Track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    /**\n     * @param tracks... (optional) {array} the tracks associated with this movie\n     */\n    static moov(tracks: Track[]) {\n        let i = tracks.length,\n            boxes = [];\n\n        while (i--) {\n            boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box(\n            MP4.types.moov,\n            ...[MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks))\n        );\n    }\n\n    static mvex(tracks: Track[]) {\n        let i = tracks.length;\n        const boxes = [];\n\n        while (i--) {\n            boxes[i] = MP4.trex(tracks[i]);\n        }\n\n        return MP4.box(MP4.types.mvex, ...boxes);\n    }\n\n    static mvhd(timescale: number, duration: number) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        const bytes = new Uint8Array([\n            0x01, // version 1\n            0x00,\n            0x00,\n            0x00, // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02, // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03, // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff, // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x01,\n            0x00,\n            0x00, // 1.0 rate\n            0x01,\n            0x00, // 1.0 volume\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00, // transformation: unity matrix\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined\n            0xff,\n            0xff,\n            0xff,\n            0xff // next_track_ID\n        ]);\n        return MP4.box(MP4.types.mvhd, bytes);\n    }\n\n    static sdtp(track: Track) {\n        let samples = track.samples || [],\n            bytes = new Uint8Array(4 + samples.length),\n            flags,\n            i;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for (i = 0; i < samples.length; i++) {\n            flags = samples[i].flags;\n            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n\n        return MP4.box(MP4.types.sdtp, bytes);\n    }\n\n    static stbl(track: Track) {\n        return MP4.box(\n            MP4.types.stbl,\n            MP4.stsd(track),\n            MP4.box(MP4.types.stts, MP4.STTS),\n            MP4.box(MP4.types.stsc, MP4.STSC),\n            MP4.box(MP4.types.stsz, MP4.STSZ),\n            MP4.box(MP4.types.stco, MP4.STCO)\n        );\n    }\n\n    static avc1(track: VTrack) {\n        let sps: any = [],\n            pps: any = [],\n            i,\n            data,\n            len;\n        // assemble the SPSs\n\n        for (i = 0; i < track.sps.length; i++) {\n            data = track.sps[i];\n            len = data.byteLength;\n            sps.push(len >>> 8 & 0xff);\n            sps.push(len & 0xff);\n\n            // SPS\n            sps = sps.concat(Array.prototype.slice.call(data));\n        }\n\n        // assemble the PPSs\n        for (i = 0; i < track.pps.length; i++) {\n            data = track.pps[i];\n            len = data.byteLength;\n            pps.push(len >>> 8 & 0xff);\n            pps.push(len & 0xff);\n\n            pps = pps.concat(Array.prototype.slice.call(data));\n        }\n\n        const avcc = MP4.box(\n                MP4.types.avcC,\n                new Uint8Array(\n                    [\n                        0x01, // version\n                        sps[3], // profile\n                        sps[4], // profile compat\n                        sps[5], // level\n                        0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n                        0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n                    ]\n                        .concat(sps)\n                        .concat([\n                            track.pps.length // numOfPictureParameterSets\n                        ])\n                        .concat(pps)\n                )\n            ), // \"PPS\"\n            width = track.width,\n            height = track.height,\n            hSpacing = track.pixelRatio[0],\n            vSpacing = track.pixelRatio[1];\n\n        return MP4.box(\n            MP4.types.avc1,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00, // pre_defined\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // pre_defined\n                width >> 8 & 0xff,\n                width & 0xff, // width\n                height >> 8 & 0xff,\n                height & 0xff, // height\n                0x00,\n                0x48,\n                0x00,\n                0x00, // horizresolution\n                0x00,\n                0x48,\n                0x00,\n                0x00, // vertresolution\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // frame_count\n                0x12,\n                0x64,\n                0x61,\n                0x69,\n                0x6c, // dailymotion/hls.js\n                0x79,\n                0x6d,\n                0x6f,\n                0x74,\n                0x69,\n                0x6f,\n                0x6e,\n                0x2f,\n                0x68,\n                0x6c,\n                0x73,\n                0x2e,\n                0x6a,\n                0x73,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // compressorname\n                0x00,\n                0x18, // depth = 24\n                0x11,\n                0x11\n            ]), // pre_defined = -1\n            avcc,\n            MP4.box(\n                MP4.types.btrt,\n                new Uint8Array([\n                    0x00,\n                    0x1c,\n                    0x9c,\n                    0x80, // bufferSizeDB\n                    0x00,\n                    0x2d,\n                    0xc6,\n                    0xc0, // maxBitrate\n                    0x00,\n                    0x2d,\n                    0xc6,\n                    0xc0\n                ])\n            ), // avgBitrate\n            MP4.box(\n                MP4.types.pasp,\n                new Uint8Array([\n                    hSpacing >> 24, // hSpacing\n                    hSpacing >> 16 & 0xff,\n                    hSpacing >> 8 & 0xff,\n                    hSpacing & 0xff,\n                    vSpacing >> 24, // vSpacing\n                    vSpacing >> 16 & 0xff,\n                    vSpacing >> 8 & 0xff,\n                    vSpacing & 0xff\n                ])\n            )\n        );\n    }\n\n    static hev1(track: VTrack) {\n        const hvcc = track.hvcc;\n        const width = track.codecWidth,\n            height = track.codecHeight;\n        const data = new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved(4)\n            0x00,\n            0x00,\n            0x00,\n            0x01, // reserved(2) + data_reference_index(2)\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined(2) + reserved(2)\n            0x00,\n            0x00,\n            0x00,\n            0x00, // pre_defined: 3 * 4 bytes\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            width >>> 8 & 0xff, // width: 2 bytes\n            width & 0xff,\n            height >>> 8 & 0xff, // height: 2 bytes\n            height & 0xff,\n            0x00,\n            0x48,\n            0x00,\n            0x00, // horizresolution: 4 bytes\n            0x00,\n            0x48,\n            0x00,\n            0x00, // vertresolution: 4 bytes\n            0x00,\n            0x00,\n            0x00,\n            0x00, // reserved: 4 bytes\n            0x00,\n            0x01, // frame_count\n            0x0a, // strlen\n            0x78,\n            0x71,\n            0x71,\n            0x2f, // compressorname: 32 bytes\n            0x66,\n            0x6c,\n            0x76,\n            0x2e,\n            0x6a,\n            0x73,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x18, // depth\n            0xff,\n            0xff // pre_defined = -1\n        ]);\n        return MP4.box(MP4.types.hev1, data, MP4.box(MP4.types.hvcC, hvcc));\n    }\n\n    static esds(track: ATrack) {\n        const configlen = track.config.length;\n        return new Uint8Array(\n            [\n                0x00, // version 0\n                0x00,\n                0x00,\n                0x00, // flags\n\n                0x03, // descriptor_type\n                0x17 + configlen, // length\n                0x00,\n                0x01, // es_id\n                0x00, // stream_priority\n\n                0x04, // descriptor_type\n                0x0f + configlen, // length\n                0x40, // codec : mpeg4_audio\n                0x15, // stream_type\n                0x00,\n                0x00,\n                0x00, // buffer_size\n                0x00,\n                0x00,\n                0x00,\n                0x00, // maxBitrate\n                0x00,\n                0x00,\n                0x00,\n                0x00, // avgBitrate\n\n                0x05 // descriptor_type\n            ]\n                .concat([configlen])\n                .concat(track.config)\n                .concat([0x06, 0x01, 0x02])\n        ); // GASpecificConfig)); // length + audio config descriptor\n    }\n\n    static mp4a(track: ATrack) {\n        const samplerate = track.samplerate;\n        return MP4.box(\n            MP4.types.mp4a,\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                track.channelCount, // channelcount\n                0x00,\n                0x10, // sampleSize:16bits\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved2\n                samplerate >> 8 & 0xff,\n                samplerate & 0xff, //\n                0x00,\n                0x00\n            ]),\n            MP4.box(MP4.types.esds, MP4.esds(track))\n        );\n    }\n\n    static mp3(track: ATrack) {\n        const samplerate = track.samplerate;\n        return MP4.box(\n            MP4.types['.mp3'],\n            new Uint8Array([\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01, // data_reference_index\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                track.channelCount, // channelcount\n                0x00,\n                0x10, // sampleSize:16bits\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved2\n                samplerate >> 8 & 0xff,\n                samplerate & 0xff, //\n                0x00,\n                0x00\n            ])\n        );\n    }\n\n    static stsd(track: Track) {\n        if (track.type === TrackType.audio) {\n            if (!(<ATrack>track).isAAC && track.codec === 'mp3') {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(<ATrack>track));\n            }\n\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(<ATrack>track));\n        }\n        if (track.codec.indexOf('hev1') === 0) {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.hev1(<VTrack>track));\n        }\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(<VTrack>track));\n    }\n\n    static tkhd(track: ATrack & VTrack) {\n        const id = track.id,\n            duration = track.duration * track.timescale,\n            upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),\n            lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        let width = 0,\n            height = 0;\n        if (track.hasOwnProperty('width')) {\n            width = track.width;\n        }\n        if (track.hasOwnProperty('height')) {\n            height = track.height;\n        }\n        return MP4.box(\n            MP4.types.tkhd,\n            new Uint8Array([\n                0x01, // version 1\n                0x00,\n                0x00,\n                0x07, // flags\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x02, // creation_time\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x03, // modification_time\n                id >> 24 & 0xff,\n                id >> 16 & 0xff,\n                id >> 8 & 0xff,\n                id & 0xff, // track_ID\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                upperWordDuration >> 24,\n                upperWordDuration >> 16 & 0xff,\n                upperWordDuration >> 8 & 0xff,\n                upperWordDuration & 0xff,\n                lowerWordDuration >> 24,\n                lowerWordDuration >> 16 & 0xff,\n                lowerWordDuration >> 8 & 0xff,\n                lowerWordDuration & 0xff,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x00, // layer\n                0x00,\n                0x00, // alternate_group\n                0x00,\n                0x00, // non-audio track volume\n                0x00,\n                0x00, // reserved\n                0x00,\n                0x01,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x01,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x00,\n                0x40,\n                0x00,\n                0x00,\n                0x00, // transformation: unity matrix\n                width >> 8 & 0xff,\n                width & 0xff,\n                0x00,\n                0x00, // width\n                height >> 8 & 0xff,\n                height & 0xff,\n                0x00,\n                0x00 // height\n            ])\n        );\n    }\n\n    static traf(track: Track, baseMediaDecodeTime: number) {\n        const sampleDependencyTable = MP4.sdtp(track),\n            id = track.id,\n            upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),\n            lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(\n            MP4.types.traf,\n            MP4.box(\n                MP4.types.tfhd,\n                new Uint8Array([\n                    0x00, // version 0\n                    0x00,\n                    0x00,\n                    0x00, // flags\n                    id >> 24,\n                    id >> 16 & 0xff,\n                    id >> 8 & 0xff,\n                    id & 0xff // track_ID\n                ])\n            ),\n            MP4.box(\n                MP4.types.tfdt,\n                new Uint8Array([\n                    0x01, // version 1\n                    0x00,\n                    0x00,\n                    0x00, // flags\n                    upperWordBaseMediaDecodeTime >> 24,\n                    upperWordBaseMediaDecodeTime >> 16 & 0xff,\n                    upperWordBaseMediaDecodeTime >> 8 & 0xff,\n                    upperWordBaseMediaDecodeTime & 0xff,\n                    lowerWordBaseMediaDecodeTime >> 24,\n                    lowerWordBaseMediaDecodeTime >> 16 & 0xff,\n                    lowerWordBaseMediaDecodeTime >> 8 & 0xff,\n                    lowerWordBaseMediaDecodeTime & 0xff\n                ])\n            ),\n            MP4.trun(\n                track,\n                sampleDependencyTable.length\n                + 16 // tfhd\n                + 20 // tfdt\n                + 8 // traf header\n                + 16 // mfhd\n                + 8 // moof header\n                    + 8\n            ), // mdat header\n            sampleDependencyTable\n        );\n    }\n\n    /**\n     * Generate a track box.\n     * @param track {object} a track definition\n     * @return {Uint8Array} the track box\n     */\n    static trak(track: Track): Uint8Array {\n        // TODO:\n        // track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(<ATrack & VTrack>track), MP4.mdia(track));\n    }\n\n    static trex(track: Track): Uint8Array {\n        const id = track.id;\n        return MP4.box(\n            MP4.types.trex,\n            new Uint8Array([\n                0x00, // version 0\n                0x00,\n                0x00,\n                0x00, // flags\n                id >> 24,\n                id >> 16 & 0xff,\n                id >> 8 & 0xff,\n                id & 0xff, // track_ID\n                0x00,\n                0x00,\n                0x00,\n                0x01, // default_sample_description_index\n                0x00,\n                0x00,\n                0x00,\n                0x00, // default_sample_duration\n                0x00,\n                0x00,\n                0x00,\n                0x00, // default_sample_size\n                0x00,\n                0x01,\n                0x00,\n                0x01 // default_sample_flags\n            ])\n        );\n    }\n\n    static trun(track: Track, offset: number) {\n        let samples = track.samples || [],\n            len = samples.length,\n            arraylen = 12 + 16 * len,\n            array = new Uint8Array(arraylen),\n            i,\n            sample,\n            duration,\n            size,\n            flags,\n            cts;\n        offset += 8 + arraylen;\n        array.set(\n            [\n                0x00, // version 0\n                0x00,\n                0x0f,\n                0x01, // flags\n                len >>> 24 & 0xff,\n                len >>> 16 & 0xff,\n                len >>> 8 & 0xff,\n                len & 0xff, // sample_count\n                offset >>> 24 & 0xff,\n                offset >>> 16 & 0xff,\n                offset >>> 8 & 0xff,\n                offset & 0xff // data_offset\n            ],\n            0\n        );\n        for (i = 0; i < len; i++) {\n            sample = samples[i];\n            duration = sample.duration;\n            size = sample.size;\n            flags = sample.flags;\n            cts = sample.cts;\n            array.set(\n                [\n                    duration >>> 24 & 0xff,\n                    duration >>> 16 & 0xff,\n                    duration >>> 8 & 0xff,\n                    duration & 0xff, // sample_duration\n                    size >>> 24 & 0xff,\n                    size >>> 16 & 0xff,\n                    size >>> 8 & 0xff,\n                    size & 0xff, // sample_size\n                    flags.isLeading << 2 | flags.dependsOn,\n                    flags.isDependedOn << 6\n                        | flags.hasRedundancy << 4\n                        | flags.paddingValue << 1\n                        | flags.isNonSync,\n                    flags.degradPrio & 0xf0 << 8,\n                    flags.degradPrio & 0x0f, // sample_flags\n                    cts >>> 24 & 0xff,\n                    cts >>> 16 & 0xff,\n                    cts >>> 8 & 0xff,\n                    cts & 0xff // sample_composition_time_offset\n                ],\n                12 + 16 * i\n            );\n        }\n        return MP4.box(MP4.types.trun, array);\n    }\n\n    static initSegment<T extends Track>(tracks: T[]) {\n        if (!MP4.types) {\n            MP4.init();\n        }\n        let ftyp = MP4.FTYP_AVC;\n        let i = tracks.length;\n        while (i--) {\n            if (tracks[i].type === 'video' && tracks[i].codec.indexOf('hev1') === 0) {\n                ftyp = MP4.FTYP_HEVC;\n            }\n        }\n        const movie = MP4.moov(tracks);\n        const result = new Uint8Array(ftyp.byteLength + movie.byteLength);\n        result.set(ftyp);\n        result.set(movie, ftyp.byteLength);\n        return result;\n    }\n}\n\nexport default MP4;\n","/**\n * fMP4 remuxer\n */\n\nimport { ErrorDetails, ErrorTypes } from '../core/errors';\nimport LasEvents from '../core/events';\nimport Observer from '../core/observer';\nimport { FLVTransConfig } from '../types/core';\nimport { ATrack, IRemuxer, TypeSupported, VTrack } from '../types/remux';\nimport Browser from '../utils/browser';\nimport { Log } from '../utils/log';\nimport AAC from './aac-helper';\nimport MP4 from './mp4-generator';\n\n\n\n// 100 seconds\nconst MAX_SILENT_FRAME_DURATION = 100 * 1000;\n\ntype StashInfo = { timeOffset: number; accurateTimeOffset: boolean; track: VTrack; sequenceNumber: number };\n\ntype Stat = {\n    ISGenerated: boolean;\n    nextAudioPts?: number;\n    nextAvcDts?: number;\n    initPTS?: number;\n    initDTS?: number;\n    videoTime: {\n        nbSamples: number;\n        firstDTS: number;\n        sampleDuration: number;\n        vLastPTS: number;\n        aLastPTS: number;\n        endDts?: number;\n    };\n};\n\nclass MP4Remuxer implements IRemuxer {\n    private _observer: Observer;\n    private _config: FLVTransConfig;\n    private _typeSupported: TypeSupported;\n    private _isSafari: boolean;\n    private _forceFirstIDR: boolean;\n    private _stash: boolean;\n    private _stashInfo: StashInfo;\n    private _stashLastVideoSample: any;\n    private _ISGenerated: boolean = false;\n    private _videoTime!: {\n        nbSamples: number;\n        firstDTS: number;\n        sampleDuration: number;\n        vLastPTS: number;\n        aLastPTS: number;\n        endDts?: number;\n    };\n    private _extra: any;\n\n    private _nextAudioPts?: number;\n    private _nextAvcDts?: number;\n    private _initPTS?: number;\n    private _initDTS?: number;\n    private _initSegment: Record<string, Uint8Array> = {};\n\n    constructor(observer: Observer, config: FLVTransConfig, typeSupported: TypeSupported, vendor: string = '') {\n        this._observer = observer;\n        this._config = config;\n        this._typeSupported = typeSupported;\n        const userAgent = navigator.userAgent;\n        this._isSafari = !!(vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS'));\n        this._ISGenerated = false;\n        this._stash = !config.gopRemux;\n        // sampleDuration\n        this._resetVideoTime();\n        this._stashInfo = <StashInfo>{};\n        if (!MP4.types) {\n            MP4.init();\n        }\n        // Workaround for chrome < 50: Always force first sample as a Random Access Point in media segment\n        // see https://bugs.chromium.org/p/chromium/issues/detail?id=229412\n        this._forceFirstIDR =\n            Browser.chrome &&\n                (Browser.version.major < 50 || (Browser.version.major === 50 && Browser.version.build < 2661))\n                ? true\n                : false;\n    }\n\n    get ISGenerated(): boolean {\n        return this._ISGenerated;\n    }\n\n    public setStat(stat: Stat): void {\n        if (stat) {\n            this._ISGenerated = stat.ISGenerated;\n            this._nextAudioPts = stat.nextAudioPts;\n            this._nextAvcDts = stat.nextAvcDts;\n            this._initPTS = stat.initPTS;\n            this._initDTS = stat.initDTS;\n            this._videoTime.nbSamples = stat.videoTime.nbSamples;\n            this._videoTime.firstDTS = stat.videoTime.firstDTS;\n            this._videoTime.sampleDuration = stat.videoTime.sampleDuration;\n            this._videoTime.vLastPTS = stat.videoTime.vLastPTS;\n            this._videoTime.aLastPTS = stat.videoTime.aLastPTS;\n            this._videoTime.endDts = stat.videoTime.endDts;\n        }\n    }\n    public getStat(): Stat {\n        return {\n            ISGenerated: this._ISGenerated,\n            nextAudioPts: this._nextAudioPts,\n            nextAvcDts: this._nextAvcDts,\n            initPTS: this._initPTS,\n            initDTS: this._initDTS,\n            videoTime: {\n                nbSamples: this._videoTime.nbSamples,\n                firstDTS: this._videoTime.firstDTS,\n                sampleDuration: this._videoTime.sampleDuration,\n                vLastPTS: this._videoTime.vLastPTS,\n                aLastPTS: this._videoTime.aLastPTS,\n                endDts: this._videoTime.endDts\n            }\n        };\n    }\n\n    destroy() { }\n\n    setExtra(data: any) {\n        this._extra = data;\n    }\n\n    resetTimeStamp(defaultTimeStamp?: number) {\n        this._initPTS = this._initDTS = defaultTimeStamp;\n        this._resetVideoTime();\n    }\n\n    resetInitSegment() {\n        this._ISGenerated = false;\n        this._initSegment = {};\n        this.resetStash();\n    }\n\n    getLastPTS() {\n        return { video: this._videoTime.vLastPTS, audio: this._videoTime.aLastPTS };\n    }\n\n    flush(audioTrackLength = 0) {\n        let videoData = null;\n        if (this._stash && this._stashLastVideoSample) {\n            const info = this._stashInfo;\n            info.track.samples = [this._stashLastVideoSample];\n            this._stashLastVideoSample = null;\n            info.sequenceNumber += 1;\n            videoData = this.remuxVideo(info.track, info.timeOffset, true, audioTrackLength, info.accurateTimeOffset);\n        }\n        this.resetStash();\n        return videoData;\n    }\n\n    resetStash() {\n        this._stashLastVideoSample = null;\n        this._stashInfo = <StashInfo>{};\n    }\n\n    remux(\n        audioTrack: ATrack,\n        videoTrack: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        accurateTimeOffset: boolean,\n        isFlush: boolean = false\n    ) {\n        // generate Init Segment if needed\n        if (!this._ISGenerated) {\n            this.generateIS(audioTrack, videoTrack, timeOffset);\n        }\n\n        // safari\n        if (!contiguous && videoTrack.samples.length) {\n            videoTrack.samples[0].pts = videoTrack.samples[0].dts;\n        }\n\n        if (this._ISGenerated) {\n            const nbVideoStashSamples = isFlush && this._stashLastVideoSample ? 1 : 0;\n            const nbAudioSamples = audioTrack.samples.length;\n            const nbVideoSamples = videoTrack.samples.length;\n            let audioTimeOffset = timeOffset;\n            let videoTimeOffset = timeOffset;\n            if (nbAudioSamples && nbVideoSamples) {\n                if (!contiguous && accurateTimeOffset) {\n                    // accurateTimeOffset=truetimeoffset\n                    if (audioTrack.samples[0].pts - videoTrack.samples[0].pts < 0) {\n                        const sample = Object.assign({}, videoTrack.samples[0]);\n                        sample.dts = sample.pts = audioTrack.samples[0].pts;\n                        videoTrack.samples.unshift(sample);\n                    }\n                } else {\n                    // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n                    // if first audio DTS is not aligned with first video DTS then we need to take that into account\n                    // when providing timeOffset to remuxAudio / remuxVideo.\n                    // if we don't do that, there might be a permanent / small drift between audio and video streams\n                    const audiovideoDeltaDts =\n                        (audioTrack.samples[0].pts - videoTrack.samples[0].pts) / videoTrack.inputTimeScale;\n                    audioTimeOffset += Math.max(0, audiovideoDeltaDts);\n                    videoTimeOffset += Math.max(0, -audiovideoDeltaDts);\n                }\n            }\n            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is\n            // calculated in remuxAudio.\n            // Log.v('nb AAC samples:' + audioTrack.samples.length);\n            if (nbAudioSamples) {\n                // if initSegment was generated without video samples, regenerate it again\n                if (!audioTrack.timescale) {\n                    Log.w('regenerate InitSegment as audio detected');\n                    this.generateIS(audioTrack, videoTrack, timeOffset);\n                }\n                const audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);\n                // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                let audioTrackLength;\n                if (audioData) {\n                    audioTrackLength = audioData.endPTS - audioData.startPTS;\n                }\n                if (nbVideoSamples) {\n                    // if initSegment was generated without video samples, regenerate it again\n                    if (!videoTrack.timescale) {\n                        Log.w('regenerate InitSegment as video detected');\n                        this.generateIS(audioTrack, videoTrack, timeOffset);\n                    }\n                    this.remuxVideo(\n                        videoTrack,\n                        videoTimeOffset,\n                        contiguous,\n                        audioTrackLength,\n                        accurateTimeOffset,\n                        isFlush\n                    );\n                } else {\n                    this.flush(audioTrackLength);\n                }\n            } else {\n                // Log.v('nb AVC samples:' + videoTrack.samples.length);\n                let videoData = null;\n                if (nbVideoSamples) {\n                    videoData = this.remuxVideo(\n                        videoTrack,\n                        videoTimeOffset,\n                        contiguous,\n                        0,\n                        accurateTimeOffset,\n                        isFlush\n                    );\n                } else if (nbVideoStashSamples) {\n                    videoData = this.flush();\n                }\n                if (\n                    videoData &&\n                    audioTrack.codec &&\n                    Number.isFinite(videoData.startDTS) &&\n                    Number.isFinite(videoData.endDTS)\n                ) {\n                    this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);\n                }\n            }\n        }\n    }\n\n    generateIS(audioTrack: ATrack, videoTrack: VTrack, timeOffset: number) {\n        const observer = this._observer,\n            audioSamples = audioTrack.samples,\n            videoSamples = videoTrack.samples,\n            typeSupported = this._typeSupported,\n            tracks: any = {},\n            data = { tracks: tracks },\n            computePTSDTS = typeof this._initPTS === 'undefined';\n        let container = 'audio/mp4',\n            initPTS,\n            initDTS;\n\n        if (computePTSDTS) {\n            initPTS = initDTS = Infinity;\n        }\n\n        if (audioTrack.config && audioSamples.length) {\n            // let's use audio sampling rate as MP4 time scale.\n            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n            // using audio sampling rate here helps having an integer MP4 frame duration\n            // this avoids potential rounding issue and AV sync issue\n            audioTrack.timescale = audioTrack.samplerate;\n            Log.v(`audio sampling rate : ${audioTrack.samplerate}`);\n            if (!audioTrack.isAAC) {\n                if (typeSupported.mpeg) {\n                    // Chrome and Safari\n                    container = 'audio/mpeg';\n                    audioTrack.codec = '';\n                } else if (typeSupported.mp3) {\n                    // Firefox\n                    audioTrack.codec = 'mp3';\n                }\n            }\n            this._initSegment.audio =\n                !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : MP4.initSegment([audioTrack]);\n            tracks.audio = {\n                container: container,\n                codec: audioTrack.codec,\n                metadata: {\n                    channelCount: audioTrack.channelCount,\n                    audioSampleRate: audioTrack.samplerate\n                }\n            };\n            if (computePTSDTS) {\n                // remember first PTS of this demuxing context. for audio, PTS = DTS\n                initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;\n            }\n        }\n\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n            // let's use input time scale as MP4 video timescale\n            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n            const inputTimeScale = videoTrack.inputTimeScale;\n            videoTrack.timescale = inputTimeScale;\n            this._initSegment.video = MP4.initSegment([videoTrack]);\n            tracks.video = {\n                container: 'video/mp4',\n                codec: videoTrack.codec,\n                metadata: {\n                    width: videoTrack.width,\n                    height: videoTrack.height,\n                    fps: videoTrack.fps,\n                    profile: videoTrack.profile,\n                    level: videoTrack.level,\n                    chromaFormat: videoTrack.chromaFormat\n                }\n            };\n            if (computePTSDTS) {\n                initPTS = Math.min(initPTS ? initPTS : Infinity, videoSamples[0].pts - inputTimeScale * timeOffset);\n                initDTS = Math.min(initDTS ? initDTS : Infinity, videoSamples[0].dts - inputTimeScale * timeOffset);\n                this._observer.trigger(LasEvents.INIT_PTS_FOUND, { initPTS: initPTS });\n            }\n        }\n\n        if (Object.keys(tracks).length) {\n            observer.trigger(LasEvents.PARSING_INIT_SEGMENT, data);\n            this._ISGenerated = true;\n            if (computePTSDTS) {\n                this._initPTS = initPTS;\n                this._initDTS = initDTS;\n            }\n        } else {\n            observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: false,\n                reason: 'no audio/video samples found'\n            });\n        }\n    }\n\n    remuxVideo(\n        track: VTrack,\n        timeOffset: number,\n        contiguous: boolean,\n        audioTrackLength?: number,\n        accurateTimeOffset: boolean = false,\n        isFlush: boolean = false\n    ) {\n        const timeScale = track.timescale,\n            inputSamples = track.samples,\n            outputSamples = [],\n            ptsNormalize = this._PTSNormalize,\n            initPTS = this._initPTS,\n            streamDTS = inputSamples[0].streamDTS / 1000,\n            key = inputSamples[0].key,\n            time = this._videoTime;\n        let offset = 8,\n            mp4SampleDuration = 0,\n            mdat,\n            moof = null,\n            firstPTS = 0,\n            firstDTS = 0,\n            lastPTS = 0,\n            lastDTS = 0,\n            nbSamples = inputSamples.length;\n        if (typeof initPTS === 'undefined') {\n            return;\n        }\n        // for (let i = 0; i < track.samples.length; i++) {\n        //   let avcSample = track.samples[i];\n        //   let units = avcSample.units;\n        //   let unitsString = '';\n        //   for (let j = 0; j < units.length ; j++) {\n        //     unitsString += units[j].type + ',';\n        //     if (units[j].data.length < 500) {\n        //       unitsString += Hex.hexDump(units[j].data);\n        //     }\n        //   }\n        //   Log.v(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);\n        // }\n\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        let nextAvcDts = this._nextAvcDts;\n\n        const isSafari = this._isSafari;\n        if (nbSamples === 0 || track.timescale === 0) {\n            return null;\n        }\n\n        // Safari does not like overlapping DTS on consecutive fragments.\n        // let's use nextAvcDts to overcome this if fragments are consecutive\n        if (isSafari) {\n            // also consider consecutive fragments as being contiguous (even if a level switch occurs),\n            // for sake of clarity:\n            // consecutive fragments are frags with\n            //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n            //  - less than 200 ms PTS gaps (timeScale/5)\n            contiguous =\n                contiguous ||\n                !!(\n                    inputSamples.length &&\n                    nextAvcDts &&\n                    ((accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1) ||\n                        Math.abs(inputSamples[0].pts - nextAvcDts - initPTS) < timeScale / 5)\n                );\n        }\n\n        if (!contiguous) {\n            // if not contiguous, let's use target timeOffset\n            nextAvcDts = timeOffset * timeScale;\n            this._resetVideoTime();\n        }\n        if (typeof nextAvcDts === 'undefined') {\n            return;\n        }\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        inputSamples.forEach(function (sample) {\n            sample.pts = ptsNormalize(sample.pts - initPTS, nextAvcDts);\n            sample.dts = ptsNormalize(sample.dts - initPTS, nextAvcDts);\n        });\n\n        // sort video samples by DTS then PTS then demux id order\n        inputSamples.sort(function (a, b) {\n            const deltadts = a.dts - b.dts;\n            const deltapts = a.pts - b.pts;\n            return deltadts || (deltapts || a.id - b.id);\n        });\n\n        // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)\n        const PTSDTSshift = inputSamples.reduce(\n            (prev, curr) => Math.max(Math.min(prev, curr.pts - curr.dts), -18000),\n            0\n        );\n        if (PTSDTSshift < 0) {\n            Log.w(\n                `PTS < DTS detected in video samples, shifting DTS by ${Math.round(\n                    PTSDTSshift / 90\n                )} ms to overcome this issue`\n            );\n            for (let i = 0; i < inputSamples.length; i++) {\n                inputSamples[i].dts += PTSDTSshift;\n            }\n        }\n        // sampleremuxsampleDuration\n        if (this._stash) {\n            this._stashInfo.timeOffset = timeOffset;\n            this._stashInfo.accurateTimeOffset = accurateTimeOffset;\n            this._stashInfo.track = track;\n            if (this._stashLastVideoSample) {\n                nbSamples++;\n                inputSamples.unshift(this._stashLastVideoSample);\n                this._stashLastVideoSample = null;\n            }\n            if (inputSamples.length > 1 && !isFlush) {\n                this._stashLastVideoSample = inputSamples.pop();\n                nbSamples--;\n            }\n        }\n        // compute first DTS and last DTS, normalize them against reference value\n        let sample = inputSamples[0];\n        firstDTS = Math.max(sample.dts, 0);\n        firstPTS = Math.max(sample.pts, 0);\n\n        // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)\n        const delta = Math.round((firstDTS - nextAvcDts) / 90);\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n            if (delta) {\n                if (delta > 1) {\n                    Log.v(`AVC:${delta} ms hole between fragments detected,filling it`);\n                } else if (delta < -1) {\n                    Log.v(`AVC:${-delta} ms overlapping between fragments detected`);\n                }\n\n                firstPTS = Math.max(firstPTS - (firstDTS - nextAvcDts), nextAvcDts);\n                // remove hole/gap : set DTS to next expected DTS\n                firstDTS = nextAvcDts;\n                inputSamples[0].dts = firstDTS;\n                // offset PTS as well, ensure that PTS is smaller or equal than new DTS\n                inputSamples[0].pts = firstPTS;\n                Log.v(\n                    `Video/PTS/DTS adjusted: ${Math.round(firstPTS / 90)}/${Math.round(\n                        firstDTS / 90\n                    )},delta:${delta} ms`\n                );\n            }\n        }\n\n        // compute lastPTS/lastDTS\n        sample = inputSamples[inputSamples.length - 1];\n        lastDTS = Math.max(sample.dts, 0);\n        lastPTS = Math.max(sample.pts, 0, lastDTS);\n\n        // on Safari let's signal the same sample duration for all samples\n        // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        if (isSafari) {\n            mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));\n        }\n\n        let nbNalu = 0,\n            naluLen = 0;\n        for (let i = 0; i < nbSamples; i++) {\n            // compute total/avc sample length and nb of NAL units\n            const sample = inputSamples[i],\n                units = sample.units,\n                nbUnits = units.length;\n            let sampleLen = 0;\n            for (let j = 0; j < nbUnits; j++) {\n                sampleLen += units[j].data.length;\n            }\n\n            naluLen += sampleLen;\n            nbNalu += nbUnits;\n            sample.length = sampleLen;\n\n            // normalize PTS/DTS\n            if (isSafari) {\n                // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples\n                sample.dts = firstDTS + i * mp4SampleDuration;\n            } else {\n                // ensure sample monotonic DTS\n                sample.dts = Math.max(sample.dts, firstDTS);\n            }\n            // ensure that computed value is greater or equal than sample DTS\n            sample.pts = Math.max(sample.pts, sample.dts);\n        }\n\n        /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n        const mdatSize = naluLen + 4 * nbNalu + 8;\n        try {\n            mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                bytes: mdatSize,\n                reason: `fail allocating video mdat ${mdatSize}`\n            });\n            return null;\n        }\n        const view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n\n        for (let i = 0; i < nbSamples; i++) {\n            const avcSample = inputSamples[i],\n                avcSampleUnits = avcSample.units;\n            let mp4SampleLength = 0,\n                compositionTimeOffset;\n            // convert NALU bitstream to MP4 format (prepend NALU with size field)\n            for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n                const unit = avcSampleUnits[j],\n                    unitData = unit.data,\n                    unitDataLen = unit.data.byteLength;\n                view.setUint32(offset, unitDataLen);\n                offset += 4;\n                mdat.set(unitData, offset);\n                offset += unitDataLen;\n                mp4SampleLength += 4 + unitDataLen;\n            }\n\n            if (!isSafari) {\n                // expected sample duration is the Decoding Timestamp diff of consecutive samples\n                if (i < nbSamples - 1) {\n                    mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n                } else {\n                    const config = this._config;\n                    let lastFrameDuration = 0;\n                    if (this._stashLastVideoSample) {\n                        lastFrameDuration = this._stashLastVideoSample.dts - avcSample.dts;\n                    } else {\n                        lastFrameDuration =\n                            track.refSampleDuration ||\n                            time.sampleDuration ||\n                            avcSample.dts - inputSamples[i > 0 ? i - 1 : i].dts;\n                    }\n                    lastFrameDuration = Math.floor(lastFrameDuration / 90) * 90;\n                    if (config.stretchShortVideoTrack && this._nextAudioPts) {\n                        // In some cases, a segment's audio track duration may exceed the video track duration.\n                        // Since we've already remuxed audio, and we know how long the audio track is, we look to\n                        // see if the delta to the next segment is longer than maxBufferHole.\n                        // If so, playback would potentially get stuck, so we artificially inflate\n                        // the duration of the last frame to minimize any potential gap between segments.\n\n                        const maxBufferHole = config.maxBufferHole,\n                            gapTolerance = Math.floor(maxBufferHole * timeScale),\n                            deltaToFrameEnd =\n                                (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this._nextAudioPts) -\n                                avcSample.pts;\n                        if (deltaToFrameEnd > gapTolerance) {\n                            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                            if (mp4SampleDuration < 0) {\n                                mp4SampleDuration = lastFrameDuration;\n                            }\n\n                            Log.v(\n                                `It is approximately ${deltaToFrameEnd /\n                                90} ms to the next segment; using duration ${mp4SampleDuration /\n                                90} ms for the last video frame.`\n                            );\n                        } else {\n                            mp4SampleDuration = lastFrameDuration;\n                        }\n                    } else {\n                        mp4SampleDuration = lastFrameDuration;\n                    }\n                }\n                compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n            } else {\n                compositionTimeOffset = Math.max(\n                    0,\n                    mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration)\n                );\n            }\n\n            // samplemp4SampleDurationfpsdurationduration\n            if (mp4SampleDuration < 0 || isNaN(mp4SampleDuration)) {\n                let fix = 0;\n                if (contiguous && inputSamples.length < 2) {\n                    fix = delta * 90;\n                }\n                mp4SampleDuration = Math.max((track.refSampleDuration || time.sampleDuration) - fix, 90);\n            }\n            // console.log('mp4SampleDuration', mp4SampleDuration);\n            outputSamples.push({\n                size: mp4SampleLength,\n                // constant duration\n                duration: mp4SampleDuration,\n                cts: compositionTimeOffset,\n                flags: {\n                    isLeading: 0,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradPrio: 0,\n                    dependsOn: avcSample.key ? 2 : 1,\n                    isNonSync: avcSample.key ? 0 : 1\n                }\n            });\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n\n        this._nextAvcDts = lastDTS + mp4SampleDuration;\n        const dropped = track.dropped;\n        track.dropped = 0;\n        if (outputSamples.length && this._forceFirstIDR) {\n            const flags = outputSamples[0].flags;\n            // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue\n            // https://code.google.com/p/chromium/issues/detail?id=229412\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n        }\n        track.samples = outputSamples;\n        moof = MP4.moof(track.sequenceNumber++, firstDTS, track);\n        track.samples = [];\n\n        const data: any = {\n            payload: this._mergeBoxes('video', moof, mdat),\n            startPTS: firstPTS / timeScale,\n            endPTS: (lastPTS + mp4SampleDuration) / timeScale,\n            startDTS: firstDTS / timeScale,\n            endDTS: this._nextAvcDts / timeScale,\n            type: 'video',\n            hasAudio: false,\n            hasVideo: true,\n            nb: outputSamples.length,\n            dropped: dropped,\n            streamDTS,\n            key,\n            extra: this._extra,\n        };\n        this._videoTime.vLastPTS = data.endPTS;\n        this._observer.trigger(LasEvents.PARSING_DATA, data);\n\n        // duration\n        if (time.nbSamples === 0) {\n            time.firstDTS = firstDTS;\n        }\n        time.nbSamples += nbSamples;\n        time.sampleDuration = Math.round((this._nextAvcDts - time.firstDTS) / time.nbSamples);\n        time.endDts = this._nextAvcDts;\n\n        return data;\n    }\n\n    remuxAudio(track: ATrack, timeOffset: number, contiguous: boolean, accurateTimeOffset: boolean = false) {\n        if (!track.samples.length) {\n            return null;\n        }\n        const inputTimeScale = track.inputTimeScale,\n            mp4timeScale = track.timescale,\n            scaleFactor = inputTimeScale / mp4timeScale,\n            mp4SampleDuration = track.isAAC ? 1024 : 1152,\n            inputSampleDuration = mp4SampleDuration * scaleFactor,\n            ptsNormalize = this._PTSNormalize,\n            initPTS = this._initPTS,\n            rawMPEG = !track.isAAC && this._typeSupported.mpeg,\n            outputSamples = [],\n            streamDTS = track.samples[0].streamDTS / 1000;\n        let offset = rawMPEG ? 0 : 8,\n            mp4Sample,\n            fillFrame,\n            mdat,\n            moof,\n            firstPTS,\n            lastPTS,\n            inputSamples = track.samples,\n            nextAudioPts = this._nextAudioPts,\n            resetPts = false;\n        if (typeof initPTS === 'undefined') {\n            return;\n        }\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity and this also avoids audio glitches/cut when switching quality,\n        // or reporting wrong duration on first audio frame\n        contiguous =\n            contiguous ||\n            !!(\n                inputSamples.length &&\n                nextAudioPts &&\n                ((accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1) ||\n                    Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration)\n            );\n\n        // compute normalized PTS\n        inputSamples.forEach(function (sample) {\n            sample.pts = sample.dts = ptsNormalize(sample.pts - initPTS, timeOffset * inputTimeScale);\n        });\n\n        // filter out sample with negative PTS that are not playable anyway\n        // if we don't remove these negative samples, they will shift all audio samples forward.\n        // leading to audio overlap between current / next fragment\n        inputSamples = inputSamples.filter(function (sample) {\n            return sample.pts >= 0;\n        });\n\n        // in case all samples have negative PTS, and have been filtered out, return now\n        if (inputSamples.length === 0) {\n            return null;\n        }\n        if (!contiguous || typeof nextAudioPts === 'undefined') {\n            if (!accurateTimeOffset) {\n                // if frag are mot contiguous and if we cant trust time offset,\n                // let's use first sample PTS as next audio PTS\n                nextAudioPts = inputSamples[0].pts;\n            } else {\n                // if timeOffset is accurate, let's use it as predicted next audio PTS\n                nextAudioPts = timeOffset * inputTimeScale;\n            }\n            resetPts = true;\n        }\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n        if (typeof nextAudioPts === 'undefined') {\n            return;\n        }\n        if (track.isAAC) {\n            const maxAudioFramesDrift = this._config.maxAudioFramesDrift;\n            for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {\n                // First, let's see how far off this frame is from where we expect it to be\n                const sample = inputSamples[i],\n                    pts = sample.pts,\n                    delta = pts - nextPts;\n\n                const duration = Math.abs((1000 * delta) / inputTimeScale);\n\n                // If we're overlapping by more than a duration, drop this sample\n                if (delta <= -maxAudioFramesDrift * inputSampleDuration) {\n                    Log.w(\n                        `Dropping 1 audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(\n                            duration\n                        )} ms overlap.`\n                    );\n                    inputSamples.splice(i, 1);\n                    // Don't touch nextPtsNorm or i\n                } // eslint-disable-line brace-style\n\n                // Insert missing frames if:\n                // 1: We're more than maxAudioFramesDrift frame away\n                // 2: Not more than MAX_SILENT_FRAME_DURATION away\n                // 3: currentTime (aka nextPtsNorm) is not 0\n                else if (\n                    delta >= maxAudioFramesDrift * inputSampleDuration &&\n                    duration < MAX_SILENT_FRAME_DURATION &&\n                    nextPts\n                ) {\n                    const missing = Math.round(delta / inputSampleDuration);\n                    Log.w(\n                        `Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(\n                            3\n                        )}s due to ${Math.round((1000 * delta) / inputTimeScale)} ms gap.`\n                    );\n                    for (let j = 0; j < missing; j++) {\n                        const newStamp = Math.max(nextPts, 0);\n                        fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                        if (!fillFrame) {\n                            Log.v('Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                            fillFrame = sample.unit.subarray();\n                        }\n                        inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });\n                        nextPts += inputSampleDuration;\n                        i++;\n                    }\n\n                    // Adjust sample to next expected pts\n                    sample.pts = sample.dts = nextPts;\n                    nextPts += inputSampleDuration;\n                    i++;\n                } else {\n                    // Otherwise, just adjust pts\n                    if (Math.abs(delta) > 0.1 * inputSampleDuration) {\n                        // Log.v(\n                        //     `Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(\n                        //         pts / 90\n                        //     )} (should be ${Math.round(inputSampleDuration)}).`\n                        // );\n                    }\n                    sample.pts = sample.dts = nextPts;\n                    nextPts += inputSampleDuration;\n                    i++;\n                }\n            }\n        }\n\n        // compute mdat size, as we eventually filtered/added some samples\n        let nbSamples = inputSamples.length;\n        let mdatSize = 0;\n        while (nbSamples--) {\n            mdatSize += inputSamples[nbSamples].unit.byteLength;\n        }\n\n        for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\n            const audioSample = inputSamples[j];\n            const unit = audioSample.unit;\n            let pts = audioSample.pts;\n            // console.log('audioSample.pts', audioSample);\n            // Log.v(`Audio/PTS:${Math.round(pts/90)}`);\n            // if not first sample\n            if (typeof lastPTS !== 'undefined' && mp4Sample) {\n                mp4Sample.duration = Math.round((pts - lastPTS) / scaleFactor);\n            } else {\n                const delta = Math.round((1000 * (pts - nextAudioPts)) / inputTimeScale);\n                let numMissingFrames = 0;\n                // if fragment are contiguous, detect hole/overlapping between fragments\n                // contiguous fragments are consecutive fragments from same quality level\n                // (same level, new SN = old SN + 1)\n                if (contiguous && track.isAAC) {\n                    // log delta\n                    if (delta) {\n                        if (delta > 0 && delta < MAX_SILENT_FRAME_DURATION) {\n                            numMissingFrames = Math.round((pts - nextAudioPts) / inputSampleDuration);\n                            Log.v(`${delta} ms hole between AAC samples detected,filling it`);\n                            if (numMissingFrames > 0) {\n                                fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                                if (!fillFrame) {\n                                    fillFrame = unit.subarray();\n                                }\n\n                                mdatSize += numMissingFrames * fillFrame.length;\n                            }\n                            // if we have frame overlap, overlapping for more than half a frame duraion\n                        } else if (delta < -12) {\n                            // drop overlapping audio frames... browser will deal with it\n                            Log.v(\n                                `drop overlapping AAC sample, expected/parsed/delta:${(\n                                    nextAudioPts / inputTimeScale\n                                ).toFixed(3)}s/${(pts / inputTimeScale).toFixed(3)}s/${-delta}ms`\n                            );\n                            mdatSize -= unit.byteLength;\n                            continue;\n                        }\n                        // set PTS/DTS to expected PTS/DTS\n                        pts = nextAudioPts;\n                    }\n                }\n                // remember first PTS of our audioSamples\n                firstPTS = pts;\n                if (mdatSize > 0) {\n                    mdatSize += offset;\n                    try {\n                        mdat = new Uint8Array(mdatSize);\n                    } catch (err) {\n                        this._observer.trigger(LasEvents.ERROR, {\n                            type: ErrorTypes.MUX_ERROR,\n                            details: ErrorDetails.REMUX_ALLOC_ERROR,\n                            fatal: false,\n                            bytes: mdatSize,\n                            reason: `fail allocating audio mdat ${mdatSize}`\n                        });\n                        return null;\n                    }\n                    if (!rawMPEG) {\n                        const view = new DataView(mdat.buffer);\n                        view.setUint32(0, mdatSize);\n                        mdat.set(MP4.types.mdat, 4);\n                    }\n                } else {\n                    track.samples = [];\n                    // no audio samples\n                    return null;\n                }\n                for (let i = 0; i < numMissingFrames; i++) {\n                    fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                    if (!fillFrame) {\n                        Log.v('Unable to get silent frame for given audio codec; duplicating this frame instead.');\n                        fillFrame = unit.subarray();\n                    }\n                    mdat.set(fillFrame, offset);\n                    offset += fillFrame.byteLength;\n                    mp4Sample = {\n                        size: fillFrame.byteLength,\n                        cts: 0,\n                        duration: 1024,\n                        flags: {\n                            isLeading: 0,\n                            isDependedOn: 0,\n                            hasRedundancy: 0,\n                            degradPrio: 0,\n                            dependsOn: 1\n                        }\n                    };\n                    outputSamples.push(mp4Sample);\n                }\n            }\n            if (!mdat) {\n                return;\n            }\n            mdat.set(unit, offset);\n            const unitLen = unit.byteLength;\n            offset += unitLen;\n            // PTS/DTS/initDTS/normPTS/normDTS/relative PTS\n            mp4Sample = {\n                size: unitLen,\n                cts: 0,\n                duration: 0,\n                flags: {\n                    isLeading: 0,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradPrio: 0,\n                    dependsOn: 1\n                }\n            };\n            outputSamples.push(mp4Sample);\n            lastPTS = pts;\n        }\n        let lastSampleDuration = 0;\n        nbSamples = outputSamples.length;\n        if (!mp4Sample) {\n            return;\n        }\n        // set last sample duration as being identical to previous sample\n        if (nbSamples >= 2) {\n            lastSampleDuration = outputSamples[nbSamples - 2].duration;\n            mp4Sample.duration = lastSampleDuration;\n        }\n        if (nbSamples && typeof lastPTS === 'number' && mdat) {\n            if (mp4Sample && mp4Sample.duration === 0) {\n                mp4Sample.duration = track.isAAC ? 1024 : 1152;\n            }\n            // next audio sample PTS should be equal to last sample PTS + duration\n            this._nextAudioPts = nextAudioPts = lastPTS + scaleFactor * (lastSampleDuration || mp4SampleDuration);\n            // Log.v('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));\n            track.samples = outputSamples;\n            if (rawMPEG) {\n                moof = new Uint8Array();\n            } else {\n                moof = MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);\n            }\n\n            track.samples = [];\n            const start = firstPTS / inputTimeScale;\n            const end = nextAudioPts / inputTimeScale;\n            const audioData = {\n                payload: this._mergeBoxes('audio', moof, mdat),\n                startPTS: start,\n                endPTS: end,\n                startDTS: start,\n                endDTS: end,\n                type: 'audio',\n                hasAudio: true,\n                hasVideo: false,\n                nb: nbSamples,\n                streamDTS,\n                extra: this._extra,\n            };\n            this._videoTime.aLastPTS = audioData.endPTS;\n            this._observer.trigger(LasEvents.PARSING_DATA, audioData);\n            return audioData;\n        }\n        if (resetPts) {\n            delete this._nextAudioPts;\n        }\n        track.samples = [];\n        return null;\n    }\n\n    remuxEmptyAudio(track: ATrack, timeOffset: number, contiguous: boolean, videoData: any) {\n        if (typeof this._initDTS === 'undefined') {\n            return;\n        }\n        const inputTimeScale = track.inputTimeScale,\n            mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,\n            scaleFactor = inputTimeScale / mp4timeScale,\n            nextAudioPts = this._nextAudioPts,\n            // sync with video's timestamp\n            startDTS =\n                (typeof nextAudioPts !== 'undefined' ? nextAudioPts : videoData.startDTS * inputTimeScale) +\n                this._initDTS,\n            endDTS = videoData.endDTS * inputTimeScale + this._initDTS,\n            // one sample's duration value\n            sampleDuration = 1024,\n            frameDuration = scaleFactor * sampleDuration,\n            // samples count of this segment's duration\n            nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),\n            // silent frame\n            silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n\n        Log.w('remux empty Audio');\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n            Log.d('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');\n            return;\n        }\n\n        const samples = [];\n        for (let i = 0; i < nbSamples; i++) {\n            const stamp = startDTS + i * frameDuration;\n            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n        }\n        track.samples = samples;\n\n        this.remuxAudio(track, timeOffset, contiguous);\n    }\n\n    _PTSNormalize(value: number, reference?: number) {\n        let offset;\n        if (typeof reference === 'undefined') {\n            return value;\n        }\n\n        if (reference < value) {\n            // - 2^33\n            offset = -8589934592;\n        } else {\n            // + 2^33\n            offset = 8589934592;\n        }\n        /* PTS is 33bit (from 0 to 2^33 -1)\n      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n      PTS looping occured. fill the gap */\n        while (Math.abs(value - reference) > 4294967296) {\n            value += offset;\n        }\n\n        return value;\n    }\n\n    _resetVideoTime() {\n        this._videoTime = { nbSamples: 0, firstDTS: 0, sampleDuration: 3000, vLastPTS: 0, aLastPTS: 0 };\n    }\n\n    private _mergeBoxes(type: string, ...arr: Uint8Array[]): Uint8Array {\n        if (this._initSegment[type]) {\n            arr.unshift(this._initSegment[type]);\n            delete this._initSegment[type];\n        }\n        const len = arr.reduce((prev, cur) => {\n            if (cur) {\n                return prev + cur.byteLength;\n            }\n            return prev;\n        }, 0);\n        const result = new Uint8Array(len);\n        let index = 0;\n        arr.forEach(cur => {\n            if (cur) {\n                result.set(cur, index);\n                index += cur.byteLength;\n            }\n        });\n        return result;\n    }\n}\n\nexport default MP4Remuxer;\n","import Observer from '../core/observer';\nimport { ATrack } from '../types/remux';\nimport { ASCInfo, getAudioConfig } from './get-audio-config';\n\nexport function parseData(data: Uint8Array, offset: number): ASCInfo {\n    return {\n        objectType: data[offset + 2] >>> 3, // 5 bits\n        sampleingIndex: (data[offset + 2] & 0x07) << 1 | data[offset + 3] >>> 7, // 4 bits\n        chanelConfig: (data[offset + 3] & 0x78) >>> 3 // 4 bits\n    };\n}\n\nexport function initTrackConfig(track: ATrack, observer: Observer, data: Uint8Array, offset: number, audioCodec: string = '') {\n    if (!track.samplerate) {\n        const config = getAudioConfig(observer, parseData(data, offset), audioCodec);\n        if (config) {\n            track.config = config.config;\n            track.timescale = track.samplerate = config.samplerate;\n            track.channelCount = config.channelCount;\n            track.codec = config.codec;\n            track.manifestCodec = config.manifestCodec;\n            track.isAAC = true;\n        }\n    }\n}\n\nexport function getFrameDuration(samplerate: number): number {\n    return 1024 * 1000 / samplerate;\n}\n","import LasEvents from '../core/events';\nimport Observer from '../core/observer';\nimport { ErrorTypes, ErrorDetails } from '../core/errors';\nimport { Log } from '../utils/log';\n\nexport interface ASCInfo {\n    objectType: number;\n    sampleingIndex: number;\n    chanelConfig: number;\n}\n\nexport interface ASCConfig {\n    config: number[];\n    samplerate: number;\n    channelCount: number;\n    codec: string;\n    manifestCodec: string;\n}\n\nexport function getAudioConfig(observer: Observer, info: ASCInfo, audioCodec: string = ''): ASCConfig | null {\n    let extensionSampleingIndex: number, // :int\n        config: Array<number>,\n        objectType = info.objectType,\n        sampleingIndex = info.sampleingIndex,\n        chanelConfig = info.chanelConfig;\n    const userAgent = navigator.userAgent.toLowerCase(),\n        manifestCodec = audioCodec,\n        sampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n    if (sampleingIndex < 0 || sampleingIndex >= sampleingRates.length) {\n        observer.trigger(LasEvents.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.PARSING_ERROR,\n            fatal: true,\n            reason: `invalid sampling index:${sampleingIndex}`\n        });\n        return null;\n    }\n    if (chanelConfig < 0 || chanelConfig >= 8) {\n        observer.trigger(LasEvents.ERROR, {\n            type: ErrorTypes.MUX_ERROR,\n            details: ErrorDetails.PARSING_ERROR,\n            fatal: true,\n            reason: `invalid chanelConfig:${chanelConfig}`\n        });\n        return null;\n    }\n\n    Log.v(\n        `manifest codec:${audioCodec},data:type:${objectType},sampleingIndex:${sampleingIndex}[${\n            sampleingRates[sampleingIndex]\n        }Hz],channelConfig:${chanelConfig}`\n    );\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if ((/firefox/i).test(userAgent)) {\n        if (sampleingIndex >= 6) {\n            objectType = 5;\n            config = new Array(4);\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            extensionSampleingIndex = sampleingIndex - 3;\n        } else {\n            objectType = 2;\n            config = new Array(2);\n            extensionSampleingIndex = sampleingIndex;\n        }\n        // Android : always use AAC\n    } else if (userAgent.indexOf('android') !== -1) {\n        objectType = 2;\n        config = new Array(2);\n        extensionSampleingIndex = sampleingIndex;\n    } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not\n        support audio codec switch properly (like Chrome ...)\n    */\n        objectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (\n            audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1)\n            || !audioCodec && sampleingIndex >= 6\n        ) {\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            extensionSampleingIndex = sampleingIndex - 3;\n        } else {\n            /* if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1)\n                OR(manifest codec not specified and mono audio)\n                Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.\n                This is not a problem with stereo.\n            */\n            if (\n                audioCodec\n                    && audioCodec.indexOf('mp4a.40.2') !== -1\n                    && (sampleingIndex >= 6 && chanelConfig === 1 || (/vivaldi/i).test(userAgent))\n                || !audioCodec && chanelConfig === 1\n            ) {\n                objectType = 2;\n                config = new Array(2);\n            }\n            extensionSampleingIndex = sampleingIndex;\n        }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = objectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (sampleingIndex & 0x0e) >> 1;\n    config[1] |= (sampleingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= chanelConfig << 3;\n    if (objectType === 5) {\n        // extensionSampleingIndex\n        config[1] |= (extensionSampleingIndex & 0x0e) >> 1;\n        config[2] = (extensionSampleingIndex & 0x01) << 7;\n        // objectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n    }\n    return {\n        config: config,\n        samplerate: sampleingRates[sampleingIndex],\n        channelCount: chanelConfig,\n        codec: 'mp4a.40.' + objectType,\n        manifestCodec: manifestCodec\n    };\n}\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\n// Exponential-Golomb buffer decoder\nclass ExpGolomb {\n    private _buffer: Uint8Array | null;\n    private _buffer_index: number;\n    private _total_bytes: number;\n    private _total_bits: number;\n    private _current_word: number;\n    private _current_word_bits_left: number;\n\n    constructor(uint8array: Uint8Array) {\n        this._buffer = uint8array;\n        this._buffer_index = 0;\n        this._total_bytes = uint8array.byteLength;\n        this._total_bits = uint8array.byteLength * 8;\n        this._current_word = 0;\n        this._current_word_bits_left = 0;\n    }\n\n    destroy() {\n        this._buffer = null;\n    }\n\n    _fillCurrentWord() {\n        let buffer_bytes_left = this._total_bytes - this._buffer_index;\n        if (buffer_bytes_left <= 0 || !this._buffer) {\n            throw new Error('ExpGolomb: _fillCurrentWord() but no bytes available');\n        }\n\n        let bytes_read = Math.min(4, buffer_bytes_left);\n        let word = new Uint8Array(4);\n        word.set(this._buffer.subarray(this._buffer_index, this._buffer_index + bytes_read));\n        this._current_word = new DataView(word.buffer).getUint32(0, false);\n\n        this._buffer_index += bytes_read;\n        this._current_word_bits_left = bytes_read * 8;\n    }\n\n    readBits(bits: number) {\n        if (bits > 32) {\n            throw new Error('ExpGolomb: readBits() bits exceeded max 32bits!');\n        }\n\n        if (bits <= this._current_word_bits_left) {\n            let result = this._current_word >>> (32 - bits);\n            this._current_word <<= bits;\n            this._current_word_bits_left -= bits;\n            return result;\n        }\n\n        let result = this._current_word_bits_left ? this._current_word : 0;\n        result = result >>> (32 - this._current_word_bits_left);\n        let bits_need_left = bits - this._current_word_bits_left;\n\n        this._fillCurrentWord();\n        let bits_read_next = Math.min(bits_need_left, this._current_word_bits_left);\n\n        let result2 = this._current_word >>> (32 - bits_read_next);\n        this._current_word <<= bits_read_next;\n        this._current_word_bits_left -= bits_read_next;\n\n        result = (result << bits_read_next) | result2;\n        return result;\n    }\n\n    readBool() {\n        return this.readBits(1) === 1;\n    }\n\n    // ():int\n    readUByte() {\n        return this.readBits(8);\n    }\n\n    readUShort() {\n        return this.readBits(16);\n    }\n\n    readUInt() {\n        return this.readBits(32);\n    }\n\n    readByte() {\n        return this.readBits(8);\n    }\n\n    _skipLeadingZero(): number {\n        let zero_count;\n        for (zero_count = 0; zero_count < this._current_word_bits_left; zero_count++) {\n            if ((this._current_word & (0x80000000 >>> zero_count)) !== 0) {\n                this._current_word <<= zero_count;\n                this._current_word_bits_left -= zero_count;\n                return zero_count;\n            }\n        }\n        this._fillCurrentWord();\n        return zero_count + this._skipLeadingZero();\n    }\n\n    readUEG() {\n        // unsigned exponential golomb\n        let leading_zeros = this._skipLeadingZero();\n        return this.readBits(leading_zeros + 1) - 1;\n    }\n\n    readSEG() {\n        // signed exponential golomb\n        let value = this.readUEG();\n        if (value & 0x01) {\n            return (value + 1) >>> 1;\n        } else {\n            return -1 * (value >>> 1);\n        }\n    }\n\n    readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n    }\n\n    getBitsLeft() {\n        return (this._total_bytes - this._buffer_index) * 8 + this._current_word_bits_left;\n    }\n\n    get bytesAvailable() {\n        return this._total_bytes - this._buffer_index;\n    }\n}\n\nexport default ExpGolomb;\n","/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable */\nimport ExpGolomb from './exp-golomb';\n\nconst HEVC_MAX_SPS_COUNT = 16;\nconst HEVC_MAIN: Record<number, string> = { 1: 'Main', 2: 'Main 10', 3: 'Main Still Picture', 4: 'Rext' };\nconst HEVC_LEVELS: Record<number, number> = {\n    30: 1,\n    60: 2,\n    63: 2.1,\n    90: 3,\n    93: 3.1,\n    120: 4,\n    123: 4.1,\n    150: 5,\n    153: 5.1,\n    156: 5.2,\n    180: 6,\n    183: 6.1,\n    186: 6.2,\n    255: 8.5\n};\n\ntype SPSInfo = {\n    profile_string: string; // baseline, high, high10, ...\n    level_string: string; // 3, 3.1, 4, 4.1, 5, 5.1, ...\n    bit_depth: number; // 8bit, 10bit, ...\n    chroma_format: number; // 4:2:0, 4:2:2, ...\n    chroma_format_string: string;\n    frame_rate: {\n        fixed: boolean;\n        fps: number;\n        fps_den: number;\n        fps_num: number;\n    };\n    sar_ratio: {\n        width: number;\n        height: number;\n    };\n    codec_size: {\n        width: number;\n        height: number;\n    };\n    present_size: {\n        width: number;\n        height: number;\n    };\n};\n\ntype HEVCSPSInfo = {\n    chroma_format_string: string;\n    profile_string: string;\n    level_string: string;\n    width: number;\n    height: number;\n};\n\nclass SPSParser {\n    static _ebsp2rbsp(uint8array: Uint8Array) {\n        const src = uint8array;\n        const src_length = src.byteLength;\n        const dst = new Uint8Array(src_length);\n        let dst_idx = 0;\n\n        for (let i = 0; i < src_length; i++) {\n            if (i >= 2) {\n                // Unescape: Skip 0x03 after 00 00\n                if (src[i] === 0x03 && src[i - 1] === 0x00 && src[i - 2] === 0x00) {\n                    continue;\n                }\n            }\n            dst[dst_idx] = src[i];\n            dst_idx++;\n        }\n\n        return new Uint8Array(dst.buffer, 0, dst_idx);\n    }\n\n    static parseHEVCSPS(uint8array: Uint8Array): HEVCSPSInfo | null {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb: ExpGolomb | null = new ExpGolomb(rbsp);\n        const ptl: any = { general_ptl: {}, sub_layer_ptl: {} };\n        gb.readBits(16);\n        gb.readBits(4); // sps_video_parameter_set_id\n        let max_sub_layers = gb.readBits(3) + 1; // sps_max_sub_layers_minus1\n        gb.readBits(1); // temporalIdNested\n\n        if (!SPSParser._parsePTL(gb, ptl, max_sub_layers)) {\n            return null;\n        }\n\n        const sps_id = gb.readUEG();\n        if (sps_id >= HEVC_MAX_SPS_COUNT) {\n            return null;\n        }\n        let chroma_format_idc = gb.readUEG();\n\n        if (chroma_format_idc == 3) {\n            const separate_colour_plane_flag = gb.readBits(1);\n            if (separate_colour_plane_flag) {\n                chroma_format_idc = 0;\n            }\n        }\n\n        const width = gb.readUEG();\n        const height = gb.readUEG();\n        gb.destroy();\n        gb = null;\n        // let conformance_window_flag = gb.readBits(1);\n        return {\n            chroma_format_string: chroma_format_idc === 3 ? '4:4:4' : '4:2:0',\n            profile_string: ptl.general_ptl.profile_string,\n            level_string: ptl.general_ptl.level_string,\n            width: width,\n            height: height\n        };\n        // hvcc_parse_ptl end\n    }\n\n    static _parsePTL(gb: ExpGolomb, ptl: any, max_num_sub_layers: number) {\n        if (\n            !this._decodeProfileTierLevel(gb, ptl.general_ptl) ||\n            gb.getBitsLeft() < 8 + 8 * 2 * (max_num_sub_layers - 1 > 0 ? 1 : 0)\n        ) {\n            return false;\n        }\n\n        ptl.general_ptl.level_idc = gb.readBits(8);\n        ptl.general_ptl.level_string = this.getHEVCLevelString(ptl.general_ptl.level_idc);\n        ptl.sub_layer_profile_present_flag = [];\n        ptl.sub_layer_level_present_flag = [];\n        for (let i = 0; i < max_num_sub_layers - 1; i++) {\n            ptl.sub_layer_profile_present_flag[i] = gb.readBits(1);\n            ptl.sub_layer_level_present_flag[i] = gb.readBits(1);\n        }\n\n        if (max_num_sub_layers - 1 > 0) {\n            for (let i = max_num_sub_layers - 1; i < 8; i++) {\n                gb.readBits(2); // reserved_zero_2bits[i]\n            }\n        }\n        for (let i = 0; i < max_num_sub_layers - 1; i++) {\n            if (ptl.sub_layer_profile_present_flag[i] && this._decodeProfileTierLevel(gb, ptl.sub_layer_ptl)) {\n                return false;\n            }\n            if (ptl.sub_layer_level_present_flag[i]) {\n                if (gb.getBitsLeft() < 8) {\n                    return false;\n                } else ptl.sub_layer_ptl[i].level_idc = gb.readBits(8);\n            }\n        }\n        return true;\n    }\n\n    static _decodeProfileTierLevel(gb: ExpGolomb, ptl: any) {\n        if (gb.getBitsLeft() < 2 + 1 + 5 + 32 + 4 + 16 + 16 + 12) {\n            return false;\n        }\n\n        ptl.profile_space = gb.readBits(2);\n        ptl.tier_flag = gb.readBits(1);\n        ptl.profile_idc = gb.readBits(5);\n        ptl.profile_compatibility_flag = [];\n\n        for (let i = 0; i < 32; i++) {\n            ptl.profile_compatibility_flag[i] = gb.readBits(1);\n            if (ptl.profile_idc == 0 && i > 0 && ptl.profile_compatibility_flag[i]) ptl.profile_idc = i;\n        }\n        ptl.progressive_source_flag = gb.readBits(1);\n        ptl.interlaced_source_flag = gb.readBits(1);\n        ptl.non_packed_constraint_flag = gb.readBits(1);\n        ptl.frame_only_constraint_flag = gb.readBits(1);\n\n        gb.readBits(16);\n        gb.readBits(16);\n        gb.readBits(12);\n        ptl.profile_string = this.getHEVCProfileString(ptl.profile_idc);\n        return true;\n    }\n\n    static parseSPS(uint8array: Uint8Array): SPSInfo {\n        const rbsp = SPSParser._ebsp2rbsp(uint8array);\n        let gb: ExpGolomb | null = new ExpGolomb(rbsp);\n\n        gb.readByte();\n        const profile_idc = gb.readByte(); // profile_idc\n        gb.readByte(); // constraint_set_flags[5] + reserved_zero[3]\n        const level_idc = gb.readByte(); // level_idc\n        gb.readUEG(); // seq_parameter_set_id\n\n        const profile_string = SPSParser.getProfileString(profile_idc);\n        const level_string = SPSParser.getLevelString(level_idc);\n        let chroma_format_idc = 1;\n        let chroma_format = 420;\n        const chroma_format_table = [0, 420, 422, 444];\n        let bit_depth = 8;\n\n        if (\n            profile_idc === 100 ||\n            profile_idc === 110 ||\n            profile_idc === 122 ||\n            profile_idc === 244 ||\n            profile_idc === 44 ||\n            profile_idc === 83 ||\n            profile_idc === 86 ||\n            profile_idc === 118 ||\n            profile_idc === 128 ||\n            profile_idc === 138 ||\n            profile_idc === 144\n        ) {\n            chroma_format_idc = gb.readUEG();\n            if (chroma_format_idc === 3) {\n                gb.readBits(1); // separate_colour_plane_flag\n            }\n            if (chroma_format_idc <= 3) {\n                chroma_format = chroma_format_table[chroma_format_idc];\n            }\n\n            bit_depth = gb.readUEG() + 8; // bit_depth_luma_minus8\n            gb.readUEG(); // bit_depth_chroma_minus8\n            gb.readBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (gb.readBool()) {\n                // seq_scaling_matrix_present_flag\n                const scaling_list_count = chroma_format_idc !== 3 ? 8 : 12;\n                for (let i = 0; i < scaling_list_count; i++) {\n                    if (gb.readBool()) {\n                        // seq_scaling_list_present_flag\n                        if (i < 6) {\n                            SPSParser._skipScalingList(gb, 16);\n                        } else {\n                            SPSParser._skipScalingList(gb, 64);\n                        }\n                    }\n                }\n            }\n        }\n        gb.readUEG(); // log2_max_frame_num_minus4\n        const pic_order_cnt_type = gb.readUEG();\n        if (pic_order_cnt_type === 0) {\n            gb.readUEG(); // log2_max_pic_order_cnt_lsb_minus_4\n        } else if (pic_order_cnt_type === 1) {\n            gb.readBits(1); // delta_pic_order_always_zero_flag\n            gb.readSEG(); // offset_for_non_ref_pic\n            gb.readSEG(); // offset_for_top_to_bottom_field\n            const num_ref_frames_in_pic_order_cnt_cycle = gb.readUEG();\n            for (let i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {\n                gb.readSEG(); // offset_for_ref_frame\n            }\n        }\n        gb.readUEG(); // max_num_ref_frames\n        gb.readBits(1); // gaps_in_frame_num_value_allowed_flag\n\n        const pic_width_in_mbs_minus1 = gb.readUEG();\n        const pic_height_in_map_units_minus1 = gb.readUEG();\n\n        const frame_mbs_only_flag = gb.readBits(1);\n        if (frame_mbs_only_flag === 0) {\n            gb.readBits(1); // mb_adaptive_frame_field_flag\n        }\n        gb.readBits(1); // direct_8x8_inference_flag\n\n        let frame_crop_left_offset = 0;\n        let frame_crop_right_offset = 0;\n        let frame_crop_top_offset = 0;\n        let frame_crop_bottom_offset = 0;\n\n        const frame_cropping_flag = gb.readBool();\n        if (frame_cropping_flag) {\n            frame_crop_left_offset = gb.readUEG();\n            frame_crop_right_offset = gb.readUEG();\n            frame_crop_top_offset = gb.readUEG();\n            frame_crop_bottom_offset = gb.readUEG();\n        }\n\n        let sar_width = 1,\n            sar_height = 1;\n        let fps = 0,\n            fps_fixed = true,\n            fps_num = 0,\n            fps_den = 0;\n\n        const vui_parameters_present_flag = gb.readBool();\n        if (vui_parameters_present_flag) {\n            if (gb.readBool()) {\n                // aspect_ratio_info_present_flag\n                const aspect_ratio_idc = gb.readByte();\n                const sar_w_table = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2];\n                const sar_h_table = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n\n                if (aspect_ratio_idc > 0 && aspect_ratio_idc < 16) {\n                    sar_width = sar_w_table[aspect_ratio_idc - 1];\n                    sar_height = sar_h_table[aspect_ratio_idc - 1];\n                } else if (aspect_ratio_idc === 255) {\n                    sar_width = (gb.readByte() << 8) | gb.readByte();\n                    sar_height = (gb.readByte() << 8) | gb.readByte();\n                }\n            }\n\n            if (gb.readBool()) {\n                // overscan_info_present_flag\n                gb.readBool(); // overscan_appropriate_flag\n            }\n            if (gb.readBool()) {\n                // video_signal_type_present_flag\n                gb.readBits(4); // video_format & video_full_range_flag\n                if (gb.readBool()) {\n                    // colour_description_present_flag\n                    gb.readBits(24); // colour_primaries & transfer_characteristics & matrix_coefficients\n                }\n            }\n            if (gb.readBool()) {\n                // chroma_loc_info_present_flag\n                gb.readUEG(); // chroma_sample_loc_type_top_field\n                gb.readUEG(); // chroma_sample_loc_type_bottom_field\n            }\n            if (gb.readBool()) {\n                // timing_info_present_flag\n                const num_units_in_tick = gb.readBits(32);\n                const time_scale = gb.readBits(32);\n                fps_fixed = gb.readBool(); // fixed_frame_rate_flag\n\n                fps_num = time_scale;\n                fps_den = num_units_in_tick * 2;\n                fps = fps_num / fps_den;\n            }\n        }\n\n        let sarScale = 1;\n        if (sar_width !== 1 || sar_height !== 1) {\n            sarScale = sar_width / sar_height;\n        }\n\n        let crop_unit_x = 0,\n            crop_unit_y = 0;\n        if (chroma_format_idc === 0) {\n            crop_unit_x = 1;\n            crop_unit_y = 2 - frame_mbs_only_flag;\n        } else {\n            const sub_wc = chroma_format_idc === 3 ? 1 : 2;\n            const sub_hc = chroma_format_idc === 1 ? 2 : 1;\n            crop_unit_x = sub_wc;\n            crop_unit_y = sub_hc * (2 - frame_mbs_only_flag);\n        }\n\n        let codec_width = (pic_width_in_mbs_minus1 + 1) * 16;\n        let codec_height = (2 - frame_mbs_only_flag) * ((pic_height_in_map_units_minus1 + 1) * 16);\n\n        codec_width -= (frame_crop_left_offset + frame_crop_right_offset) * crop_unit_x;\n        codec_height -= (frame_crop_top_offset + frame_crop_bottom_offset) * crop_unit_y;\n\n        const present_width = Math.ceil(codec_width * sarScale);\n\n        gb.destroy();\n        gb = null;\n\n        return {\n            profile_string, // baseline, high, high10, ...\n            level_string, // 3, 3.1, 4, 4.1, 5, 5.1, ...\n            bit_depth, // 8bit, 10bit, ...\n            chroma_format, // 4:2:0, 4:2:2, ...\n            chroma_format_string: SPSParser.getChromaFormatString(chroma_format),\n\n            frame_rate: {\n                fixed: fps_fixed,\n                fps,\n                fps_den,\n                fps_num\n            },\n\n            sar_ratio: {\n                width: sar_width,\n                height: sar_height\n            },\n\n            codec_size: {\n                width: codec_width,\n                height: codec_height\n            },\n\n            present_size: {\n                width: present_width,\n                height: codec_height\n            }\n        };\n    }\n\n    static _skipScalingList(gb: ExpGolomb, count: number) {\n        let last_scale = 8,\n            next_scale = 8;\n        let delta_scale = 0;\n        for (let i = 0; i < count; i++) {\n            if (next_scale !== 0) {\n                delta_scale = gb.readSEG();\n                next_scale = (last_scale + delta_scale + 256) % 256;\n            }\n            last_scale = next_scale === 0 ? last_scale : next_scale;\n        }\n    }\n\n    static getProfileString(profile_idc: number) {\n        switch (profile_idc) {\n            case 66:\n                return 'Baseline';\n            case 77:\n                return 'Main';\n            case 88:\n                return 'Extended';\n            case 100:\n                return 'High';\n            case 110:\n                return 'High10';\n            case 122:\n                return 'High422';\n            case 244:\n                return 'High444';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getLevelString(level_idc: number) {\n        return (level_idc / 10).toFixed(1);\n    }\n\n    static getChromaFormatString(chroma: number) {\n        switch (chroma) {\n            case 420:\n                return '4:2:0';\n            case 422:\n                return '4:2:2';\n            case 444:\n                return '4:4:4';\n            default:\n                return 'Unknown';\n        }\n    }\n\n    static getHEVCProfileString(profile_idc: number) {\n        return HEVC_MAIN[profile_idc];\n    }\n\n    static getHEVCLevelString(level_idc: number) {\n        return HEVC_LEVELS[level_idc];\n    }\n}\n\nexport default SPSParser;\n","/* eslint-disable */\nfunction decodeUTF8(uint8array: Uint8Array) {\n    const out = [];\n    const input = uint8array;\n    let i = 0;\n    const length = uint8array.length;\n\n    while (i < length) {\n        if (input[i] < 0x80) {\n            out.push(String.fromCharCode(input[i]));\n            ++i;\n            continue;\n        } else if (input[i] < 0xc0) {\n            // fallthrough\n        } else if (input[i] < 0xe0) {\n            if (checkContinuation(input, i, 1)) {\n                const ucs4 = ((input[i] & 0x1f) << 6) | (input[i + 1] & 0x3f);\n                if (ucs4 >= 0x80) {\n                    out.push(String.fromCharCode(ucs4 & 0xffff));\n                    i += 2;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xf0) {\n            if (checkContinuation(input, i, 2)) {\n                const ucs4 = ((input[i] & 0xf) << 12) | ((input[i + 1] & 0x3f) << 6) | (input[i + 2] & 0x3f);\n                if (ucs4 >= 0x800 && (ucs4 & 0xf800) !== 0xd800) {\n                    out.push(String.fromCharCode(ucs4 & 0xffff));\n                    i += 3;\n                    continue;\n                }\n            }\n        } else if (input[i] < 0xf8) {\n            if (checkContinuation(input, i, 3)) {\n                let ucs4 =\n                    ((input[i] & 0x7) << 18) |\n                    ((input[i + 1] & 0x3f) << 12) |\n                    ((input[i + 2] & 0x3f) << 6) |\n                    (input[i + 3] & 0x3f);\n                if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n                    ucs4 -= 0x10000;\n                    out.push(String.fromCharCode((ucs4 >>> 10) | 0xd800));\n                    out.push(String.fromCharCode((ucs4 & 0x3ff) | 0xdc00));\n                    i += 4;\n                    continue;\n                }\n            }\n        }\n        out.push(String.fromCharCode(0xfffd));\n        ++i;\n    }\n\n    return out.join('');\n}\n\nfunction checkContinuation(uint8array: Uint8Array, start: number, checkLength: number) {\n    let array = uint8array;\n    if (start + checkLength < array.length) {\n        while (checkLength--) {\n            if ((array[++start] & 0xc0) !== 0x80) return false;\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\nexport default decodeUTF8;\n","/* eslint-disable */\nimport decodeUTF8 from '../../utils/decodeUTF8';\nimport { Log } from '../../utils/log';\n\nlet tag: string = 'AMF';\n\nexport default class AMF {\n    /**\n     * metadata\n     */\n    static parseMetadata(arr: ArrayBuffer) {\n        let data: any = {};\n        try {\n            let name = AMF.parseScript(arr, 0);\n            let value = AMF.parseScript(arr, name.size);\n            data[name.data] = value.data;\n        } catch (e) {\n            Log.e('AMF', e.toString());\n        }\n        return data;\n    }\n\n    static parseObject(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let name = AMF.parseString(arrayBuffer, dataOffset);\n        let value = AMF.parseScript(arrayBuffer, dataOffset + name.size);\n        let isObjectEnd = value.objectEnd;\n\n        return {\n            data: {\n                name: name.data,\n                value: value.data\n            },\n            size: value.size,\n            objectEnd: isObjectEnd\n        };\n    }\n\n    static parseVariable(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        return AMF.parseObject(arrayBuffer, dataOffset);\n    }\n    static parseLongString(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let length = v.getUint32(0);\n\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 4, length));\n        } else {\n            str = '';\n        }\n\n        return {\n            data: str,\n            size: 4 + length\n        };\n    }\n    static parseDate(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let timestamp = v.getFloat64(0);\n        let localTimeOffset = v.getInt16(8);\n        timestamp += localTimeOffset * 60 * 1000; // get UTC time\n\n        return {\n            data: new Date(timestamp),\n            size: 8 + 2\n        };\n    }\n    static parseString(arrayBuffer: ArrayBuffer, dataOffset: number) {\n        let v = new DataView(arrayBuffer, dataOffset);\n        let length = v.getUint16(0);\n        let str;\n        if (length > 0) {\n            str = decodeUTF8(new Uint8Array(arrayBuffer, dataOffset + 2, length));\n        } else {\n            str = '';\n        }\n        return {\n            data: str,\n            size: 2 + length\n        };\n    }\n\n    static parseScript(arr: ArrayBuffer, dataOffset: number) {\n        let dataSize = arr.byteLength;\n        let offset = dataOffset;\n        // let uint8 = new Uint8Array(arr);\n        let buffer = arr;\n        let dv = new DataView(buffer, 0);\n\n        let value: any = null;\n        let type = dv.getUint8(offset);\n        offset += 1;\n        let objectEnd = false;\n\n        switch (type) {\n            case 0: // Number(Double) type\n                value = dv.getFloat64(offset);\n                offset += 8;\n                break;\n            case 1: {\n                // Boolean type\n                let b = dv.getUint8(offset);\n                value = !!b;\n                offset += 1;\n                break;\n            }\n            case 2: {\n                // String type\n                let amfstr = AMF.parseString(buffer, offset);\n                value = amfstr.data;\n                offset += amfstr.size;\n                break;\n            }\n            case 3: {\n                // Object(s) type\n                value = {};\n                let terminal = 0; // workaround for malformed Objects which has missing ScriptDataObjectEnd\n                if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                    terminal = 3;\n                }\n                while (offset < dataSize - 4) {\n                    // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n                    let amfobj = AMF.parseObject(buffer, offset);\n\n                    if (amfobj.objectEnd) {\n                        break;\n                    }\n                    value[amfobj.data.name] = amfobj.data.value;\n                    // dataOffset += amfobj.size;\n                    offset = amfobj.size;\n                }\n                if (offset <= dataSize - 3) {\n                    let marker = dv.getUint32(offset - 1) & 0x00ffffff;\n                    if (marker === 9) {\n                        offset += 3;\n                    }\n                }\n                break;\n            }\n            case 8: {\n                // ECMA array type (Mixed array)\n                value = {};\n                // dataOffset += 1;\n                offset += 4; // ECMAArrayLength(UI32)\n                let terminal = 0; // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n                if ((dv.getUint32(dataSize - 4) & 0x00ffffff) === 9) {\n                    terminal = 3;\n                }\n                while (offset < dataSize - 8) {\n                    // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n                    let amfvar = AMF.parseVariable(buffer, offset);\n\n                    if (amfvar.objectEnd) {\n                        break;\n                    }\n                    value[amfvar.data.name] = amfvar.data.value;\n                    offset = amfvar.size;\n                }\n                if (offset <= dataSize - 3) {\n                    let marker = dv.getUint32(offset - 1) & 0x00ffffff;\n                    if (marker === 9) {\n                        offset += 3;\n                    }\n                }\n                break;\n            }\n            case 9: // ScriptDataObjectEnd\n                value = undefined;\n                offset = 1;\n                objectEnd = true;\n                break;\n            case 10: {\n                // Strict array type\n                // ScriptDataValue[n]. NOTE: according to video_file_format_spec_v10_1.pdf\n                value = [];\n                let strictArrayLength = dv.getUint32(offset);\n                offset += 4;\n                for (let i = 0; i < strictArrayLength; i++) {\n                    let val = AMF.parseScript(buffer, offset);\n                    value.push(val.data);\n                    offset = val.size;\n                }\n                break;\n            }\n            case 11: {\n                // Date type\n                let date = AMF.parseDate(buffer, offset + 1);\n                value = date.data;\n                offset += date.size;\n                break;\n            }\n            case 12: {\n                // Long string type\n                let amfLongStr = AMF.parseString(buffer, offset + 1);\n                value = amfLongStr.data;\n                offset += amfLongStr.size;\n                break;\n            }\n            default:\n                // ignore and skip\n                offset = dataSize;\n                Log.v(tag, 'AMF', 'Unsupported AMF value type ' + type);\n        }\n        return {\n            data: value,\n            size: offset,\n            objectEnd\n        };\n    }\n}\n","import { FlvTag, FlvTagType } from './flv';\n\nconst configBody = new Uint8Array([\n    23,\n    0,\n    0,\n    0,\n    0,\n    1,\n    100,\n    0,\n    10,\n    255,\n    225,\n    0,\n    24,\n    103,\n    100,\n    0,\n    10,\n    172,\n    114,\n    4,\n    68,\n    122,\n    16,\n    0,\n    0,\n    3,\n    0,\n    16,\n    0,\n    0,\n    3,\n    3,\n    32,\n    241,\n    34,\n    88,\n    70,\n    1,\n    0,\n    6,\n    104,\n    232,\n    67,\n    143,\n    44,\n    139\n]);\n\nconst frameI = new Uint8Array([\n    23,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    176,\n    6,\n    5,\n    255,\n    255,\n    172,\n    220,\n    69,\n    233,\n    189,\n    230,\n    217,\n    72,\n    183,\n    150,\n    44,\n    216,\n    32,\n    217,\n    35,\n    238,\n    239,\n    120,\n    50,\n    54,\n    52,\n    32,\n    45,\n    32,\n    99,\n    111,\n    114,\n    101,\n    32,\n    49,\n    53,\n    50,\n    32,\n    114,\n    50,\n    56,\n    53,\n    52,\n    32,\n    101,\n    57,\n    97,\n    53,\n    57,\n    48,\n    51,\n    32,\n    45,\n    32,\n    72,\n    46,\n    50,\n    54,\n    52,\n    47,\n    77,\n    80,\n    69,\n    71,\n    45,\n    52,\n    32,\n    65,\n    86,\n    67,\n    32,\n    99,\n    111,\n    100,\n    101,\n    99,\n    32,\n    45,\n    32,\n    67,\n    111,\n    112,\n    121,\n    108,\n    101,\n    102,\n    116,\n    32,\n    50,\n    48,\n    48,\n    51,\n    45,\n    50,\n    48,\n    49,\n    55,\n    32,\n    45,\n    32,\n    104,\n    116,\n    116,\n    112,\n    58,\n    47,\n    47,\n    119,\n    119,\n    119,\n    46,\n    118,\n    105,\n    100,\n    101,\n    111,\n    108,\n    97,\n    110,\n    46,\n    111,\n    114,\n    103,\n    47,\n    120,\n    50,\n    54,\n    52,\n    46,\n    104,\n    116,\n    109,\n    108,\n    32,\n    45,\n    32,\n    111,\n    112,\n    116,\n    105,\n    111,\n    110,\n    115,\n    58,\n    32,\n    99,\n    97,\n    98,\n    97,\n    99,\n    61,\n    49,\n    32,\n    114,\n    101,\n    102,\n    61,\n    49,\n    54,\n    32,\n    100,\n    101,\n    98,\n    108,\n    111,\n    99,\n    107,\n    61,\n    49,\n    58,\n    48,\n    58,\n    48,\n    32,\n    97,\n    110,\n    97,\n    108,\n    121,\n    115,\n    101,\n    61,\n    48,\n    120,\n    51,\n    58,\n    48,\n    120,\n    49,\n    51,\n    51,\n    32,\n    109,\n    101,\n    61,\n    117,\n    109,\n    104,\n    32,\n    115,\n    117,\n    98,\n    109,\n    101,\n    61,\n    49,\n    48,\n    32,\n    112,\n    115,\n    121,\n    61,\n    49,\n    32,\n    112,\n    115,\n    121,\n    95,\n    114,\n    100,\n    61,\n    49,\n    46,\n    48,\n    48,\n    58,\n    48,\n    46,\n    48,\n    48,\n    32,\n    109,\n    105,\n    120,\n    101,\n    100,\n    95,\n    114,\n    101,\n    102,\n    61,\n    49,\n    32,\n    109,\n    101,\n    95,\n    114,\n    97,\n    110,\n    103,\n    101,\n    61,\n    50,\n    52,\n    32,\n    99,\n    104,\n    114,\n    111,\n    109,\n    97,\n    95,\n    109,\n    101,\n    61,\n    49,\n    32,\n    116,\n    114,\n    101,\n    108,\n    108,\n    105,\n    115,\n    61,\n    50,\n    32,\n    56,\n    120,\n    56,\n    100,\n    99,\n    116,\n    61,\n    49,\n    32,\n    99,\n    113,\n    109,\n    61,\n    48,\n    32,\n    100,\n    101,\n    97,\n    100,\n    122,\n    111,\n    110,\n    101,\n    61,\n    50,\n    49,\n    44,\n    49,\n    49,\n    32,\n    102,\n    97,\n    115,\n    116,\n    95,\n    112,\n    115,\n    107,\n    105,\n    112,\n    61,\n    49,\n    32,\n    99,\n    104,\n    114,\n    111,\n    109,\n    97,\n    95,\n    113,\n    112,\n    95,\n    111,\n    102,\n    102,\n    115,\n    101,\n    116,\n    61,\n    45,\n    50,\n    32,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    49,\n    32,\n    108,\n    111,\n    111,\n    107,\n    97,\n    104,\n    101,\n    97,\n    100,\n    95,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    49,\n    32,\n    115,\n    108,\n    105,\n    99,\n    101,\n    100,\n    95,\n    116,\n    104,\n    114,\n    101,\n    97,\n    100,\n    115,\n    61,\n    48,\n    32,\n    110,\n    114,\n    61,\n    48,\n    32,\n    100,\n    101,\n    99,\n    105,\n    109,\n    97,\n    116,\n    101,\n    61,\n    49,\n    32,\n    105,\n    110,\n    116,\n    101,\n    114,\n    108,\n    97,\n    99,\n    101,\n    100,\n    61,\n    48,\n    32,\n    98,\n    108,\n    117,\n    114,\n    97,\n    121,\n    95,\n    99,\n    111,\n    109,\n    112,\n    97,\n    116,\n    61,\n    48,\n    32,\n    99,\n    111,\n    110,\n    115,\n    116,\n    114,\n    97,\n    105,\n    110,\n    101,\n    100,\n    95,\n    105,\n    110,\n    116,\n    114,\n    97,\n    61,\n    48,\n    32,\n    98,\n    102,\n    114,\n    97,\n    109,\n    101,\n    115,\n    61,\n    56,\n    32,\n    98,\n    95,\n    112,\n    121,\n    114,\n    97,\n    109,\n    105,\n    100,\n    61,\n    50,\n    32,\n    98,\n    95,\n    97,\n    100,\n    97,\n    112,\n    116,\n    61,\n    50,\n    32,\n    98,\n    95,\n    98,\n    105,\n    97,\n    115,\n    61,\n    48,\n    32,\n    100,\n    105,\n    114,\n    101,\n    99,\n    116,\n    61,\n    51,\n    32,\n    119,\n    101,\n    105,\n    103,\n    104,\n    116,\n    98,\n    61,\n    49,\n    32,\n    111,\n    112,\n    101,\n    110,\n    95,\n    103,\n    111,\n    112,\n    61,\n    48,\n    32,\n    119,\n    101,\n    105,\n    103,\n    104,\n    116,\n    112,\n    61,\n    50,\n    32,\n    107,\n    101,\n    121,\n    105,\n    110,\n    116,\n    61,\n    50,\n    53,\n    48,\n    32,\n    107,\n    101,\n    121,\n    105,\n    110,\n    116,\n    95,\n    109,\n    105,\n    110,\n    61,\n    50,\n    53,\n    32,\n    115,\n    99,\n    101,\n    110,\n    101,\n    99,\n    117,\n    116,\n    61,\n    52,\n    48,\n    32,\n    105,\n    110,\n    116,\n    114,\n    97,\n    95,\n    114,\n    101,\n    102,\n    114,\n    101,\n    115,\n    104,\n    61,\n    48,\n    32,\n    114,\n    99,\n    95,\n    108,\n    111,\n    111,\n    107,\n    97,\n    104,\n    101,\n    97,\n    100,\n    61,\n    54,\n    48,\n    32,\n    114,\n    99,\n    61,\n    99,\n    114,\n    102,\n    32,\n    109,\n    98,\n    116,\n    114,\n    101,\n    101,\n    61,\n    49,\n    32,\n    99,\n    114,\n    102,\n    61,\n    50,\n    51,\n    46,\n    48,\n    32,\n    113,\n    99,\n    111,\n    109,\n    112,\n    61,\n    48,\n    46,\n    54,\n    48,\n    32,\n    113,\n    112,\n    109,\n    105,\n    110,\n    61,\n    48,\n    32,\n    113,\n    112,\n    109,\n    97,\n    120,\n    61,\n    54,\n    57,\n    32,\n    113,\n    112,\n    115,\n    116,\n    101,\n    112,\n    61,\n    52,\n    32,\n    105,\n    112,\n    95,\n    114,\n    97,\n    116,\n    105,\n    111,\n    61,\n    49,\n    46,\n    52,\n    48,\n    32,\n    97,\n    113,\n    61,\n    49,\n    58,\n    49,\n    46,\n    48,\n    48,\n    0,\n    128,\n    0,\n    0,\n    0,\n    29,\n    101,\n    136,\n    129,\n    0,\n    5,\n    127,\n    254,\n    246,\n    115,\n    124,\n    10,\n    107,\n    109,\n    176,\n    149,\n    46,\n    5,\n    118,\n    246,\n    150,\n    55,\n    45,\n    60,\n    239,\n    89,\n    160,\n    124,\n    49,\n    129\n]);\n\nclass AVC {\n    static getFlvVideoTag(timestamp: number, config: boolean = false): FlvTag {\n        const tag = new FlvTag();\n        tag.tagType = FlvTagType.VIDEO;\n        if (config) {\n            tag.body = configBody;\n        } else {\n            tag.body = frameI;\n        }\n        tag.dataSize = tag.body.byteLength;\n        tag.timestamp = Math.round(timestamp);\n        tag.frameType = 1;\n        tag.codecId = 7;\n        tag.fill = true;\n        return tag;\n    }\n}\n\nexport default AVC;\n","import { ErrorDetails, ErrorTypes } from '../../core/errors';\nimport LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport { FLVTransConfig } from '../../types/core';\nimport { ATrack, IRemuxer, TrackType, VTrack } from '../../types/remux';\nimport { Log } from '../../utils/log';\nimport * as ASC from '../asc';\nimport SPSParser from '../sps-parser';\nimport AMF from './amf';\nimport AVC from './avc-helper';\nimport { FlvTag, FlvTagType } from './flv';\n\n\n// Non-monotonousremux\nconst DISCONTINUITY_ON_NON_MONOTONOUS = 10;\n\ntype TagCache = {\n    tag: FlvTag,\n    dataOffset: number\n}\n\nclass FlvDemux {\n    private tag = 'FlvDemux';\n    private _observer: Observer;\n    private _remuxer: IRemuxer;\n    private _config: FLVTransConfig;\n    private _duration: number;\n    private _naluLengthSize: number;\n    private _hasVideo: boolean;\n    private _hasAudio: boolean;\n    private _videoTrack: VTrack;\n    private _audioTrack: ATrack;\n    private _remuxStat?: { timeOffset: number; contiguous: boolean; accurateTimeOffset: boolean };\n    private _currentTimestamp: number = 0;\n    private _aLastDTS: number = 0;\n    private _vLastDTS: number = 0;\n    private _nonMonotonousCache?: Record<string, TagCache[]>;\n    private _fillAtStart = {\n        enabled: true,\n        start: 0,\n        avcConfig: true\n    };\n\n    constructor(observer: Observer, remuxer: IRemuxer, config: FLVTransConfig) {\n        this._observer = observer;\n        this._remuxer = remuxer;\n        this._config = config;\n\n        this._duration = 0;\n        this._naluLengthSize = 4;\n\n        this._hasVideo = true;\n        this._hasAudio = true;\n\n        this._videoTrack = {\n            id: 1,\n            type: TrackType.video,\n            container: '',\n            codec: '',\n            timescale: 90000,\n            duration: Infinity,\n            samples: [],\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            pid: -1,\n            width: 0,\n            height: 0,\n            codecWidth: 0,\n            codecHeight: 0,\n            sps: [],\n            pps: [],\n            pixelRatio: [],\n            profile: '',\n            level: '',\n            chromaFormat: '',\n            fps: 0,\n            dropped: 0,\n            refSampleDuration: 0,\n        };\n        this._audioTrack = {\n            id: 2,\n            type: TrackType.audio,\n            container: '',\n            codec: '',\n            timescale: 90000,\n            duration: Infinity,\n            samples: [],\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            pid: -1,\n            isAAC: true,\n            samplerate: 0,\n            channelCount: 0,\n            config: []\n        };\n    }\n\n    public append(tags: FlvTag[], timeOffset: number, contiguous: boolean, accurateTimeOffset: boolean): void {\n        if (!this._remuxStat) {\n            this._remuxStat = { timeOffset, contiguous, accurateTimeOffset };\n        }\n        if (!tags.length) return;\n        tags.forEach(tag => {\n            if (tag.tagType === FlvTagType.VIDEO && this._hasVideo) {\n                if (this._fillAtStart.enabled) {\n                    // tag\n                    this._fillAtStart.enabled = false;\n                    if (this._audioTrack.samples.length) {\n                        this._fillFrame(this._audioTrack.samples[this._audioTrack.samples.length - 1].dts / 90);\n                    }\n                }\n                this._parseVideoData(tag);\n            }\n            if (tag.tagType === FlvTagType.AUDIO && this._hasAudio) {\n                this._parseAudioData(tag);\n            }\n            if (tag.tagType === FlvTagType.SCRIPT) {\n                this._parseScriptTag(tag);\n            }\n        });\n\n        if (this._fillAtStart.enabled && this._audioTrack.samples.length) {\n            // \n            let st = this._audioTrack.samples[0].dts / 90;\n            let ed = this._audioTrack.samples[this._audioTrack.samples.length - 1].dts / 90;\n            if (this._fillAtStart.start <= 0) {\n                this._fillAtStart.start = st;\n            }\n            if (ed > this._fillAtStart.start) {\n                this._fillFrame(ed);\n            }\n        }\n        this._remux();\n    }\n\n    public flvHead(hasAudio: boolean, hasVideo: boolean): void {\n        this._hasAudio = hasAudio;\n        this._hasVideo = hasVideo;\n        this._fillAtStart.enabled = this._hasVideo;\n    }\n\n    public destroy() { }\n\n    public flush() {\n        this._remux(true);\n        this._remuxStat = undefined;\n    }\n\n    public resetInitSegment() {\n        this._videoTrack.samples = [];\n        this._audioTrack.samples = [];\n        this._aLastDTS = this._vLastDTS = 0;\n        this._remuxStat = undefined;\n    }\n\n    public resetTimeStamp() { }\n\n    // \n    public set duration(sec: number) {\n        this._duration = sec;\n    }\n\n    private _parseScriptTag(tag: FlvTag) {\n        if (tag.body) {\n            const scriptData = AMF.parseMetadata(tag.body.buffer);\n            scriptData.timestamp = this._currentTimestamp || 0;\n            if (scriptData.hasOwnProperty('onMetaData')) {\n                const onMetaData = scriptData.onMetaData;\n                if (typeof onMetaData.framerate === 'number') {\n                    this._videoTrack.fps = this._videoTrack.fps || onMetaData.framerate;\n                }\n                Log.i(this.tag, 'Parsed onMetaData');\n            }\n            this._observer.trigger(LasEvents.SCRIPT_PARSED, scriptData);\n        }\n    }\n\n    private _parseVideoData(tag: FlvTag) {\n        if (!tag.body) {\n            return;\n        }\n        //  video tag body \n        const spec = tag.body[0];\n        // \n        tag.frameType = (spec & 240) >>> 4;\n        // \n        const codecId = spec & 15;\n        if (codecId !== 7 && codecId !== 12) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Unsupported codec in video frame: ${codecId}`\n            });\n            return;\n        }\n        tag.codecId = codecId;\n        // IF CodecID == 7  AVCPacketType\n        // 0 = AVC sequence header\n        // 1 = AVC NALU\n        // 2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)\n        const packetType = tag.body[1];\n        // 3\n        // IF AVCPacketType == 1\n        //  Composition time offset\n        // ELSE\n        //  0\n        tag.cts = ((tag.body[2] & 0xff) << 16) + ((tag.body[3] & 0xff) << 8) + (tag.body[4] & 0xff);\n\n        // IF AVCPacketType == 0 AVCDecoderConfigurationRecordAVC sequence header\n        // IF AVCPacketType == 1 One or more NALUs (Full frames are required)\n        if (packetType === 0) {\n            if (codecId === 7) {\n                this._parseAVCDecoderConfigurationRecord(tag, 5);\n            }\n        } else if (packetType === 1) {\n            this._parseAVCVideoData(tag, 5) || {};\n        } else if (packetType === 2) {\n            // empty, AVC end of sequence\n        } else {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid video packet type ${packetType}`\n            });\n            return;\n        }\n    }\n\n    /**\n     * AVC \n     * @param {FlvTag} tag flvtag\n     * @param {number} dataOffset tag body offset\n     */\n    private _parseAVCDecoderConfigurationRecord(tag: FlvTag, dataOffset: number) {\n        if (!tag.body) {\n            return;\n        }\n        const track = this._videoTrack;\n        const arrayBuffer = tag.body.buffer;\n        const dataSize = tag.body.byteLength - dataOffset;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        const version = v.getUint8(0); // configurationVersion\n        const avcProfile = v.getUint8(1); // avcProfileIndication\n        // const profileCompatibility = v.getUint8(2); // profile_compatibility\n        // const avcLevel = v.getUint8(3); // AVCLevelIndication\n        if (version !== 1 || avcProfile === 0) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: 'Flv: Invalid AVCDecoderConfigurationRecord'\n            });\n            return;\n        }\n\n        this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n        if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Strange NaluLengthSizeMinusOne: ${this._naluLengthSize - 1}`\n            });\n            return;\n        }\n\n        const spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n        if (spsCount === 0 || spsCount > 1) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid H264 SPS count: ${spsCount}`\n            });\n            return;\n        }\n\n        let offset = 6;\n        let spsList = [];\n        for (let i = 0; i < spsCount; i++) {\n            const len = v.getUint16(offset); // sequenceParameterSetLength\n            offset += 2;\n\n            if (len === 0) {\n                continue;\n            }\n\n            // Notice: Nalu without startcode header (00 00 00 01)\n            const sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            offset += len;\n            spsList.push(sps);\n            const config = SPSParser.parseSPS(sps);\n            const codecArray = sps.subarray(1, 4);\n            let codecString = 'avc1.';\n            for (let j = 0; j < 3; j++) {\n                let h = codecArray[j].toString(16);\n                if (h.length < 2) {\n                    h = '0' + h;\n                }\n                codecString += h;\n            }\n\n            // sps update\n            if (\n                !!track.codec &&\n                (track.width !== config.codec_size.width ||\n                    track.height !== config.codec_size.height ||\n                    codecString !== track.codec)\n            ) {\n                if (!tag.fill) {\n                    this._remux(true);\n                }\n                if (this._remuxer.ISGenerated) {\n                    this._remuxer.resetInitSegment();\n                }\n            }\n            track.sps = spsList;\n            track.width = config.codec_size.width;\n            track.height = config.codec_size.height;\n            track.pixelRatio = [config.sar_ratio.width, config.sar_ratio.height];\n            if (config.frame_rate.fixed && config.frame_rate.fps !== 0) {\n                track.fps = config.frame_rate.fps;\n            }\n            track.codec = codecString;\n\n            track.profile = config.profile_string;\n            track.level = config.level_string;\n            track.chromaFormat = config.chroma_format_string;\n        }\n\n        const ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n        if (ppsCount === 0 || ppsCount > 1) {\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.PARSING_ERROR,\n                fatal: true,\n                reason: `Flv: Invalid H264 PPS count: ${ppsCount}`\n            });\n            return;\n        }\n\n        offset++;\n        track.pps = [];\n        for (let i = 0; i < ppsCount; i++) {\n            const len = v.getUint16(offset); // pictureParameterSetLength\n            offset += 2;\n            const pps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n            track.pps.push(pps);\n            if (len === 0) {\n                continue;\n            }\n            offset += len;\n        }\n        Log.v(this.tag, 'Parsed AVCDecoderConfigurationRecord');\n\n        track.duration = this._duration;\n        track.container = 'video/mp4';\n        if (track.fps) {\n            track.refSampleDuration = Math.floor(track.timescale / track.fps);\n        } else {\n            // fpsfpsmp4sample durationgopremux\n            // this._config.gopRemux = true;\n            track.refSampleDuration = Math.floor(track.timescale / 30);\n        }\n    }\n\n    /**\n     * AVC \n     * @param {Flvtag} tag flv tag\n     * @param {number} dataOffset dataOffset\n     */\n    private _parseAVCVideoData(tag: FlvTag, dataOffset: number, ignoreNonMonotonous: boolean = false) {\n        if (!tag.body) {\n            return;\n        }\n        let info;\n        const arrayBuffer = tag.body.buffer;\n        const dataSize = tag.body.byteLength - dataOffset;\n        const v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n        const units = [];\n        let length = 0;\n\n        let offset = 0;\n        const lengthSize = this._naluLengthSize;\n        const dts = tag.timestamp;\n        let keyframe = tag.frameType === 1; // from FLV Frame Type constants\n        // Non-monotonous DTS\n        if (!ignoreNonMonotonous && dts <= this._vLastDTS && this._vLastDTS > 0) {\n            Log.w(this.tag, `debug Non-monotonous DTS dts:${dts} last:${this._vLastDTS}`);\n            this._onNonMonotonous({ tag, dataOffset }, TrackType.video);\n            return;\n        }\n        if (!ignoreNonMonotonous && this._nonMonotonousCache) {\n            this._flushNonMonotonousCache();\n        }\n        const pts = dts + tag.cts;\n        while (offset < dataSize) {\n            if (offset + 4 >= dataSize) {\n                Log.v(this.tag, `Malformed Nalu near timestamp ${dts}, offset = ${offset}, dataSize = ${dataSize}`);\n                break; // data not enough for next Nalu\n            }\n            // Nalu with length-header (AVC1)\n            let naluSize = v.getUint32(offset); // Big-Endian read\n            if (lengthSize === 3) {\n                naluSize >>>= 8;\n            }\n            if (naluSize > dataSize - lengthSize) {\n                Log.v(this.tag, `Malformed Nalus near timestamp ${dts}, NaluSize > DataSize!`);\n                return;\n            }\n            const data = new Uint8Array(arrayBuffer, dataOffset + offset + 4, lengthSize + naluSize - 4);\n            let unitType;\n            if (tag.codecId === 7) {\n                // AVC\n                unitType = v.getUint8(offset + lengthSize) & 0x1f;\n                if (unitType === 5) {\n                    keyframe = true;\n                }\n            }\n\n            const unit = { type: unitType, data };\n            units.push(unit);\n            length += data.byteLength;\n            offset += lengthSize + naluSize;\n        }\n\n        if (units.length) {\n            const track = this._videoTrack;\n            const avcSample = {\n                units,\n                length,\n                dts: dts * 90,\n                cts: tag.cts * 90,\n                pts: pts * 90,\n                streamDTS: dts,\n                key: keyframe\n            };\n            track.samples.push(avcSample);\n        }\n        this._vLastDTS = dts;\n        return info;\n    }\n\n    private _parseAudioData(tag: FlvTag, ignoreNonMonotonous: boolean = false) {\n        if (!tag.body) {\n            return;\n        }\n        const dataSize = tag.body.byteLength;\n        let aacFrameLen;\n        if (dataSize <= 1) {\n            Log.v(this.tag, 'Flv: Invalid audio packet, missing SoundData payload!');\n            return;\n        }\n        const track = this._audioTrack;\n\n        const packetType = tag.body[1];\n\n        if (packetType === 0) {\n            if (tag.body.byteLength < 4) {\n                return;\n            }\n            ASC.initTrackConfig(track, this._observer, tag.body, 0, this._config.audioCodec);\n            track.duration = this._duration;\n\n            return;\n        } else if (packetType === 1) {\n            const aacData = tag.body.subarray(2);\n            // AAC raw frame data\n            let dts = tag.timestamp;\n            // dtsdts\n            // aac\n            aacFrameLen = ASC.getFrameDuration(track.samplerate);\n            let maxAudioFramesDrift = aacFrameLen * this._config.maxAudioFramesDrift;\n            if (this._aLastDTS > 0) {\n                // \n                dts = this._aLastDTS + aacFrameLen;\n                const dtsDiff = tag.timestamp - dts;\n                if (!ignoreNonMonotonous && dtsDiff < -maxAudioFramesDrift) {\n                    this._onNonMonotonous({ tag }, TrackType.audio);\n                    return;\n                }\n            }\n            if (!ignoreNonMonotonous && this._nonMonotonousCache) {\n                this._flushNonMonotonousCache();\n            }\n\n            const sampleDts = (dts * track.inputTimeScale) / 1000;\n            const aacSample = {\n                unit: aacData,\n                dts: sampleDts,\n                pts: sampleDts,\n                streamDTS: tag.timestamp,\n                length: aacData.byteLength\n            };\n            this._aLastDTS = dts;\n            track.samples.push(aacSample);\n        } else {\n            Log.v(this.tag, `Flv: Unsupported AAC data type ${packetType}`);\n        }\n    }\n\n    /**\n     * Non-monotonousNon-monotonous\n     * @param {object} data tag\n     * @param {string} type audio|video\n     */\n    private _onNonMonotonous(data: any, type: TrackType) {\n        if (!this._nonMonotonousCache) {\n            this._nonMonotonousCache = {\n                video: [],\n                audio: []\n            };\n        }\n        const cache = this._nonMonotonousCache[type];\n        if (cache.length > DISCONTINUITY_ON_NON_MONOTONOUS) {\n            this.flush();\n            const lastPts = this._remuxer.getLastPTS();\n            let ptsSync: number = lastPts.audio;\n            if (ptsSync === 0 || (lastPts.video > 0 && lastPts.video < ptsSync)) {\n                ptsSync = lastPts.video;\n            }\n            this._videoTrack.samples = [];\n            this._audioTrack.samples = [];\n            this._aLastDTS = this._vLastDTS = 0;\n            this._remuxStat = { accurateTimeOffset: false, contiguous: false, timeOffset: ptsSync };\n            this._remuxer.resetInitSegment();\n            this._remuxer.resetTimeStamp();\n            Log.i(this.tag, 'NON_MONOTONOUS reset time');\n            this._flushNonMonotonousCache();\n        } else {\n            cache.push(data);\n        }\n    }\n\n    /**\n     * Non-monotonousremux\n     */\n    private _flushNonMonotonousCache() {\n        if (this._nonMonotonousCache) {\n            const nonMonotonousCache = this._nonMonotonousCache;\n            for (const key in nonMonotonousCache) {\n                const cache = nonMonotonousCache[key];\n                while (cache.length) {\n                    const data = cache.shift();\n                    if (data) {\n                        if (key === 'video') {\n                            this._parseAVCVideoData(data.tag, data.dataOffset, true);\n                        } else if (key === 'audio') {\n                            this._parseAudioData(data.tag, true);\n                        }\n                    }\n                }\n            }\n            this._nonMonotonousCache = undefined;\n        }\n    }\n\n    private _remux(end = false) {\n        const audiotrack = this._audioTrack;\n        const videotrack = this._videoTrack;\n        let contiguous = true,\n            timeOffset = 0,\n            accurateTimeOffset = false;\n        if (this._remuxStat) {\n            contiguous = this._remuxStat.contiguous;\n            timeOffset = this._remuxStat.timeOffset;\n            accurateTimeOffset = this._remuxStat.accurateTimeOffset;\n        }\n\n        if (audiotrack.samples.length === 0 && videotrack.samples.length === 0) {\n            if (end) {\n                this._remuxer.flush();\n            }\n            return;\n        }\n\n        if (!end && (this._hasAudio && audiotrack.samples.length === 0 || this._hasVideo && videotrack.samples.length < 2)) {\n            return;\n        }\n        try {\n            this._remuxer.remux(audiotrack, videotrack, timeOffset, contiguous, accurateTimeOffset, end);\n            this._remuxStat = undefined;\n        } catch (error) {\n            Log.e(this.tag, error);\n            this._observer.trigger(LasEvents.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ERROR,\n                fatal: true,\n                reason: error.message\n            });\n        }\n    }\n\n    /**\n     * \n     * @param ed  ms\n     */\n    private _fillFrame(ed: number) {\n        if (this._audioTrack.samples.length === 0) {\n            return;\n        }\n        let st = this._fillAtStart.start || this._audioTrack.samples[0].dts * 90;\n        if (ed > st) {\n            Log.i(this.tag, `fill video frame: ${st} ${ed}`);\n            this._fillAtStart.start = ed;\n            let tags: FlvTag[] = [AVC.getFlvVideoTag(st), AVC.getFlvVideoTag(ed - 1)];\n            if (this._fillAtStart.avcConfig) {\n                tags.unshift(AVC.getFlvVideoTag(st, true));\n                this._fillAtStart.avcConfig = false;\n            }\n            tags.forEach(tag => {\n                this._parseVideoData(tag);\n            });\n        }\n    }\n}\n\nexport default FlvDemux;\n","import LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport Mp4Remuxer from '../../remux/mp4-remuxer';\nimport { FLVTransConfig } from '../../types/core';\nimport FlvDemuxer from './flv-demuxer';\nimport { FlvTag } from './flv';\n\nexport interface FlvExtraData {\n    remuxId: number;\n    bitrate?: number;\n}\nclass FlvDemuxerInline {\n    private tag: string = 'Flv';\n    private _observer: Observer;\n    private _config: FLVTransConfig;\n    private _extraData: FlvExtraData;\n\n    private _demuxer!: FlvDemuxer;\n    private _remuxer!: Mp4Remuxer;\n\n    private _bitrate: number;\n    private _vendor: string;\n\n    constructor(observer: Observer, config: FLVTransConfig, extraData: FlvExtraData, vendor: string) {\n        this._observer = observer;\n        this._config = config;\n\n        this._bitrate = this._config.bitrate as number;\n        this._extraData = extraData;\n        this._vendor = vendor;\n    }\n\n    public init(): void {\n        const config = this._config,\n            observer = this._observer;\n\n        const remuxer = (this._remuxer = new Mp4Remuxer(observer, config, { mp4: true, mpeg: false, mp3: false }));\n        const demuxer = (this._demuxer = new FlvDemuxer(observer, remuxer, config));\n        remuxer.setExtra(this._extraData);\n        demuxer.duration = config.duration || 0;\n    }\n\n    public flvHead(hasAudio: boolean, hasVideo: boolean): void {\n        this._demuxer.flvHead(hasAudio, hasVideo);\n    }\n\n    public append(tags: FlvTag[], timeOffset: number, discontinuity: boolean, contiguous: boolean, accurateTimeOffset: boolean) {\n        if (discontinuity) {\n            this._demuxer.resetInitSegment();\n            this._remuxer.resetInitSegment();\n            this._demuxer.resetTimeStamp();\n            this._remuxer.resetTimeStamp();\n        }\n        this._demuxer.append(tags, timeOffset, contiguous, accurateTimeOffset);\n    }\n\n    public end(): void {\n        this._demuxer.flush();\n        this._remuxer.flush();\n        this._observer.trigger(LasEvents.LOAD_END);\n    }\n\n    public flush(): void {\n        if (this._demuxer) {\n            this._demuxer.flush();\n        }\n    }\n\n    public setExtra(data: FlvExtraData): void {\n        this._extraData = data;\n        this._extraData.bitrate = this._bitrate;\n        if (this._remuxer) {\n            this._remuxer.setExtra(this._extraData);\n        }\n    }\n\n    public destroy(): void { }\n\n}\n\nexport default FlvDemuxerInline;\n","function webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_modules__\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i\n  , whitespace = '[\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x20\\\\xA0\\\\u1680\\\\u180E\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\u2028\\\\u2029\\\\uFEFF]'\n  , left = new RegExp('^'+ whitespace +'+');\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(left, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address) {          // Sanitize what is left of the address\n    return address.replace('\\\\', '/');\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address) {\n  address = trimLeft(address);\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encodeURIComponent(key);\n      value = encodeURIComponent(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n","import Observer from '../../core/observer';\nimport LasEvents from '../../core/events';\nimport FlvDemuxerInline, { FlvExtraData } from './flv-demuxer-inline';\nimport { Log } from '../../utils/log';\nimport { FLVTransConfig } from '../../types/core';\n\nexport default function (self: any) {\n    let flv: FlvDemuxerInline;\n\n    const observer = new Observer();\n    const forwardMessage = function (ev: string, data: any) {\n        self.postMessage({ event: ev, data: data });\n    };\n\n    observer.on(LasEvents.PARSING_INIT_SEGMENT, forwardMessage);\n    observer.on(LasEvents.ERROR, forwardMessage);\n    observer.on(LasEvents.SCRIPT_PARSED, forwardMessage);\n    observer.on(LasEvents.LOAD_END, forwardMessage);\n    observer.on(LasEvents.PARSING_DATA, function (ev, data) {\n        const message: any = { event: ev, data: data };\n        message.payload = data.payload;\n        delete data.payload;\n        self.postMessage(message, [message.payload.buffer]);\n    });\n\n    function init(observer: Observer, config: FLVTransConfig, data: FlvExtraData, vendor: string) {\n        flv = new FlvDemuxerInline(observer, config, data, vendor);\n        flv.init();\n    }\n\n    function destroy() {\n        if (flv) {\n            flv.destroy();\n        }\n        if (observer) {\n            observer.removeAllListeners();\n        }\n    }\n\n    self.addEventListener('message', function (e: any) {\n        const d = e.data;\n        switch (d.cmd) {\n            case 'init':\n                Log.level(d.config.debug);\n                init(observer, d.config, d.data, d.vendor);\n                break;\n            case 'destroy':\n                destroy();\n                break;\n            case 'append':\n                flv.append(d.tags, d.timeOffset, d.discontinuity, d.contiguous, d.accurateTimeOffset);\n                break;\n            case 'flvHead':\n                flv.flvHead(d.hasAudio, d.hasVideo);\n                break;\n            case 'flush':\n                flv.flush();\n                break;\n            case 'setExtra':\n                flv.setExtra(d.data);\n                break;\n            case 'end':\n                flv.end();\n                break;\n        }\n    });\n}\n","import { LasConfig } from './types/core';\nimport Browser from './utils/browser';\nimport { Log, LOG_LEVEL } from './utils/log';\n\nconst CLEANUP_DURATION_STEP = 10;\n\nconst URL_REG = new RegExp('^(http|https)://');\n\nconst DEFAULT_CONFIG = {\n    webWorker: true, // webworker\n    autoCleanupMaxBackwardDuration: 60, // sourcebuffer\n    autoCleanupMinBackwardDuration: 15, // sourcebuffer\n    appendErrorMaxRetry: 3, // mse append\n    credentials: false, // cookie\n    defaultSpts: -2000,\n    debug: LOG_LEVEL.LEVEL_ERROR,\n\n    connectionTimeout: 10000, // \n    transmissionTimeout: 30000, // \n    stretchShortVideoTrack: false,\n    maxBufferHole: 0.5,\n    maxAudioFramesDrift: 5, // used by mp4-remuxer\n};\n\nclass ConfigHelper {\n    /**\n     * config\n     * @param {object} userConfig config\n     * @returns {object} config\n     */\n    static processConfig(userConfig: any): LasConfig {\n        const config: LasConfig = Object.assign({}, DEFAULT_CONFIG);\n        Object.assign(config, userConfig);\n        ConfigHelper.setSrc(config);\n\n        if (!(window as any).Worker) {\n            config.webWorker = false;\n        }\n        if (config.debug) {\n            Log.level(config.debug);\n        }\n        ConfigHelper.detectStreamingMux(config);\n        config.autoCleanupMaxBackwardDuration = Math.max(\n            config.autoCleanupMaxBackwardDuration,\n            config.autoCleanupMinBackwardDuration + CLEANUP_DURATION_STEP\n        );\n        return config;\n    }\n\n    static detectStreamingMux(config: LasConfig) {\n        config.gopRemux = Browser.safari || (Browser.opera && Browser.version.major < 37);\n    }\n\n    /**\n     * configsrc\n     * @param {object} config config\n     * @param {*} src srcmanifest\n     */\n    static setSrc(config: LasConfig, src: any = null) {\n        if (src) {\n            config.src = src;\n            config.manifest = '';\n        }\n        if (typeof config.src === 'string' && !URL_REG.test(config.src)) {\n            try {\n                config.src = JSON.parse(config.src);\n            } catch (e) {\n                config.manifest = '';\n            }\n        }\n        if (typeof config.src === 'object') {\n            config.manifest = config.src;\n            config.src = '';\n        }\n    }\n}\n\nexport { DEFAULT_CONFIG, ConfigHelper };\n\n","import { TimeRange } from '../types/core';\nimport MSEController from './mse-controller';\n\nclass Media {\n    private _video?: HTMLVideoElement;\n    private _mse?: MSEController;\n\n    private _streamTime: number = 0;\n    private _localTime: number = 0;\n\n    constructor() { }\n\n    public reset(): void {\n        this._streamTime = 0;\n        this._localTime = 0;\n    }\n\n    public attachVideo(video: HTMLVideoElement): void {\n        this._video = video;\n    }\n    public attachMSE(mse: MSEController): void {\n        this._mse = mse;\n    }\n\n    /**\n     * video\n     * @param sec time\n     * @returns isTimeinBuffered\n     */\n    public isTimeinBuffered(sec: number): boolean {\n        if (this._video) {\n            const buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                if (sec >= buffered.start(i) && sec < buffered.end(i)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /*\n     * video buffer\n     */\n    public bufferedSec(): number {\n        if (this._video && this._video.buffered.length > 0) {\n            return Math.max(0, this._video.buffered.end(this._video.buffered.length - 1) - this._video.currentTime);\n        }\n        return 0;\n    }\n\n    /**\n     * buffer\n     * @param type video|audio\n     */\n    public bufferedSecByType(type: string): number {\n        if (this._mse && this._video) {\n            let end = this._mse.bufferedEndByType(type);\n            if (end > 0) {\n                return this._mse.bufferedEndByType(type) - this._video.currentTime;\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * buffer\n     * @param type video|audio\n     */\n    public mseBufferedSecByType(type: string): TimeRange {\n        if (this._mse) {\n            return this._mse.bufferedByType(type);\n        }\n        return { start: 0, end: 0 };\n    }\n\n    /**\n     * buffer\n     * @param type video|audio\n     */\n    public bufferSliceNumByType(type: string): number {\n        if (this._mse) {\n            return this._mse.bufferSliceNumByType(type);\n        }\n        return 0;\n    }\n\n    public pendingNum(): number {\n        if (this._mse) {\n            return this._mse.pendingNum();\n        }\n        return 0;\n    }\n\n    /**\n     * buffer\n     * @param type video|audio\n     */\n    public pendingSecByType(type: string): number {\n        if (this._mse) {\n            return this._mse.pendingSecByType(type);\n        }\n        return 0;\n    }\n\n    /**\n     * bufferbuffer\n     * @param time \n     */\n    public currentBuffer(time: number): TimeRange | undefined {\n        if (this._video) {\n            let buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                if (start <= time && time < end) {\n                    return { start, end };\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * bufferbuffer\n     * @param time \n     */\n    public nextBuffer(time: number): TimeRange | undefined {\n        if (this._video) {\n            let buffered = this._video.buffered;\n            for (let i = 0; i < buffered.length; i++) {\n                const start = buffered.start(i);\n                const end = buffered.end(i);\n                if (start > time) {\n                    return { start, end };\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * \n     * @param streamTime \n     * @param localTime \n     */\n    public updateStreamTime(streamTime: number, localTime: number): void {\n        this._streamTime = streamTime;\n        this._localTime = localTime;\n    }\n\n    /**\n     * \n     * @param streamTime \n     */\n    public getLocalTime(streamTime: number): number | undefined {\n        if (this._streamTime) {\n            return (streamTime - this._streamTime) + this._localTime;\n        }\n        return;\n    }\n\n    public get video(): HTMLVideoElement | undefined {\n        return this._video;\n    }\n\n    public get mse(): MSEController | undefined {\n        return this._mse;\n    }\n\n    /**\n     * MSEmse.readyState\n     */\n    public get mseReadyState(): ReadyState {\n        if (this._mse) {\n            return this._mse.readyState;\n        }\n        return 'closed';\n    }\n\n    /**\n     * MSEmse.readyState\n     */\n    public get videoReadyState(): number {\n        if (this._video) {\n            return this._video.readyState;\n        }\n        return 0;\n    }\n\n\n    /**\n     * video\n     */\n    public get currentTime(): number {\n        if (this._video) {\n            return this._video.currentTime;\n        }\n        return 0;\n    }\n}\n\nexport default Media;\n","/**\n * MediaSource helper\n */\n\nexport function getMediaSource (): typeof MediaSource {\n  return (window as any).MediaSource || (window as any).WebKitMediaSource;\n}\n","import { EventEmitter } from 'events';\nimport { LasConfig, TimeRange } from '../types/core';\nimport Browser from '../utils/browser';\nimport { Log } from '../utils/log';\nimport { getMediaSource } from '../utils/mediasource-helper';\nimport { ErrorDetails, ErrorTypes } from './errors';\nimport LasEvents from './events';\n\n// appendqueue\nconst QUEUE_SIZE_LIMIT = 200 * 1024 * 1024;\nconst MIN_CLEANUP_DURATION = 10;\nconst CLEANUP_DURATION_STEP = 10;\n\nconst MAX_BUFFERED = 30;\n\ntype Segment = {\n    type: string;\n    data: Uint8Array;\n    startDTS: number;\n    endDTS: number;\n    duration: number;\n};\n\nexport default class MSEController extends EventEmitter {\n    private tag: string = 'mse-controller';\n    private _config: LasConfig;\n\n    public video?: HTMLVideoElement;\n    public _sourceBuffer: { [index: string]: SourceBuffer };\n    private _mediaSource: MediaSource | null = null;\n    private _mimeCodec: { [index: string]: string };\n    private _cleanUpTask: { [index: string]: TimeRange[] };\n    private _appendQueue: { [index: string]: any[] };\n    private _hasVideo: boolean;\n    private _hasAudio: boolean;\n    private _endOfData: boolean = false;\n    private _appendEnabled: boolean;\n    private _duration: number | null = null;\n    private _appendError: number = 0;\n    private _appendBufferError: boolean = false;\n    private _sbHandler: { [index: string]: { updateend: (e: Event) => any; error: (e: Event) => any } } = {};\n    private _souceBufferLocked: boolean = false;\n\n    /**\n     * Mediasource \n     * @class Mediasource\n     * @param {Element} videoElement videoElement\n     * @param {object} config config\n     */\n    constructor(config: LasConfig) {\n        super();\n        this._config = config;\n        this._hasVideo = false;\n        this._hasAudio = false;\n        this._appendQueue = {\n            video: [],\n            audio: [],\n            audiovideo: []\n        };\n        this._sourceBuffer = {};\n        this._cleanUpTask = { video: [], audio: [], audiovideo: [] };\n        this._mimeCodec = {};\n        this._appendEnabled = true;\n    }\n\n    /**\n     * HTMLvideo\n     * @param video video\n     */\n    public attach(video: HTMLVideoElement): void {\n        this.video = video;\n        const MediaSourceDef = getMediaSource();\n        if (MediaSourceDef) {\n            const ms = (this._mediaSource = new MediaSourceDef());\n            this.video.src = URL.createObjectURL(ms);\n            this.video.load();\n            ms.addEventListener('sourceopen', this._onSourceOpen);\n            ms.addEventListener('sourceended', this._onSourceEnded);\n            ms.addEventListener('sourceclose', this._onSourceClose);\n            this._souceBufferLocked = false;\n        } else {\n            setTimeout(() => {\n                this.emit(LasEvents.ERROR, {\n                    type: ErrorTypes.MSE_ERROR,\n                    details: ErrorDetails.MEDIASOURCE_ERROR,\n                    fatal: true,\n                    reason: 'MediaSource is not support'\n                });\n            }, 0);\n        }\n    }\n\n    /**\n     * mediaSource init\n     * @param {Object} mediaInfo mediaInfo\n     */\n    public trackInfo(mediaInfo: any): void {\n        if ((this._hasAudio !== mediaInfo.hasAudio || this._hasVideo !== mediaInfo.hasVideo || !!mediaInfo.audiovideo !== !!this._mimeCodec.audiovideo) && this.video && this.hasSourceBuffer()) {\n            // mse\n            Log.i(this.tag, 'trackInfo rebuild mse');\n            for (const type in this._sourceBuffer) {\n                if (this._sourceBuffer[type] && this._sbHandler[type]) {\n                    this._sourceBuffer[type].removeEventListener('error', this._sbHandler[type].error);\n                    this._sourceBuffer[type].removeEventListener('updateend', this._sbHandler[type].updateend);\n                }\n            }\n            this._sourceBuffer = {};\n            if (this._mediaSource) {\n                this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n                this._mediaSource.removeEventListener('sourceended', this._onSourceEnded);\n                this._mediaSource.removeEventListener('sourceclose', this._onSourceClose);\n            }\n            this._mimeCodec = {};\n            this.attach(this.video);\n        }\n        if (!mediaInfo.audiovideo) {\n            if (mediaInfo.hasAudio && mediaInfo.audioCodec) {\n                this._mimeCodec.audio = `audio/mp4; codecs=\"${mediaInfo.audioCodec}\"`;\n            }\n            if (mediaInfo.hasVideo && mediaInfo.videoCodec) {\n                this._mimeCodec.video = `video/mp4; codecs=\"${mediaInfo.videoCodec}\"`;\n            }\n        } else {\n            this._mimeCodec.audiovideo = `video/mp4; codecs=\"${mediaInfo.codec}\"`;\n        }\n        this._hasAudio = this._hasAudio || mediaInfo.hasAudio;\n        this._hasVideo = this._hasVideo || mediaInfo.hasVideo;\n\n        this._checkSourceBuffer();\n    }\n\n    /**\n     * trackcodec\n     */\n    private _checkSourceBuffer(): void {\n        let expected = (this._hasAudio ? 1 : 0) + (this._hasVideo ? 1 : 0);\n        let codecs = (this._mimeCodec.audio ? 1 : 0) + (this._mimeCodec.video ? 1 : 0);\n        if (this._mimeCodec.audiovideo) {\n            expected = 1;\n            codecs = 1;\n        }\n        Log.v(this.tag, 'checkSourceBuffer', expected, codecs, this._mimeCodec);\n        if (this._mediaSource && this._mediaSource.readyState === 'open' && expected > 0 && codecs >= expected) {\n            for (const type in this._mimeCodec) {\n                if (this._mimeCodec[type]) {\n                    this._addSourceBuffer(type);\n                }\n            }\n        }\n    }\n\n    /**\n     * mediaSource open\n     */\n    private _onSourceOpen = () => {\n        Log.i(this.tag, 'MediaSource onSourceOpen');\n        if (this._mediaSource) {\n            this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n            this._checkSourceBuffer();\n            this.refresh();\n            this.emit('source_open');\n        }\n    };\n\n    /**\n     * addSourceBuffer\n     * @param {String} type type\n     */\n    private _addSourceBuffer(type: string): void {\n        if (this._sourceBuffer[type] || this._souceBufferLocked) {\n            return;\n        }\n        try {\n            if (this._mediaSource) {\n                this._sourceBuffer[type] = this._mediaSource.addSourceBuffer(this._mimeCodec[type]);\n            }\n        } catch (e) {\n            Log.e(this.tag, e);\n            this.emit(LasEvents.ERROR, {\n                type: ErrorTypes.MSE_ERROR,\n                details: ErrorDetails.ADDSOURCEBUFFER_ERROR,\n                fatal: true,\n                reason: e.message\n            });\n            return;\n        }\n        const sb = this._sourceBuffer[type];\n        this._sbHandler[type] = {\n            updateend: () => {\n                this._onSourceBufferUpdateEnd(type);\n            },\n            error: (e: Event) => {\n                this._onSourceBufferError(e);\n            }\n        };\n        sb.addEventListener('error', this._sbHandler[type].error);\n        sb.addEventListener('updateend', this._sbHandler[type].updateend);\n        if (this._duration && this._mediaSource) {\n            this._mediaSource.duration = this._duration;\n        }\n    }\n\n    /**\n     * \n     */\n    private _hasPendingData(): boolean {\n        return !!(\n            this._appendQueue &&\n            ((this._appendQueue.video && this._appendQueue.video.length) ||\n                (this._appendQueue.audio && this._appendQueue.audio.length))\n        );\n    }\n\n    /**\n     * MSEbuffer\n     */\n    public refresh() {\n        for (const type in this._sourceBuffer) {\n            this._update(type);\n        }\n    }\n\n    /**\n     * mse sourcebuffer\n     */\n    private _doAppend(type: string): void {\n        if (this._hasPendingData()) {\n            if (!this._appendEnabled) {\n                const size = this._getBufferQueueSize();\n                if (size > QUEUE_SIZE_LIMIT && !this._appendBufferError) {\n                    this._appendBufferError = true;\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: 'bufferfull'\n                    });\n                }\n                return;\n            }\n            if (\n                this._appendQueue[type].length > 0 &&\n                this._sourceBuffer[type] &&\n                !this._sourceBuffer[type].updating &&\n                !this._appendBufferError\n            ) {\n                const data = this._appendQueue[type].shift();\n                this._appendBuffer(data, type);\n            }\n        }\n    }\n\n    /**\n     * fmp4\n     * @param segment segment\n     */\n    public mediaSegment(segment: Segment): void {\n        const type = segment.type;\n        const queue = this._appendQueue[type];\n        if (!this._souceBufferLocked || this._sourceBuffer[type]) {\n            queue.push(segment);\n        }\n        if (this._sourceBuffer[type]) {\n            this._souceBufferLocked = true;\n            this._update(type);\n        }\n    }\n\n    /**\n     * mse buffer\n     * @param type video|audio|audiovideo\n     */\n    public bufferedByType(type: string): { start: number; end: number } {\n        const sb = this._sourceBuffer[type];\n        if (sb && sb.buffered.length > 0) {\n            return { start: sb.buffered.start(0), end: sb.buffered.end(sb.buffered.length - 1) };\n        }\n        return { start: 0, end: 0 };\n    }\n\n    /**\n     * mse buffer\n     * @param type video|audio|audiovideo\n     */\n    public bufferedEndByType(type: string): number {\n        const sb = this._sourceBuffer[type];\n        if (sb && sb.buffered.length > 0) {\n            return sb.buffered.end(sb.buffered.length - 1);\n        }\n        return 0;\n    }\n\n    /**\n     * mse buffer1\n     * @param type video|audio|audiovideo\n     */\n    public bufferSliceNumByType(type: string): number {\n        const sb = this._sourceBuffer[type];\n        if (sb) {\n            return sb.buffered.length;\n        }\n        return 0;\n    }\n\n    /**\n     * buffer\n     * @param type video|audio|audiovideo\n     */\n    public pendingSecByType(type: string): number {\n        const buffer = this._appendQueue[type];\n        if (buffer) {\n            return buffer.reduce((prev, current) => {\n                return prev + current.duration;\n            }, 0);\n        }\n        return 0;\n    }\n\n    /**\n     * buffer\n     */\n    public pendingNum(): number {\n        let num = 0;\n        for (let type in this._appendQueue) {\n            num += this._appendQueue[type].length;\n        }\n        return num;\n    }\n\n    /**\n     * \n     * @param type video|audio|audiovideo\n     */\n    private _calculateRemoveRange(type: string): void {\n        const video = this.video;\n        if (!video || video.seeking) {\n            return;\n        }\n        const time = video.currentTime;\n        if (this._sourceBuffer[type]) {\n            const task = this._cleanUpTask[type];\n            const buffered = this._sourceBuffer[type].buffered;\n            if (buffered.length >= 1 && time - buffered.start(0) >= this._config.autoCleanupMaxBackwardDuration) {\n                const end = time - this._config.autoCleanupMinBackwardDuration;\n                if (task.length) {\n                    if (task[task.length - 1].start === 0 && task[task.length - 1].end === end) {\n                        return;\n                    }\n                }\n                task.push({ start: 0, end });\n            }\n        }\n    }\n\n    /**\n     * sourcebufer\n     * @param sb sourceBuffer\n     * @param range \n     */\n    private _cleanUpRange(type: string, range: TimeRange): boolean {\n        const sb = this._sourceBuffer[type];\n        if (sb) {\n            if (!sb.updating) {\n                try {\n                    for (let i = 0; i < sb.buffered.length; i++) {\n                        const bufStart = Browser.firefox ? 0 : sb.buffered.start(i);\n                        const bufEnd = sb.buffered.end(i);\n                        const removeStart = Math.max(bufStart, range.start);\n                        const removeEnd = Math.min(bufEnd, range.end);\n                        /**\n                         * removeremove500ms\n                         */\n                        if (removeEnd > removeStart) {\n                            sb.remove(removeStart, removeEnd);\n                            this.emit('remove');\n                            // buffer\n                            if (i < sb.buffered.length - 1) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) { }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * sourcebuffer\n     * @param data data\n     * @param type type\n     */\n    private _appendBuffer(data: Segment, type: string): void {\n        if (!this._sourceBuffer[type] || !this.video || this.video.error) {\n            return;\n        }\n        try {\n            this._sourceBuffer[type].appendBuffer(data.data.buffer);\n        } catch (e) {\n            Log.w(this.tag, e.code, e);\n            if (e.code !== 22) {\n                if (this._appendError) {\n                    this._appendError++;\n                } else {\n                    this._appendError = 1;\n                }\n                if (this._appendError > this._config.appendErrorMaxRetry) {\n                    this._appendBufferError = true;\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: e.message\n                    });\n                } else {\n                    this._appendQueue[type].unshift(data);\n                }\n            } else {\n                let v = this.video, conf = this._config;\n                this._appendEnabled = false;\n                this._appendQueue[type].unshift(data);\n                let buffered = v.buffered.end(v.buffered.length - 1) - v.currentTime;\n                // mse bufferfull \n                let useless = v.currentTime - v.buffered.start(0);\n                if (buffered < MAX_BUFFERED) {\n                    //  bufferbuffer\n                    if (useless < conf.autoCleanupMaxBackwardDuration) {\n                        conf.autoCleanupMaxBackwardDuration = Math.max(conf.autoCleanupMaxBackwardDuration / 2, MIN_CLEANUP_DURATION + CLEANUP_DURATION_STEP);\n                        conf.autoCleanupMinBackwardDuration = MIN_CLEANUP_DURATION;\n                    }\n                    this._calculateRemoveRange(type);\n                    if (this.hasCleanUpTask(type)) {\n                        this._cleanUp(type);\n                    }\n                } else if (useless < conf.autoCleanupMinBackwardDuration) {\n                    //  buffer\n                    this.emit(LasEvents.ERROR, {\n                        type: ErrorTypes.MSE_ERROR,\n                        details: ErrorDetails.APPENDBUFFER_ERROR,\n                        fatal: true,\n                        reason: 'buffer full, append error'\n                    });\n                }\n                Log.i(this.tag, 'mse bufferfull')\n                this.emit('bufferFull');\n            }\n        }\n    }\n\n    /**\n     * sourcebuffer end\n     */\n    private _onSourceEnded = () => {\n        Log.i(this.tag, 'MediaSource onSourceEnded');\n    };\n\n    /**\n     * sourcebuffer close\n     */\n    private _onSourceClose = () => {\n        Log.i(this.tag, 'MediaSource onSourceClose');\n        if (this._mediaSource) {\n            this._mediaSource.removeEventListener('sourceopen', this._onSourceOpen);\n            this._mediaSource.removeEventListener('sourceended', this._onSourceEnded);\n            this._mediaSource.removeEventListener('sourceclose', this._onSourceClose);\n        }\n    };\n\n    private _onSourceBufferUpdateEnd = (type: string) => {\n        this._update(type);\n        if (this._endOfData) {\n            this._endOfStream();\n        }\n        this.emit('updateend');\n    };\n\n    /**\n     * sourcebuffer error\n     * @param {Object} e \n     */\n    private _onSourceBufferError = (e: Event) => {\n        Log.e(this.tag, `SourceBuffer Error: ${e}`);\n        this.emit(LasEvents.ERROR, {\n            type: ErrorTypes.MSE_ERROR,\n            details: ErrorDetails.SOURCEBUFFER_ERROR,\n            fatal: true,\n            reason: 'source buffer error'\n        });\n    };\n\n    /**\n     * mse sourcebuffer\n     * @param startSec 0\n     * @param endSec \n     * @param flushType sourcebuffe\n     */\n    public flush(startSec?: number, endSec?: number, flushType?: string): void {\n        let start = 0,\n            end = Number.POSITIVE_INFINITY;\n        this._endOfData = false;\n        // \n        for (const type in this._sourceBuffer) {\n            if (flushType && flushType !== type) {\n                continue;\n            }\n            const sb = this._sourceBuffer[type];\n            if (!sb) {\n                continue;\n            }\n            // \n            if (startSec) {\n                start = Math.max(start, startSec);\n                for (let i = this._appendQueue[type].length - 1; i >= 0; i--) {\n                    if (!this._appendQueue[type][i].startPTS || this._appendQueue[type][i].startPTS >= startSec) {\n                        this._appendQueue[type].pop();\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                this._appendQueue[type] = [];\n            }\n            if (endSec) {\n                end = Math.min(end, endSec);\n            }\n            this._cleanUpTask[type].push({ start, end });\n            this._cleanUp(type);\n        }\n        this._appendEnabled = true;\n    }\n\n    /**\n     * buffer\n     * @param value \n     */\n    public setAppendEnabled(value: boolean): void {\n        if (!this._appendEnabled && value) {\n            this._appendEnabled = value;\n            this.refresh();\n        } else {\n            this._appendEnabled = value;\n        }\n    }\n\n    public getAppendEnabled(): boolean {\n        return this._appendEnabled;\n    }\n\n    public endOfData(): void {\n        this._endOfData = true;\n        if (!this._hasPendingData()) {\n            this._endOfStream();\n        }\n    }\n\n    public ended(): boolean {\n        return this._endOfData;\n    }\n\n    private _endOfStream(): void {\n        const ms = this._mediaSource;\n        if (!ms || ms.readyState !== 'open') {\n            return;\n        }\n        for (const type in this._sourceBuffer) {\n            const sb = this._sourceBuffer[type];\n            if (sb && sb.updating) {\n                return;\n            }\n        }\n        try {\n            ms.endOfStream();\n        } catch (error) {\n            Log.e(this.tag, error);\n            this.emit(LasEvents.ERROR, {\n                type: ErrorTypes.MSE_ERROR,\n                details: ErrorDetails.ENDOFSTREAM_ERROR,\n                fatal: true,\n                reason: error.message\n            });\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        if (this._mediaSource) {\n            const ms = this._mediaSource;\n            // pending segments should be discard\n\n            // remove all sourcebuffers\n            this._endOfStream();\n            if (ms.readyState !== 'closed') {\n                for (const type in this._sourceBuffer) {\n                    if (this._sourceBuffer[type] && this._sbHandler[type]) {\n                        this._sourceBuffer[type].removeEventListener('error', this._sbHandler[type].error);\n                        this._sourceBuffer[type].removeEventListener('updateend', this._sbHandler[type].updateend);\n                        ms.removeSourceBuffer(this._sourceBuffer[type]);\n                    }\n                }\n            }\n            ms.removeEventListener('sourceopen', this._onSourceOpen);\n            ms.removeEventListener('sourceended', this._onSourceEnded);\n            ms.removeEventListener('sourceclose', this._onSourceClose);\n            this._mediaSource = null;\n        }\n        this.removeAllListeners();\n        this._appendQueue = {};\n        this._mimeCodec = {};\n        this._cleanUpTask = {};\n        this._sourceBuffer = {};\n        this._sbHandler = {};\n    }\n\n    /**\n     * \n     * @param type video|audio|audiovideo\n     */\n    public hasCleanUpTask(type?: string): boolean {\n        let num = 0;\n        if (typeof type === 'undefined') {\n            for (let type in this._cleanUpTask) {\n                num += this._cleanUpTask[type].length;\n            }\n        } else {\n            if (this._cleanUpTask[type]) {\n                num = this._cleanUpTask[type].length;\n            }\n        }\n        return num > 0;\n    }\n\n    public hasSourceBuffer(): boolean {\n        return !!Object.keys(this._sourceBuffer).length;\n    }\n\n    private _getBufferQueueSize(): number {\n        let num = 0;\n        for (const type in this._appendQueue) {\n            num += this._appendQueue[type].reduce((prev, current) => {\n                if (current.data && current.data.byteLength) {\n                    return prev + current.data.byteLength;\n                }\n                return prev;\n            }, 0);\n        }\n        return num;\n    }\n\n    /**\n     * \n     * @param {string} type video|audio|audiovideovideo|audio\n     * @returns {number} \n     */\n    public getBufferQueueSec(type?: string): number {\n        if (!this._appendQueue) {\n            return 0;\n        }\n        let keys;\n        if (type) {\n            keys = [type];\n        } else {\n            keys = Object.keys(this._appendQueue);\n        }\n        return keys.reduce((prev, current) => {\n            if (this._appendQueue[current] && this._appendQueue[current].length > 0 && (Object.keys(this._sourceBuffer).length === 0 || this._sourceBuffer[current])) {\n                return Math.max(\n                    prev,\n                    this._appendQueue[current].reduce((prevDuration, currentSeg) => {\n                        if (currentSeg.duration) {\n                            return prevDuration + currentSeg.duration;\n                        }\n                        return prevDuration;\n                    }, 0)\n                );\n            }\n            return prev;\n        }, 0);\n    }\n\n    /**\n     * MSEmse.readyState\n     */\n    public get readyState(): ReadyState {\n        if (this._mediaSource) {\n            return this._mediaSource.readyState;\n        }\n        return 'closed';\n    }\n\n    /**\n     * souceBuffer\n     */\n    private _update(type: string): void {\n        if (this.hasCleanUpTask(type)) {\n            this._cleanUp(type);\n        }\n        this._doAppend(type);\n    }\n\n    /**\n     * \n     * @param type video|audio|audiovideo\n     */\n    private _cleanUp(type: string): void {\n        let range = this._cleanUpTask[type];\n        while (range && range.length) {\n            const item = range[0];\n            if (this._cleanUpRange(type, item)) {\n                range.shift();\n            } else {\n                return;\n            }\n        }\n        this.refresh();\n    }\n}\n","import Url from 'url-parse';\n\n/**\n * flv\n * @param url \n * @param spts 0pts0\n */\nexport function abrGetUrl(url: string, spts?: number): string {\n    if (typeof spts === 'undefined') {\n        return url;\n    }\n    const urlparse = new Url(url, true);\n    urlparse.query.lasSpts = `${spts}`;\n    return urlparse.toString();\n}","export default class AbrLevel {\n    public url: string;\n    public bitrate: number = 0;\n    public maxBitrate: number = 0;\n    public avgBitrate: number = 0;\n    public qualityType: string = '';\n    public qualityLabel: string = '';\n    public id: number = 0;\n    public codec: string = '';\n    public hidden: boolean = false;\n    public enableAdaptive: boolean = true;\n    public defaultSelect: boolean = false;\n\n    constructor(url: string) {\n        this.url = url;\n    }\n}","import AbrLevel from \"./abr-level\";\nexport type Representation = {\n    id: number,  //[int][M]\n    url: string, // [string][M]\n    backupUrl: string[], // [string][M1]\n    host: string, // [string][M2]\n    maxBitrate: number, // [int][M] maxBitrate in kbps set by transcoder\n    avgBitrate: number, // [int][M1&2] avgBitrate in kbps\n    codecs: string, // [string][O]\n    width: number,  // [int][M]\n    height: number, // [int][M]\n    frameRate: number, // [float][O]\n    qualityType: string,  // [string][M] \n    qualityLabel: string, // [string][O] \n    hidden: boolean, // [bool][M] false denotes the representation is show in UI and can be selected by manual model\n    disableAdaptive: boolean, // [bool][M] false denotes the representation can be selected by auto model\n    defaultSelect: boolean // [bool][M1,3,4] false denotes the representation is not selected as the initialization level\n}\n\ntype AdaptationSet = {\n    id: number;\n    duration: number;\n    representation: Representation[];\n};\n\nexport type AbrManifestData = {\n    version: string,\n    adaptationSet: AdaptationSet[];\n};\n\n/**\n * las manifest\n */\nexport class AbrManifest {\n    private _levels: AbrLevel[] = [];\n    private _abrLevels: number[] = [];\n    private _default?: number;\n\n    /**\n     * las manifest\n     * @param data \n     */\n    public static verify(data: any) {\n        if (\n            data &&\n            data.hasOwnProperty('version') &&\n            data.hasOwnProperty('adaptationSet') &&\n            Array.isArray(data.adaptationSet) &&\n            data.adaptationSet.length > 0\n        ) {\n            return data.adaptationSet.reduce((prev: boolean, item: any) => {\n                return !!(prev && item.representation && item.representation.length)\n            }, true);\n        }\n        return false;\n    }\n\n    constructor(manifest: AbrManifestData) {\n        if (AbrManifest.verify(manifest)) {\n\n            manifest.adaptationSet[0].representation.sort((a, b) => {\n                return a.maxBitrate - b.maxBitrate;\n            });\n\n            manifest.adaptationSet[0].representation.forEach((item, index) => {\n                let level = new AbrLevel(item.url);\n                level.id = item.id || 0;\n                level.maxBitrate = item.maxBitrate || 0;\n                level.avgBitrate = item.avgBitrate || 0;\n                level.bitrate = level.maxBitrate;\n                level.qualityType = item.qualityType || '';\n                level.qualityLabel = item.qualityLabel || '';\n                level.codec = item.codecs || '';\n                level.hidden = item.hidden || false;\n                level.enableAdaptive = typeof item.disableAdaptive === 'undefined' ? true : !item.disableAdaptive;\n                level.defaultSelect = item.defaultSelect || false;\n                this._levels.push(level);\n\n                if (level.enableAdaptive) {\n                    this._abrLevels.push(index);\n                }\n                if (level.defaultSelect && typeof this._default === 'undefined') {\n                    this._default = index;\n                }\n            });\n        } else {\n            return;\n        }\n    }\n\n    /**\n     * \n     */\n    public get levels(): AbrLevel[] {\n        return this._levels;\n    }\n\n    /**\n     * index\n     */\n    public get abrLevels(): number[] {\n        return this._abrLevels;\n    }\n\n    /**\n     * \n     */\n    public get default(): number {\n        return this._default || 0;\n    }\n}\n","export type TypedArray\n= | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Uint8ClampedArray\n    | Float32Array\n    | Float64Array;\n\nexport type TypedArrayConstructor\n= | Int8ArrayConstructor\n    | Uint8ArrayConstructor\n    | Int16ArrayConstructor\n    | Uint16ArrayConstructor\n    | Int32ArrayConstructor\n    | Uint32ArrayConstructor\n    | Uint8ClampedArrayConstructor\n    | Float32ArrayConstructor\n    | Float64ArrayConstructor;\n\nconst type: (input: TypedArray) => TypedArrayConstructor = (input: TypedArray): TypedArrayConstructor => {\n    switch (input.constructor.name) {\n        case 'Int8Array':\n            return Int8Array;\n        case 'Uint8Array':\n            return Uint8Array;\n        case 'Int16Array':\n            return Int16Array;\n        case 'Uint16Array':\n            return Uint16Array;\n        case 'Int32Array':\n            return Int32Array;\n        case 'Uint32Array':\n            return Uint32Array;\n        case 'Uint8ClampedArray':\n            return Uint8ClampedArray;\n        case 'Float64Array':\n            return Float64Array;\n        default:\n            return Float32Array;\n    }\n};\n\nconst flatten: (input: any[]) => number[] = (input: any[]): number[] =>\n    input.reduce((acc: any[], next: any) => acc.concat(Array.isArray(next) ? flatten(next) : next), []);\n\nconst shape: (input: any) => number[] = (input: any): number[] =>\n    Array.isArray(input) ? [input.length].concat(shape(input[0])) : [];\n\nconst isTypedArray: (input: any) => boolean = (input: any): boolean =>\n    !!(input && input.buffer instanceof ArrayBuffer && input.BYTES_PER_ELEMENT);\n\nexport class Matrix {\n    /**\n     * Static method. Adds two matrices `a` and `b` together.\n     */\n    public static add(a: Matrix, b: Matrix): Matrix {\n        return a.copy().add(b);\n    }\n\n    /**\n     * Static method. Subtracts the matrix `b` from matrix `a`.\n     */\n    public static subtract(a: Matrix, b: Matrix): Matrix {\n        return a.copy().subtract(b);\n    }\n\n    /**\n     * Static method. Augments two matrices `a` and `b` of matching dimensions\n     * (appends `b` to `a`).\n     */\n    public static augment(a: Matrix, b: Matrix): Matrix {\n        return a.copy().augment(b);\n    }\n\n    /**\n     * Static method. Multiplies two matrices `a` and `b` of matching dimensions.\n     */\n    public static multiply(a: Matrix, b: Matrix): Matrix {\n        return a.multiply(b);\n    }\n\n    /**\n     * Static method. Creates an `r x c` matrix containing zeros (`0`), takes an\n     * optional `type` argument which should be an instance of `TypedArray`.\n     */\n    public static zeros(r: number, c: number, type: TypedArrayConstructor = Float32Array): Matrix {\n        return Matrix.fill(r, c, 0, type);\n    }\n\n    /**\n     * Static method. Creates a `r x c` matrix containing optional 'value' (default 0), takes\n     * an optional `type` argument which should be an instance of `TypedArray`.\n     */\n    public static fill(\n        r: number,\n        c: number,\n        value: number | ((index: number) => number) = 0,\n        type: TypedArrayConstructor = Float32Array\n    ): Matrix {\n        if (r <= 0 || c <= 0) {\n            throw new Error('invalid size');\n        }\n\n        const size: number = r * c;\n        const data: TypedArray = new type(size);\n\n        return new Matrix(data, { shape: [r, c] }).fill(value);\n    }\n\n    public data: TypedArray = new Float32Array(0);\n    public length: number = 0;\n    public shape: number[] = [0];\n    public type: TypedArrayConstructor = Float32Array;\n\n    /**\n     * Static method. Creates an identity matrix of `size`, takes an optional `type` argument\n     * which should be an instance of `TypedArray`.\n     */\n    public static identity(size: number, type: TypedArrayConstructor = Float32Array): Matrix {\n        return Matrix.fill(size, size, (i: number) => i % size === Math.floor(i / size) ? 1 : 0, type);\n    }\n\n    constructor(data?: any, options?: any) {\n        if (typeof data === 'number' && typeof options === 'number') {\n            this._init(new Float32Array(data * options), { shape: [data, options] });\n        } else {\n            this._init(data, options);\n        }\n    }\n\n    private _init(\n        data?: any,\n        options?: {\n        shape: number[];\n        }\n    ) {\n        if (isTypedArray(data)) {\n            this.data = data as TypedArray;\n            this.shape = typeof options === 'object' ? options.shape : [this.data.length];\n            this.length = this.data.length;\n            this.type = type(data);\n        } else if (data instanceof Array) {\n            this.data = new Float32Array(flatten(data));\n            this.shape = shape(data);\n            this.length = this.data.length;\n        } else if (data instanceof Matrix) {\n            return data.copy();\n        }\n    }\n\n    public multiply(matrix: Matrix): Matrix {\n        const [r1, c1] = this.shape;\n        const [r2, c2] = matrix.shape;\n\n        if (c1 !== r2) {\n            throw new Error('sizes do not match');\n        }\n\n        const { data: d1 } = this;\n        const { data: d2 } = matrix;\n        const data: TypedArray = new this.type(r1 * c2);\n\n        let i: number;\n        let j: number;\n        let k: number;\n        let sum: number;\n        for (i = 0; i < r1; i += 1) {\n            for (j = 0; j < c2; j += 1) {\n                sum = 0;\n                for (k = 0; k < c1; k += 1) {\n                    sum += d1[i * c1 + k] * d2[j + k * c2];\n                }\n\n                data[i * c2 + j] = sum;\n            }\n        }\n\n        return new Matrix(data, { shape: [r1, c2] });\n    }\n\n    /**\n     * Adds `x` multiplied by `alpha` to the current array.\n     */\n    public add(x: Matrix, alpha: number = 1): this {\n        this.equilateral(x);\n        this.equidimensional(x);\n\n        const { data: d1, length: l1 } = this;\n        const { data: d2 } = x;\n\n        let i: number;\n        for (i = 0; i < l1; i += 1) {\n            d1[i] += alpha * d2[i];\n        }\n\n        return this;\n    }\n\n    /**\n     * Subtracts `x` to the current array.\n     */\n    public subtract(x: Matrix): this {\n        return this.add(x, -1);\n    }\n\n    /**\n     * Augments `matrix` with current matrix.\n     */\n    public augment(matrix: Matrix): Matrix {\n        const [r1, c1] = this.shape;\n        const [r2, c2] = matrix.shape;\n\n        if (r2 === 0 || c2 === 0) {\n            return this;\n        }\n\n        if (r1 !== r2) {\n            throw new Error('rows do not match');\n        }\n\n        const { data: d1 } = this;\n        const { data: d2 } = matrix;\n        const length: number = c1 + c2;\n        const data: TypedArray = new this.type(length * r1);\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r1; i += 1) {\n            for (j = 0; j < c1; j += 1) {\n                data[i * length + j] = d1[i * c1 + j];\n            }\n        }\n\n        for (i = 0; i < r2; i += 1) {\n            for (j = 0; j < c2; j += 1) {\n                data[i * length + j + c1] = d2[i * c2 + j];\n            }\n        }\n\n        this.shape = [r1, length];\n        this.length = data.length;\n        this.data = data;\n\n        return this;\n    }\n\n    /**\n     * Fills the array with a scalar value, takes an optional `type` argument\n     * which should be an instance of `TypedArray`.\n     */\n    public fill(value: number | ((index: number) => number) = 0): this {\n        const { data, length } = this;\n\n        let i: number;\n        for (i = 0; i < length; i += 1) {\n            data[i] = value instanceof Function ? value(i) : value;\n        }\n\n        return this;\n    }\n\n    /**\n     * Transposes a matrix (mirror across the diagonal).\n     */\n    public transpose(): Matrix {\n        const [r, c] = this.shape;\n        const data: TypedArray = new this.type(c * r);\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r; i += 1) {\n            for (j = 0; j < c; j += 1) {\n                data[j * r + i] = this.data[i * c + j];\n            }\n        }\n\n        return new Matrix(data, { shape: [c, r] });\n    }\n\n    /**\n     * Determines the inverse of any invertible square matrix using\n     * Gaussian elimination.\n     */\n    public inverse(): Matrix {\n        const [r, c] = this.shape;\n\n        if (r !== c) {\n            throw new Error('invalid dimensions');\n        }\n\n        const identity: Matrix = Matrix.identity(r);\n        const augmented: Matrix = Matrix.augment(this, identity);\n        const gauss: Matrix = augmented.gauss();\n        const left: Matrix = Matrix.zeros(r, c);\n        const right: Matrix = Matrix.zeros(r, c);\n\n        const n: number = gauss.shape[1];\n\n        let i: number;\n        let j: number;\n        for (i = 0; i < r; i += 1) {\n            for (j = 0; j < n; j += 1) {\n                if (j < c) {\n                    left.set(i, j, gauss.get(i, j));\n                } else {\n                    right.set(i, j - r, gauss.get(i, j));\n                }\n            }\n        }\n\n        if (!left.equals(Matrix.identity(r))) {\n            throw new Error('matrix is not invertible');\n        }\n\n        return right;\n    }\n\n    /**\n     * Performs Gaussian elimination on a matrix.\n     */\n    public gauss(): Matrix {\n        const [r, c] = this.shape;\n        const copy: Matrix = this.copy();\n\n        let lead: number = 0;\n        let pivot: number;\n        let leadValue: number;\n\n        let i: number;\n        let j: number;\n        let k: number;\n        for (i = 0; i < r; i += 1) {\n            if (c <= lead) {\n                throw new Error('matrix is singular');\n            }\n\n            j = i;\n            while (copy.data[j * c + lead] === 0) {\n                j += 1;\n                if (r === j) {\n                    j = i;\n                    lead += 1;\n\n                    if (c === lead) {\n                        throw new Error('matrix is singular');\n                    }\n                }\n            }\n\n            copy.swap(i, j);\n\n            pivot = copy.data[i * c + lead];\n            if (pivot !== 0) {\n                for (k = 0; k < c; k += 1) {\n                    copy.data[i * c + k] = copy.data[i * c + k] / pivot;\n                }\n            }\n\n            for (j = 0; j < r; j += 1) {\n                leadValue = copy.data[j * c + lead];\n                if (j !== i) {\n                    for (k = 0; k < c; k += 1) {\n                        copy.data[j * c + k] = copy.data[j * c + k] - copy.data[i * c + k] * leadValue;\n                    }\n                }\n            }\n\n            lead += 1;\n        }\n\n        for (i = 0; i < r; i += 1) {\n            pivot = 0;\n            for (j = 0; j < c; j += 1) {\n                if (pivot === 0) {\n                    pivot = copy.data[i * c + j];\n                }\n            }\n\n            if (pivot === 0) {\n                for (k = 0; k < c; k += 1) {\n                    copy.data[i * c + k] = copy.data[i * c + k] / pivot;\n                }\n            }\n        }\n\n        return copy;\n    }\n\n    /**\n     * Checks if current array and `x` are equal.\n     */\n    public equals(x: Matrix): boolean {\n        this.equilateral(x);\n        this.equidimensional(x);\n\n        const { data: d1, length: l1 } = this;\n        const { data: d2 } = x;\n\n        let i: number;\n        for (i = 0; i < l1; i += 1) {\n            if (d1[i] !== d2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if `i` and `j` is within the bounds for current matrix.\n     */\n    public check(i: number, j: number): void {\n        const [r, c] = this.shape;\n\n        if (isNaN(i) || isNaN(j)) {\n            throw new Error('one of the indices is not a number');\n        }\n\n        if (i < 0 || j < 0 || i > r - 1 || j > c - 1) {\n            throw new Error('index out of bounds');\n        }\n    }\n\n    /**\n     * Sets the element at row `i`, column `j` to value\n     */\n    public set(i: number, j: number, value: number): Matrix {\n        this.check(i, j);\n        this.data[i * this.shape[1] + j] = value;\n\n        return this;\n    }\n\n    /**\n     * Gets the value of the element in row `i`, column `j` of current matrix\n     */\n    public get(i: number, j: number): number {\n        this.check(i, j);\n\n        return this.data[i * this.shape[1] + j];\n    }\n\n    /**\n     * Swaps two rows `i` and `j` in a matrix\n     */\n    public swap(i: number, j: number): Matrix {\n        const [r, c] = this.shape;\n        if (i < 0 || j < 0 || i > r - 1 || j > r - 1) {\n            throw new Error('index out of bounds');\n        }\n\n        if(this.data.slice) {\n            const copy: TypedArray = this.data.slice(i * c, (i + 1) * c);\n            this.data.copyWithin(i * c, j * c, (j + 1) * c);\n            this.data.set(copy, j * c);\n        } else {\n            // IE 11  slice copyWithin \n            const D:any = this.data.constructor;\n            const copy: TypedArray = new D(this.data.buffer.slice(0));\n            this.data.set(copy.subarray(i * c, (i + 1) * c), j * c);\n            this.data.set(copy.subarray(j * c, (j + 1) * c), i * c);\n        }\n\n        return this;\n    }\n    /**\n     * Makes a copy of the class and underlying data\n     */\n    public copy(): this {\n        const copy: Matrix = Object.assign(Object.create(Object.getPrototypeOf(this)), this) as Matrix;\n\n        copy.data = new this.type(this.data);\n        copy.shape = this.shape;\n        copy.length = this.length;\n        copy.type = this.type;\n\n        return copy as this;\n    }\n\n    /**\n     * Asserts if current array and `x` have the same shape\n     */\n    public equidimensional(x: Matrix): void {\n        const { shape: s1 } = this;\n        const { shape: s2 } = x;\n\n        if (!s1.every((dim: number, i: number) => dim === s2[i])) {\n            throw new Error(`shapes ${s1} and ${s2} do not match`);\n        }\n    }\n\n    /**\n     * Asserts if current array and `x` have the same length\n     */\n    public equilateral(x: Matrix): void {\n        const { length: l1 } = this;\n        const { length: l2 } = x;\n\n        if (l1 !== l2) {\n            throw new Error(`lengths ${l1} and ${l2} do not match`);\n        }\n    }\n}\n","import {EventEmitter} from 'events';\nimport {Log} from '../utils/log';\nimport {Matrix} from '../utils/matrix';\nimport AbrLevel from './abr-level';\nimport {AbrManifest} from './abr-manifest';\n\ntype AdaptiveConfig = {\n    beacon: boolean;\n    predictStep: number;\n    minBuffer: number; // buffer\n    bufferOffset: number; // buffer\n    duration: number; // \n    smoothRatioToTarget: number;\n    speedSmoothRatio: number;\n    switchPenalty: number;\n    slidingWindowSize: number;\n    kalmanR: number;\n    kalmanQ: number;\n    initBitrateLevel: number;\n    speedPredictNum: number;\n};\n\nconst tag = 'algorithm-flv';\n\nconst CONFIG: AdaptiveConfig = {\n    beacon: false, // \n    predictStep: 5,\n    minBuffer: 0.2, // buffer\n    bufferOffset: -1,\n    duration: 2, // \n    smoothRatioToTarget: 0.25,\n    speedSmoothRatio: 0.5,\n    switchPenalty: 1.5 * 1e-6,\n    slidingWindowSize: 3,\n    kalmanR: 0.2 ** 2,\n    kalmanQ: 4e-4,\n    initBitrateLevel: 3, // \n    speedPredictNum: 3, // \n};\n\n/**\n * HLS\n */\nclass AbrAlgorithm extends EventEmitter {\n    private MATRIX_E!: Matrix;\n    private MATRIX_G!: Matrix;\n\n    private _conf!: AdaptiveConfig;\n\n    private _xPrev: number = 0;\n    private _PPrev: number = 0;\n    private _pastBuffer!: number[];\n    private _pastThroughput!: number[];\n    private _levels!: AbrLevel[];\n    private _availableList?: number[];\n    private _current: number = 0; // index\n    private _next: number = 0; // index\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * \n     * @param manifest \n     * @param config \n     */\n    public init(manifest: AbrManifest, config?: any): void {\n        // TODO: config\n        this._processConfig(config);\n\n        Log.i(tag, 'init', manifest, config, this._conf);\n        this._levels = manifest.levels.slice(0);\n        // TODO: defaultconfig.initBitrateLevel\n        this._current = manifest.default;\n\n        // initialize the parameters\n        this._next = 0;\n        this._pastBuffer = [0, 0];\n        this._pastThroughput = new Array(this._conf.slidingWindowSize);\n        this._pastThroughput[this._conf.slidingWindowSize - 1] = 0;\n        // initialize the parameters of kalman filter\n        this._xPrev = 0;\n        this._PPrev = 0;\n        // matrix initialization\n        this.MATRIX_E = Matrix.zeros(\n            this._conf.predictStep,\n            this._conf.predictStep\n        );\n        this.MATRIX_G = Matrix.zeros(this._conf.predictStep, 2);\n\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            for (let j = 0; j < i + 1; j++) {\n                this.MATRIX_E.set(i, j, i - j + 1);\n            }\n        }\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            this.MATRIX_G.set(i, 0, i + 2);\n            this.MATRIX_G.set(i, 1, -i - 1);\n        }\n    }\n\n    /**\n     * \n     * @param list index\n     */\n    public setAvailableBitrates(list: number[]): void {\n        if (list.length) {\n            this._availableList = list;\n        }\n    }\n\n    /**\n     * \n     * @returns {number} index\n     */\n    public get nextLevel(): number {\n        return this._next;\n    }\n\n    /**\n     * \n     * @param buffered buffer\n     * @param size \n     * @param time \n     */\n    public onGOP(buffered: number, size: number, time: number): void {\n        // Byte/s -> kbps: {x} * 1000 * 8 / 1024;\n        let speed = (size / time) * 8 / 1024;\n        this._next = this._nextRateIndex(\n            this._recentSpeed(speed),\n            buffered\n        );\n    }\n\n    /**\n     * \n     * @param index index\n     */\n    public onLevelLoad(index: number): void {\n        this._current = Math.max(0, index);\n    }\n\n    /**\n     * \n     * @param config \n     */\n    private _processConfig(config?: any): void {\n        const c = Object.assign({}, CONFIG);\n        this._conf = Object.assign(c, config);\n    }\n\n    private _quantization(bitrate: number, speed: number): number {\n        let index = this._current;\n        for (let i = this._levels.length - 1; i >= 0; i--) {\n            if (bitrate >= this._levels[i].bitrate) {\n                index = i;\n                break;\n            }\n        }\n        if (index > this._current && speed < this._levels[index].bitrate) {\n            index -= 1;\n        }\n        return index;\n    }\n\n    /**\n     * \n     * @param value  kpbs\n     * @param buffered buffer ms\n     */\n    private _nextRateIndex(value: number, buffered: number): number {\n        this._pastThroughput.shift();\n        this._pastThroughput.push(value);\n\n        let index = this._nextRateBySpeedAndBuffered(value, buffered);\n        if (index >= this._current) {\n            this._pastBuffer.shift();\n            this._pastBuffer.push(buffered);\n        } else {\n            this._pastBuffer = [buffered, buffered];\n        }\n\n        if (\n            this._availableList &&\n            this._availableList.length &&\n            this._availableList.indexOf(index) === -1\n        ) {\n            for (let i = this._availableList.length - 1; i >= 0; i--) {\n                if (this._availableList[i] <= index) {\n                    index = this._availableList[i];\n                    break;\n                }\n            }\n            index = Math.max(index, this._availableList[0]);\n        }\n        return index;\n    }\n\n    /**\n     * \n     */\n    private _resetAlgorithm() {\n        this._pastBuffer = [0, 0];\n        this._pastThroughput = new Array(this._conf.slidingWindowSize);\n    }\n\n    /**\n     * buffer\n     */\n    private _recentBuffer(): number {\n        return this._pastBuffer.reduce((a, b) => a + b) / this._pastBuffer.length;\n    }\n\n    /**\n     * \n     */\n    private _recentSpeed(value: number): number {\n        const speed = this._pastThroughput[this._pastThroughput.length - 1];\n        if (speed > 0) {\n            return speed * this._conf.speedSmoothRatio + value * (1 - this._conf.speedSmoothRatio);\n        }\n        return value;\n    }\n\n    /**\n     * bufferTarget Buffer\n     */\n    private _adjustedTargetBuffer(): number {\n        const targetBuffer = Math.max(this._conf.minBuffer, this._recentBuffer() + this._conf.bufferOffset);\n        Log.v(tag, `targetBuffer:${targetBuffer}`);\n        return targetBuffer;\n    }\n\n    /**\n     * \n     * @param switchPenaltyArray \n     * @param estimatedThroughput \n     * @param Bk buffer\n     * @param br buffer\n     */\n    private _rateChangeArray(switchPenaltyArray: Matrix, estimatedThroughput: number[], Bk: Matrix, br: number[]): any {\n        const targetBufferArray = new Matrix(br);\n        this._printFirstColumn(targetBufferArray, 'targetBufferArray');\n\n        const matrixG = this.MATRIX_G;\n        const predictedBufferArray = Matrix.multiply(matrixG, Bk);\n        this._printFirstColumn(predictedBufferArray, 'predictedBufferArray');\n\n        const matrixE = this.MATRIX_E;\n        const matrixF = matrixE.multiply(this._diag(estimatedThroughput));\n        return Matrix.multiply(\n            Matrix.multiply(\n                Matrix.add(\n                    Matrix.multiply(matrixF.transpose(), matrixF),\n                    switchPenaltyArray\n                ).inverse(),\n                matrixF.transpose()\n            ),\n            Matrix.subtract(targetBufferArray, predictedBufferArray)\n        );\n    }\n\n    /**\n     * buffer\n     * @param speed  kbps\n     * @param buffered buffer ms\n     */\n    private _nextRateBySpeedAndBuffered(\n        speed: number,\n        buffered: number\n    ): number {\n        const switchPenaltyArray = Matrix.zeros(\n            this._conf.predictStep,\n            this._conf.predictStep\n        );\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            switchPenaltyArray.set(\n                i,\n                i,\n                this._conf.switchPenalty * (this._conf.predictStep - i)\n            );\n        }\n\n        const futureThroughput = this._multistepPred(\n            this._pastThroughput,\n            this._conf.predictStep\n        );\n        // const result = this._multistepKalmanfilter(\n        //     this._xPrev,\n        //     this._pastThroughput[this._pastThroughput.length - 1],\n        //     this._PPrev,\n        //     this._conf.predictStep\n        // );\n        // const futureThroughput = result.futureThroughput;\n        // this._xPrev = result.xRet;\n        // this._PPrev = result.PRet;\n        Log.v(tag, `futureThroughput:${futureThroughput}`);\n        const estimatedThroughput = futureThroughput.map(item => {\n            return -(this._conf.duration / item);\n        });\n\n        const Bk = new Matrix([[buffered], [this._recentBuffer()]]);\n\n        const br: any[] = [];\n        br[0] = [buffered];\n        const target = this._adjustedTargetBuffer();\n        for (let i = 0; i < this._conf.predictStep; i++) {\n            br[i + 1] = [\n                this._conf.smoothRatioToTarget * br[i] +\n                (1 - this._conf.smoothRatioToTarget) * target\n            ];\n        }\n        const rateChangeArray = this._rateChangeArray(switchPenaltyArray, estimatedThroughput, Bk, br.slice(1));\n        Log.v(\n            tag,\n            `algorithm input speed:${speed} buffered:${buffered}`,\n            `output result:${rateChangeArray.get(0, 0)}`\n        );\n        return this._quantization(\n            (this._levels[this._current].bitrate + rateChangeArray.get(0, 0)),\n            speed\n        );\n    }\n\n    private _printFirstColumn(matrix: Matrix, name: string) {\n        let out = [];\n        for (let i = 0; i < matrix.shape[0]; ++i) {\n            out[i] = +matrix.get(i, 0).toFixed(2);\n        }\n        Log.v(tag, name, JSON.stringify(out));\n    }\n\n    private _printFirstRow(matrix: Matrix, name: string) {\n        let out = [];\n        for (let i = 0; i < matrix.shape[0]; ++i) {\n            out[i] = +matrix.get(0, i).toFixed(2);\n        }\n        Log.v(tag, name, JSON.stringify(out));\n    }\n\n    private _diag(arr: any[]): Matrix {\n        const dist = [],\n            len = arr.length;\n        for (let i = 0; i < len; i++) {\n            dist[i] = new Array(len);\n            for (let j = 0; j < len; j++) {\n                dist[i][j] = 0;\n            }\n            dist[i][i] = arr[i];\n        }\n        return new Matrix(dist, { shape: [len, len] });\n    }\n\n    private _multistepPred(\n        pastThroughput: number[],\n        predictStep: number\n    ): number[] {\n        const futureThroughput = new Array(predictStep);\n        const pastThroughputClone = pastThroughput.slice(0);\n        for (let i = 0; i < predictStep; i++) {\n            let bandwidthSum = 0,\n                nonzeroCnt = 0;\n            for (let j = 0; j < pastThroughput.length; j++) {\n                if (pastThroughputClone[j]) {\n                    bandwidthSum += 1.0 / pastThroughputClone[j];\n                    nonzeroCnt += 1;\n                }\n            }\n            if (nonzeroCnt === 0) {\n                continue;\n            } else {\n                futureThroughput[i] = 1.0 / (bandwidthSum / nonzeroCnt);\n            }\n            pastThroughputClone.shift();\n            pastThroughputClone.push(futureThroughput[i]);\n        }\n        return futureThroughput;\n    }\n\n    private _multistepKalmanfilter(\n        xLast: number,\n        z: number,\n        PLast: number,\n        predictStep: number\n    ) {\n        const R = this._conf.kalmanR,\n            Q = this._conf.kalmanQ;\n        const futureThroughput = new Array(this._conf.predictStep);\n        let xPrev = xLast,\n            PPrev = PLast,\n            xRet = 0,\n            PRet = 0;\n        for (let i = 0; i < predictStep; i++) {\n            const xMinus = xPrev,\n                PMinus = PPrev + Q,\n                K = PMinus / (PMinus + R),\n                predX = xMinus + K * (z - xMinus),\n                P = (1 - K) * PMinus;\n            if (i === 0) {\n                xRet = predX;\n                PRet = P;\n            }\n            futureThroughput[i] = predX;\n            xPrev = predX;\n            PPrev = P;\n        }\n        return { futureThroughput, xRet, PRet };\n    }\n}\n\nexport default AbrAlgorithm;\n","import LasEvents from '../core/events';\nimport Media from '../core/media';\nimport Observer from '../core/observer';\nimport { AbrConfig } from '../types/core';\nimport AbrAlgorithm from './abr-algorithm';\nimport { abrGetUrl } from './abr-get-url';\nimport AbrLevel from './abr-level';\nimport { AbrManifest } from './abr-manifest';\n\nexport type MultirateItem = {\n    url: string;\n    level: number;\n}\n/**\n * \n */\nclass Multirate extends Observer {\n    private _config: AbrConfig;\n    private _media: Media;\n    private _next: number = 0;\n    private _downloadSize: number = 0;\n    private _downloadStartTime: number = 0;\n    private _keyCount: number = 0;\n    private _index: number = 0;\n    private _alg: AbrAlgorithm;\n    private _manifest: AbrManifest;\n    private _autoLevelEnabled: boolean = false;\n\n    constructor(config: AbrConfig, media: Media) {\n        super();\n        this._config = config;\n        this._media = media;\n        this._manifest = new AbrManifest(config.manifest);\n        this._alg = new AbrAlgorithm();\n        this._alg.init(this._manifest);\n        this._autoLevelEnabled = this._manifest.abrLevels.length > 0\n    }\n\n    /**\n     * flv\n     */\n    public init(): void {\n        this._downloadSize = 0;\n        this._downloadStartTime = performance.now();\n\n        // I\n        this._keyCount = 0;\n        this._index = this._next = 0;\n\n        if (this.current) {\n            if (this._autoLevelEnabled) {\n                this._index = this._next = this._alg.nextLevel;\n            }\n            this.trigger(LasEvents.MANIFEST_PARSED, {\n                levels: this._manifest.levels,\n                currentLevel: this._index\n            });\n        }\n    }\n\n    public destory(): void {\n        if (this._alg) {\n            this._alg.removeAllListeners();\n        }\n    }\n\n    public onLoaderChunk(size: number): void {\n        this._downloadSize += size;\n    }\n\n    public onLevelLoad(index: number) {\n        if (this._manifest.levels.length && index >= 0 && index < this._manifest.levels.length) {\n            this._keyCount = 0;\n            this._index = index;\n            this._downloadStartTime = performance.now();\n            this._downloadSize = 0;\n            this._alg.onLevelLoad(index);\n        }\n    }\n\n    /**\n     * \n     * @param time flv tag timestamp\n     */\n    public onKeyFrame(time: number): MultirateItem | undefined {\n        let levels = this._manifest.levels;\n        this._keyCount++;\n\n        if ((this._alg || this._next !== this._index) && this._keyCount > 1 && levels) {\n            let next = this._index;\n            if (this._next !== this._index) {\n                // \n                next = this._next;\n            } else if (this._autoLevelEnabled) {\n                // \n                let now = performance.now();\n                this._alg.onGOP(this._media.bufferedSec(), this._downloadSize, (now - this._downloadStartTime) / 1000);\n                this._downloadSize = 0;\n                this._downloadStartTime = now;\n                this._next = next = this._alg.nextLevel;\n            } else {\n                return;\n            }\n            // TEST:\n            // next = (this._index + 1) % levels.length;\n            if (next !== this._index) {\n                return {\n                    url: this._getRequestUrl(next, time),\n                    level: next,\n                }\n            }\n        }\n        return;\n    }\n\n    public get autoLevelEnabled(): boolean {\n        return this._autoLevelEnabled;\n    }\n\n    /**\n     * \n     */\n    public get levels(): AbrLevel[] {\n        return this._manifest.levels;\n    }\n\n    public get nextLevel(): number {\n        if (typeof this._next === 'number') {\n            return this._next;\n        } else {\n            return this._index;\n        }\n    }\n\n    public set nextLevel(value: number) {\n        if (value >= 0 && this._manifest.levels.length > value) {\n            this._autoLevelEnabled = false;\n            this._next = value;\n        } else if (value === -1) {\n            this._autoLevelEnabled = true;\n        }\n    }\n\n    public get currentLevel(): number {\n        return this._index;\n    }\n\n    public set currentLevel(value: number) {\n        if (value >= 0 && this._manifest.levels.length > value) {\n            this._autoLevelEnabled = false;\n            this._index = this._next = value;\n        } else if (value === -1) {\n            this._autoLevelEnabled = true;\n        }\n    }\n\n    private get current(): AbrLevel | undefined {\n        return this._manifest.levels[this._index];\n    }\n\n    /**\n     * flv\n     * @param index index\n     * @param spts 0pts0\n     */\n    private _getRequestUrl(index: number, spts?: number): string {\n        let url = this._config.src;\n        let level = this._manifest.levels[index];\n        if (level) {\n            url = level.url;\n        }\n        return abrGetUrl(url, spts || this._config.defaultSpts);\n    }\n}\n\nexport default Multirate;\n","/**\n * Uint8Array\n */\nclass Cache {\n    // 100m = 104857600 = 100 * 1024 * 1024\n    public static MAX_CACHE_SIZE = 104857600;\n    public static DEFAULT_CACHE_SIZE = 3145728;\n    // cache\n    private _size: number;\n    private _readOffset: number = 0;\n    private _writeOffset: number = 0;\n    // cache\n    private _storage: ArrayBuffer;\n    private _cache: Uint8Array;\n\n    constructor(size: number = 0) {\n        if (size > 0) {\n            this._size = size;\n        } else {\n            this._size = Cache.DEFAULT_CACHE_SIZE;\n        }\n        this._storage = new ArrayBuffer(this._size);\n        this._cache = new Uint8Array(this._storage);\n    }\n\n    /**\n     * cache\n     * @param chunk \n     */\n    public put(chunk: Uint8Array): void {\n        if (this._readOffset === this._writeOffset) {\n            this._readOffset = this._writeOffset = 0;\n        }\n        if (this._writeOffset + chunk.byteLength > this._size) {\n            const expected = this._writeOffset + chunk.byteLength - this._readOffset;\n            if (expected > this._size) {\n                // \n                this._collateCache();\n                this.expandCache(expected);\n            } else {\n                // buffer\n                this._collateCache();\n            }\n        }\n        this._cache.set(chunk, this._writeOffset);\n        this._writeOffset += chunk.byteLength;\n    }\n\n    /**\n     * \n     * @param len \n     * @returns \n     */\n    public get(len: number): Uint8Array | null {\n        if (len + this._readOffset > this._writeOffset) {\n            return null;\n        }\n        let data = null;\n        if (this._cache.slice) {\n            data = this._cache.slice(this._readOffset, this._readOffset + len);\n        } else {\n            const offset = this._cache.byteOffset + this._readOffset;\n            data = new Uint8Array(this._storage.slice(offset, offset + len));\n        }\n        this._readOffset += len;\n        return data;\n    }\n\n    /**\n     * Uint8Arraycache\n     * @param len \n     * @returns \n     */\n    public read(len: number): Uint8Array | null {\n        if (len + this._readOffset > this._writeOffset) {\n            return null;\n        }\n        return new Uint8Array(this._storage, this._readOffset, len);\n    }\n\n    /**\n     * \n     * @param len \n     */\n    public skip(len: number): void {\n        if (len + this._readOffset > this._writeOffset) {\n            return;\n        }\n        this._readOffset += len;\n    }\n\n    /**\n     * \n     */\n    public clear(): void {\n        this._readOffset = this._writeOffset = 0;\n    }\n\n    /**\n     * cachecachecachemax(,)\n     * @param expected \n     */\n    public expandCache(expected: number = 0): void {\n        this._size = Math.max(this._size * 2, expected);\n        if (this._size >= Cache.MAX_CACHE_SIZE) {\n            throw new Error('max cache size');\n        }\n        if (this._readOffset === 0 && this._writeOffset === 0) {\n            this._storage = new ArrayBuffer(this._size);\n        } else {\n            this._storage = this._transfer(this._storage, this._size);\n        }\n        this._cache = new Uint8Array(this._storage);\n    }\n\n    /**\n     * \n     */\n    public get unreadLen(): number {\n        return this._writeOffset - this._readOffset;\n    }\n\n    /**\n     * cache\n     */\n    private _collateCache(): void {\n        const remain = new Uint8Array(this._storage, this._readOffset, this._writeOffset - this._readOffset);\n        this._cache.set(remain);\n        this._writeOffset -= this._readOffset;\n        this._readOffset = 0;\n    }\n\n    private _transfer(source: ArrayBuffer, length: number): ArrayBuffer {\n        if (!(source instanceof ArrayBuffer)) {\n            throw new TypeError('Source must be an instance of ArrayBuffer');\n        }\n        if (length <= source.byteLength) {\n            return source.slice(0, length);\n        }\n        const sourceView = new Uint8Array(source),\n            destView = new Uint8Array(new ArrayBuffer(length));\n        destView.set(sourceView);\n        return destView.buffer;\n    }\n}\n\nexport default Cache;\n","import { IBaseLoader, ILoaderContext, IBaseLoaderCallback } from '../types/io';\nexport enum XHR_TYPE {\n    MOZ_CHUNK = 'moz-chunked-arraybuffer',\n    MS_STREAM = 'ms-stream',\n    UNKNOW = 'unknow',\n    UNSUPPORT = ''\n}\n\n/**\n * XhrLoader\n * @class XhrLoader\n */\nexport class XHR implements IBaseLoader<ILoaderContext> {\n    private static supportChunk: XHR_TYPE = XHR_TYPE.UNKNOW;\n\n    public tag: string = 'xhr';\n    private _xhr: XMLHttpRequest | null = null;\n    private _context!: ILoaderContext;\n    private _callbacks: IBaseLoaderCallback<ILoaderContext> | null = null;\n    private _reader: MSStreamReader | null = null;\n    private _msBufferOffset: number = 0;\n    private _msBufferUpper: number = 16 * 1024 * 1024; // 16MB\n    private _progress: XHR_TYPE = XHR_TYPE.UNKNOW;\n\n    static isSupportChunk() {\n        if (XHR.supportChunk !== XHR_TYPE.UNKNOW) {\n            return XHR.supportChunk;\n        }\n        try {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            (xhr.responseType as any) = XHR_TYPE.MOZ_CHUNK;\n            if ((xhr.responseType as any) === XHR_TYPE.MOZ_CHUNK) {\n                XHR.supportChunk = XHR_TYPE.MOZ_CHUNK;\n                return XHR.supportChunk;\n            }\n        } catch (e) {\n            XHR.supportChunk = XHR_TYPE.UNSUPPORT;\n        }\n        try {\n            const xhr = new XMLHttpRequest();\n            xhr.open('GET', 'https://example.com', true);\n            (xhr.responseType as any) = XHR_TYPE.MS_STREAM;\n            if ((xhr.responseType as any) === XHR_TYPE.MS_STREAM) {\n                XHR.supportChunk = XHR_TYPE.MS_STREAM;\n                return XHR.supportChunk;\n            }\n        } catch (e) {\n            XHR.supportChunk = XHR_TYPE.UNSUPPORT;\n        }\n        return XHR_TYPE.UNSUPPORT;\n    }\n\n    constructor() {\n        this._xhr = null;\n        this._msBufferOffset = 0;\n    }\n\n    /**\n     * \n     * @param context\n     * @param callbacks\n     */\n    load(context: ILoaderContext, callbacks: IBaseLoaderCallback<ILoaderContext>) {\n        this._callbacks = callbacks;\n        this._context = context;\n        this._progress = XHR_TYPE.UNSUPPORT;\n        if (context.progress && context.responseType === 'arraybuffer') {\n            this._progress = XHR.isSupportChunk();\n            if (this._progress === XHR_TYPE.MS_STREAM) {\n                const reader = this._reader = new (self as any).MSStreamReader();\n                reader.onprogress = this._msrOnProgress.bind(this);\n                reader.onload = this._onLoadEnd.bind(this);\n                reader.onerror = this._onError.bind(this);\n            }\n        }\n\n        const xhr = this._xhr = new XMLHttpRequest();\n        xhr.open('GET', this._context.url, true);\n        // arraybufferchunk\n        if (this._progress === XHR_TYPE.MOZ_CHUNK) {\n            (xhr.responseType as any) = XHR_TYPE.MOZ_CHUNK;\n            xhr.onprogress = this._onProgress.bind(this);\n            xhr.onload = this._onLoadEnd.bind(this);\n        } else if (this._progress === XHR_TYPE.MS_STREAM) {\n            (xhr.responseType as any) = XHR_TYPE.MS_STREAM;\n        } else {\n            (xhr.responseType as any) = context.responseType || 'arraybuffer';\n            xhr.onload = this._onLoadEnd.bind(this);\n        }\n        xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n        xhr.onerror = this._onError.bind(this);\n        xhr.withCredentials = !!context.credentials;\n\n        if (context.range) {\n            xhr.setRequestHeader('Range', context.range);\n        }\n        xhr.send();\n    }\n\n    /**\n     * abort request\n     */\n    abort() {\n        if (this._reader) {\n            // 0 EMPTY 1 LOADING 2 DONE\n            if (this._reader.readyState === 1) {\n                this._reader.abort();\n            }\n            this._reader.onprogress = null;\n            this._reader.onload = null;\n            this._reader.onerror = null;\n            this._reader = null;\n        }\n        if (this._xhr) {\n            this._xhr.onreadystatechange = null;\n            this._xhr.onprogress = null;\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr.abort();\n            this._xhr = null;\n        }\n    }\n\n    /**\n     * destroy xhr Object clean cache\n     */\n    destroy() {\n        this._callbacks = null;\n        this.abort();\n    }\n\n    _onReadyStateChange(e: Event) {\n        if (!this._xhr) {\n            return;\n        }\n        const xhr = this._xhr;\n        if (xhr.readyState === 2) {\n            this._context.responseUrl = xhr.responseURL;\n            this._context.responseHeader = xhr.getAllResponseHeaders();\n            if (this._callbacks && this._callbacks.onConnect) {\n                this._callbacks.onConnect(xhr.status);\n            }\n            if (xhr.status < 200 || xhr.status > 299) {\n                this._onError(new Error('xhr error'));\n            }\n        } else if (xhr.readyState === 3) {\n            if (this._reader && this._reader.readyState === 0 && xhr.status >= 200 && xhr.status <= 299) {\n                this._reader.readAsArrayBuffer(xhr.response);\n            }\n        }\n    }\n\n    /**\n     * xhr onProgress\n     * @param {*} e xhr\n     */\n    _onProgress(e: Event) {\n        if (!this._xhr) {\n            return;\n        }\n        const chunk = this._xhr.response;\n        if (this._callbacks && this._callbacks.onProgress && chunk) {\n            this._callbacks.onProgress(this._context, chunk);\n        }\n    }\n\n    /**\n     * ms-stream progress\n     * @param {*} e MSStreamReader\n     */\n    _msrOnProgress(e: any) {\n        const reader = e.target;\n        const buffer = reader.result;\n        if (!buffer) {\n            // result may be null, workaround for buggy M$\n            this._onError(new Error('ms buffer null'));\n            return;\n        }\n\n        const chunk = buffer.slice(this._msBufferOffset);\n        this._msBufferOffset = buffer.byteLength;\n\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(this._context, chunk);\n        }\n\n        if (buffer.byteLength >= this._msBufferUpper) {\n            this._onError(new Error('ms buffer too large'));\n        }\n    }\n\n    /**\n     * xhr onLoadEnd\n     * @param {*} e xhr\n     */\n    _onLoadEnd(e: ProgressEvent) {\n        let data = null;\n        const target = this._xhr;\n        if (!this._progress && target) {\n            data = target.response;\n        }\n        if (this._callbacks) {\n            this._callbacks.onEnd(this._context, data);\n        }\n    }\n\n    /**\n     * xhr onXhrError\n     * @param {*} e xhr\n     * @private\n     */\n    _onError(e: any) {\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(e);\n        }\n    }\n}\n","import { ErrorDetails, ErrorTypes } from '../../core/errors';\nimport LasEvents from '../../core/events';\nimport Observer from '../../core/observer';\nimport Cache from '../../io/cache';\nimport { FlvSize, FlvTag, FlvTagType } from \"./flv\";\n\nexport type AbrCallback = (time: number) => any;\n\ntype Result = {\n    list: FlvTag[];\n    abr?: any;\n}\n\nclass FlvTagDump {\n    private _observer: Observer;\n    private _cache: Cache;\n    private _tag?: FlvTag;\n    private _result: Result;\n\n    private _parseLen: number = 0;\n    private _parseFunc: Function;\n    private _onAbr: AbrCallback;\n\n    constructor(observer: Observer, onAbr: AbrCallback) {\n        this._observer = observer;\n        this._onAbr = onAbr;\n        this._cache = new Cache();\n        this._parseLen = FlvSize.FLV_HEAD_LEN;\n        this._parseFunc = this._parseFlvHead;\n        this._result = { list: [] };\n    }\n\n    public reset(): void {\n        this._parseLen = FlvSize.FLV_HEAD_LEN;\n        this._parseFunc = this._parseFlvHead;\n        this._cache.clear();\n        this._tag = undefined;\n        this._result.list = [];\n        this._result.abr = undefined;\n    }\n\n    public append(input: ArrayBuffer): Result {\n        this._cache.put(new Uint8Array(input));\n        while (this._cache.unreadLen > this._parseLen) {\n            this._parseFunc();\n        }\n        let data = { list: this._result.list.splice(0), abr: this._result.abr }\n        this._result.abr = undefined;\n        return data;\n    }\n\n    /**\n     * tag\n     */\n    private _parseFlvHead(): void {\n        const data = this._cache.read(FlvSize.FLV_HEAD_LEN);\n        if (data) {\n            if (data[0] !== 0x46 || data[1] !== 0x4c || data[2] !== 0x56 || data[3] !== 0x01) {\n                this._observer.trigger(LasEvents.ERROR, {\n                    type: ErrorTypes.MUX_ERROR,\n                    details: ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'Flv: wrong head'\n                });\n            }\n            this._observer.trigger(LasEvents.FLV_HEAD, {\n                hasAudio: (data[4] & 4) >>> 2,\n                hasVideo: (data[4] & 1)\n            });\n            // TEST:\n            // this._observer.trigger(KEvents.FLV_HEAD, {\n            //     hasAudio: true,\n            //     hasVideo: true\n            // });\n\n            this._cache.skip(FlvSize.FLV_HEAD_LEN);\n            this._parseLen = FlvSize.FLV_TAG_HEAD_LEN;\n            this._parseFunc = this._parseFlvTagHead;\n        }\n    }\n\n    /**\n     * flv tag head\n     */\n    private _parseFlvTagHead(): void {\n        this._tag = new FlvTag();\n        const data = this._cache.read(FlvSize.FLV_TAG_HEAD_LEN);\n        if (data) {\n            // tag\n            this._tag.tagType = data[0];\n            // \n            this._tag.dataSize = ((data[1] & 0xff) << 16) + ((data[2] & 0xff) << 8) + (data[3] & 0xff);\n            // \n            this._tag.timestamp =\n                ((data[7] & 0xff) << 24) + ((data[4] & 0xff) << 16) + ((data[5] & 0xff) << 8) + (data[6] & 0xff);\n            this._cache.skip(FlvSize.FLV_TAG_HEAD_LEN);\n            // tag\n            if (this._tag.tagType === FlvTagType.VIDEO) {\n                this._parseFunc = this._detectKeyFrame;\n                this._parseLen = FlvSize.AVC_KEY_FRAME_CHECK_LEN;\n            } else {\n                this._parseFunc = this._parseFlvTag;\n                this._parseLen = this._tag.dataSize + FlvSize.FLV_TAG_SIZE_LEN;\n            }\n        }\n    }\n\n    /**\n     * \n     */\n    private _detectKeyFrame(): void {\n        const data = this._cache.read(2);\n        if (data && this._tag) {\n            const frameType = (data[0] & 240) >>> 4;\n            const packetType = data[1];\n            this._parseFunc = this._parseFlvTag;\n            this._parseLen = this._tag.dataSize + FlvSize.FLV_TAG_SIZE_LEN;\n            // \n            if (frameType === 1 && packetType === 1 && this._onAbr) {\n                this._result.abr = this._onAbr(this._tag.timestamp);\n                if (this._result.abr) {\n                    this._parseLen = FlvSize.FLV_HEAD_LEN;\n                    this._parseFunc = this._parseFlvHead;\n                    this._cache.clear();\n                    this._tag = undefined;\n                }\n            }\n        }\n    }\n\n    /**\n     * flv tag\n     */\n    private _parseFlvTag(): void {\n        const tag = this._tag;\n        if (!tag) {\n            return;\n        }\n        if (tag.tagType === FlvTagType.SCRIPT || tag.tagType === FlvTagType.AUDIO || tag.tagType === FlvTagType.VIDEO) {\n            tag.body = this._cache.get(tag.dataSize);\n            this._cache.skip(4); // skip size\n            if (tag)\n                this._result.list.push(tag);\n            this._tag = undefined;\n        }\n        this._parseFunc = this._parseFlvTagHead;\n        this._parseLen = FlvSize.FLV_TAG_HEAD_LEN;\n    }\n}\n\nexport default FlvTagDump;\n","import { IBaseLoader, ILoaderContext, IBaseLoaderCallback } from '../types/io';\n/**\n * FetchLoader\n */\nexport default class FetchLoader implements IBaseLoader<ILoaderContext> {\n    public tag: string = 'fetch';\n    private _context!: ILoaderContext;\n    private _callbacks: IBaseLoaderCallback<ILoaderContext> | null = null;\n    private _controller: AbortController | null = null;\n    private _reader: ReadableStreamReader | null = null;\n    private _abort: boolean = false;\n\n    /**\n     * broswer is support moz-chunk\n     * @returns \n     */\n    static isSupport(): boolean {\n        if (self.fetch && self.ReadableStream) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * \n     * @param context context\n     * @param callbacks \n     */\n    load(context: ILoaderContext, callbacks: IBaseLoaderCallback<ILoaderContext>) {\n        this._context = context;\n        this._callbacks = callbacks;\n\n        const reqHeaders = new Headers();\n        if (context.headers) {\n            context.headers.forEach(element => {\n                reqHeaders.append(element.header, element.value);\n            });\n        }\n        if (context.range) {\n            reqHeaders.append('Range', context.range);\n        }\n        const params: RequestInit = {\n            method: 'GET',\n            headers: reqHeaders,\n            mode: 'cors',\n            cache: 'default',\n            referrerPolicy: 'no-referrer-when-downgrade',\n            signal: this._getAbortSignal()\n        };\n        if (context.credentials) {\n            params.credentials = 'include';\n        }\n        fetch(context.url, params)\n            .then(res => {\n                context.responseUrl = res.url;\n                context.responseHeader = res.headers;\n                if (this._callbacks && this._callbacks.onConnect) {\n                    this._callbacks.onConnect(res.status);\n                }\n                if (res.ok) {\n                    // AbortController\n                    if (this._abort) {\n                        if (res.body) {\n                            res.body.getReader().cancel();\n                        }\n                        return;\n                    }\n                    if (context.responseType === 'arraybuffer') {\n                        if (context.progress) {\n                            if (res.body) {\n                                this._reader = res.body.getReader();\n                                this._pump(this._reader);\n                            }\n                            return;\n                        }\n                        res.arrayBuffer().then(responseData => {\n                            this._onEnd(context, responseData);\n                        });\n                        return;\n                    }\n                    res.text().then(responseData => {\n                        this._onEnd(context, responseData);\n                    });\n                    return;\n                }\n                const error = new Error(res.status + ' ' + res.statusText);\n                this._onError(error);\n                return;\n            })\n            .catch(e => {\n                // AbortErrortimeoutabort\n                if (e.name !== 'AbortError') {\n                    this._onError(e);\n                }\n            });\n    }\n\n    abort() {\n        if (this._controller) {\n            this._controller.abort();\n        } else if (this._reader) {\n            this._reader.cancel();\n            this._reader = null;\n        }\n        this._abort = true;\n    }\n\n    destroy() {\n        this._callbacks = null;\n        this.abort();\n    }\n\n    _onProgress(context: ILoaderContext, chunk: ArrayBuffer) {\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(context, chunk);\n        }\n    }\n\n    _onEnd(context: ILoaderContext, responseData: ArrayBuffer | string | null) {\n        if (this._callbacks && this._callbacks.onEnd) {\n            this._reader = null;\n            this._controller = null;\n            this._callbacks.onEnd(context, responseData);\n        }\n    }\n\n    _onError(e: Error) {\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(e);\n        }\n    }\n\n    /**\n     * pump data\n     * @param reader \n     * @private\n     */\n    _pump(reader: ReadableStreamReader) {\n        reader\n            .read()\n            .then(result => {\n                if (this._abort) {\n                    reader.cancel();\n                    return null;\n                }\n                if (result.done) {\n                    this._onEnd(this._context, null);\n                    return null;\n                }\n                const chunk = result.value.buffer;\n                this._onProgress(this._context, chunk);\n                return this._pump(reader);\n            })\n            .catch((e: Error) => {\n                if (e.name !== 'AbortError') {\n                    this._onError(e);\n                }\n            });\n    }\n\n    _getAbortSignal(): AbortSignal | null {\n        try {\n            if (AbortController) {\n                this._controller = new AbortController();\n                return this._controller.signal;\n            }\n        } catch (e) {\n            return null;\n        }\n        return null;\n    }\n}\n","import Browser from '../utils/browser';\nimport FetchLoader from './fetch';\nimport { XHR } from './xhr';\nimport { Log } from '../utils/log';\nimport {\n    IBaseLoader,\n    ILoaderContext,\n    IBaseLoaderCallback,\n    ILoaderCallback,\n    ILoaderStats,\n    ILoaderConfig,\n    ILoader\n} from '../types/io';\n\nlet ChunkLoader: any;\nlet index: number = 0;\n/**\n * \n * @param  {object} video config\n */\nexport default class Loader<T extends ILoaderContext> implements ILoader<T> {\n    public tag: string = 'loader';\n    public context!: T;\n    private _loader: IBaseLoader<T> | null;\n    protected _callbacks: ILoaderCallback<T> | null = null;\n    protected _config: ILoaderConfig;\n    private _loaderCallback!: IBaseLoaderCallback<T>;\n    protected _stats!: ILoaderStats;\n    protected _retryDelay: number = 0;\n    private _loading: boolean = false;\n    private _aborted: boolean = false;\n    private _requestTimeout: any;\n    private _transTimer: any;\n    private _retryTimeout: any;\n    protected _rangeStart?: number;\n    private _continuedTransmissionRetry: boolean = false;\n    private _progressTime: number = 0;\n\n    /**\n     * Loader\n     * @param useFetch fetch\n     * @returns class\n     */\n    _getInternalLoader(useFetch: boolean) {\n        if (typeof ChunkLoader !== 'undefined') {\n            return ChunkLoader;\n        }\n        ChunkLoader = null;\n        // msxhrfetch\n        if (Browser.msie || Browser.msedge) {\n            if (useFetch) {\n                if (FetchLoader.isSupport()) {\n                    ChunkLoader = FetchLoader;\n                }\n                return ChunkLoader;\n            }\n            if (XHR.isSupportChunk()) {\n                ChunkLoader = XHR;\n            } else if (FetchLoader.isSupport()) {\n                ChunkLoader = FetchLoader;\n            }\n        } else if (FetchLoader.isSupport()) {\n            ChunkLoader = FetchLoader;\n        } else if (XHR.isSupportChunk()) {\n            ChunkLoader = XHR;\n        }\n        return ChunkLoader;\n    }\n\n    constructor() {\n        this.tag = 'loader';\n        index++;\n        this._loader = null;\n        this._config = {\n            useFetch: false,\n            connectionTimeout: 0,\n            transmissionTimeout: 0,\n            maxRetry: 0,\n            retryDelay: 0\n        };\n        this._loaderCallback = {\n            onConnect: this._onConnect.bind(this),\n            onProgress: this._onProgress.bind(this),\n            onEnd: this._onEnd.bind(this),\n            onError: this._onError.bind(this)\n        };\n    }\n\n    load(context: T, callbacks: ILoaderCallback<T>, config: ILoaderConfig) {\n        this._init(context, callbacks, config);\n        this._loadInternal();\n    }\n\n    /**\n     * destory\n     */\n    destroy() {\n        this._stopTimer();\n        this._abortInternal();\n        this._destroyLoader();\n        this._callbacks = null;\n    }\n\n    _init(context: T, callbacks: ILoaderCallback<T>, config: ILoaderConfig) {\n        this.context = context;\n        this._rangeStart = context.rangeStart\n        this._callbacks = callbacks;\n        this._config = config || this._config;\n\n        this._stats = {\n            id: '',\n            trequest: performance.now(),\n            retry: 0,\n            loaded: 0,\n            code: 0,\n            output: 0,\n            tfirst: 0,\n            tload: 0,\n            total: 0,\n            tsload: 0,\n            tstart: 0,\n            fatal: false,\n            text: ''\n        };\n        if (this._config.retryDelay) {\n            this._retryDelay = this._config.retryDelay;\n        }\n    }\n\n    /**\n     * loader\n     */\n    _destroyLoader() {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n    }\n\n    /**\n     * xhr\n     */\n    _loadInternal() {\n        this._loading = true;\n        this._aborted = false;\n        const stats = this._stats;\n        stats.code = 0;\n        stats.tfirst = 0;\n        stats.loaded = 0;\n        if (this._retryTimeout) {\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n        }\n        if (this.context.progress) {\n            this._loader = new (this._getInternalLoader(!!this._config.useFetch))();\n        } else {\n            this._loader = new XHR();\n        }\n        if (!this._loader) {\n            return;\n        }\n        stats.id = `${this._loader.tag}-${index}`;\n        // \n        if (this._config.connectionTimeout) {\n            this._requestTimeout = setTimeout(this._onTimeout.bind(this), this._config.connectionTimeout);\n        }\n        if (this.context.rangeEnd) {\n            this.context.range = 'bytes=' + this.context.rangeStart + '-' + (this.context.rangeEnd - 1);\n        } else if (this.context.rangeStart) {\n            this.context.range = 'bytes=' + this.context.rangeStart + '-';\n        }\n        stats.tsload = Date.now();\n        stats.tstart = performance.now();\n        this._loader.load(this.context, this._loaderCallback);\n    }\n\n    _abortInternal() {\n        if (this._callbacks && this._callbacks.onAbort && !this._aborted && this._loading) {\n            this._callbacks.onAbort(this.context, this._stats);\n        }\n        this._aborted = true;\n        if (this._loader) {\n            this._loader.abort();\n        }\n    }\n\n    abort() {\n        this._stopTimer();\n        this._abortInternal();\n    }\n\n    /**\n     * \n     * \n     */\n    _stopTimer() {\n        if (this._requestTimeout) {\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n        }\n        if (this._retryTimeout) {\n            clearTimeout(this._retryTimeout);\n            this._retryTimeout = null;\n        }\n        this._stopTransmissionTimer();\n    }\n\n    _onConnect(status: number) {\n        if (this._requestTimeout) {\n            clearTimeout(this._requestTimeout);\n            this._requestTimeout = null;\n        }\n        this._startTransmissionTimer();\n        this._stats.code = status;\n        this._stats.tfirst = Math.max(this._stats.trequest, performance.now());\n    }\n    _onProgress(context: T, chunk: ArrayBuffer) {\n        const stats = this._stats;\n        this._progressTime = performance.now();\n        // rangerange\n        if (!this._continuedTransmissionRetry && stats.output > stats.loaded) {\n            const size = stats.loaded + chunk.byteLength - stats.output;\n            if (size > 0) {\n                const tmp = chunk.slice(stats.output - stats.loaded);\n                this._callProgress(this.context, tmp, stats);\n            }\n        } else {\n            this._callProgress(this.context, chunk, stats);\n        }\n        stats.loaded += chunk.byteLength;\n    }\n    _callProgress(context: T, chunk: ArrayBuffer, stats: ILoaderStats) {\n        this._stats.output += chunk.byteLength;\n        if (this._callbacks && this._callbacks.onProgress) {\n            this._callbacks.onProgress(context, chunk, stats);\n        }\n    }\n    _onEnd(context: T, responseData: string | ArrayBuffer | null) {\n        this._stopTimer();\n        const stats = this._stats;\n        if (responseData) {\n            if (typeof responseData === 'string') {\n                stats.total = stats.loaded = responseData.length || 0;\n            } else {\n                stats.total = stats.loaded = responseData.byteLength || 0;\n            }\n        } else {\n            stats.total = stats.loaded;\n        }\n        stats.tload = Math.max(stats.tfirst, performance.now());\n        this._loading = false;\n        stats.output = 0;\n        if (this._callbacks) {\n            this._callbacks.onEnd(context, responseData, stats);\n        }\n    }\n\n    _onError(e: Error) {\n        Log.i(this.tag, e);\n        this._stopTimer();\n        this._destroyLoader();\n        const stats = this._stats;\n        const config = this._config;\n        this._loading = false;\n\n        stats.fatal = !config.maxRetry || (stats.retry >= config.maxRetry || !config.maxRetry);\n        stats.text = e.message || 'load error';\n        if (this._callbacks && this._callbacks.onError) {\n            this._callbacks.onError(this.context, stats);\n        }\n        if (stats.fatal) {\n            return;\n        }\n        // range\n        if (this._stats.output && this._stats.loaded > 0) {\n            if (this._rangeStart) {\n                this.context.rangeStart = this._rangeStart + this._stats.output;\n            } else {\n                this.context.rangeStart = this._stats.output;\n            }\n            this._continuedTransmissionRetry = true;\n        } else {\n            this.context.rangeStart = this._rangeStart;\n            this._continuedTransmissionRetry = false;\n        }\n        stats.retry++;\n        if (this._callbacks) {\n            if (this._retryDelay) {\n                this._retryTimeout = setTimeout(this._loadInternal.bind(this), this._retryDelay);\n                this._retryDelay = 2 * this._retryDelay;\n            } else {\n                this._loadInternal();\n            }\n        }\n    }\n\n    _onTimeout() {\n        this._loading = false;\n        this._abortInternal();\n        const e = new Error('timeout');\n        this._onError(e);\n    }\n\n    // \n    _startTransmissionTimer() {\n        this._stopTransmissionTimer();\n        this._progressTime = performance.now();\n        let timeout = this._config.transmissionTimeout || 0;\n        if (timeout) {\n            this._transTimer = setInterval(() => {\n                if (performance.now() - this._progressTime > timeout) {\n                    this._onTimeout();\n                }\n            }, 1000);\n        }\n    }\n\n    _stopTransmissionTimer() {\n        if (this._transTimer) {\n            clearInterval(this._transTimer);\n            this._transTimer = null;\n        }\n    }\n}\n","export const REPORT_TYPES = {\n    START_LOAD_STREAM: 'startLoadStream',\n    LOADER_CHUNK_ARRIVAL: 'loader-chunk-arrival',\n    KEY_FRAME: 'keyFrame',\n};\n","import work from 'webworkify-webpack';\nimport { abrGetUrl } from '../abr/abr-get-url';\nimport { AbrManifest } from '../abr/abr-manifest';\nimport Multirate, { MultirateItem } from '../abr/multirate';\nimport { FlvTag } from '../demux/flv/flv';\nimport FlvDemuxerInline from '../demux/flv/flv-demuxer-inline';\nimport FlvTagDump from '../demux/flv/flv-tag-dump';\nimport Loader from '../io/loader';\nimport { FLVTransConfig } from '../types/core';\nimport { ILoaderCallback, ILoaderConfig, ILoaderContext, ILoaderStats } from '../types/io';\nimport { Log } from '../utils/log';\nimport { ErrorDetails, ErrorTypes } from './errors';\nimport LasEvents from './events';\nimport Media from './media';\nimport Observer from './observer';\nimport { REPORT_TYPES } from './report-types';\n\n/**\n * TransFLV\n * @class TransFLV\n * @param {object} config \n */\nconst tag = 'TransFLV';\nexport default class TransFLV extends Observer {\n    private _config: FLVTransConfig;\n    private _media: Media;\n    private _w?: Worker;\n    private _flv?: FlvDemuxerInline;\n    private _observer: Observer;\n\n    private _loader: Loader<ILoaderContext> | null = null;\n    private _loaderConf: ILoaderConfig;\n    private _loaderCallbacks: ILoaderCallback<ILoaderContext>;\n    private _multirate?: Multirate;\n    private _contiguous: boolean;\n    private _remuxId: number;\n    private _discontinuity: boolean = false;\n    private _accurateTimeOffset: boolean = false;\n    private _baseTimeSec: number = 0;\n    private _tagDump: FlvTagDump;\n    private _currentUrl?: any;\n    private _lastDTS: number = 0;\n    private _isAbr: boolean = false;\n    private _progressTime: number = 0;\n\n    constructor(config: FLVTransConfig, media: Media) {\n        super();\n        this._config = config;\n        this._media = media;\n\n        if (config.manifest) {\n            if (AbrManifest.verify(config.manifest)) {\n                this._isAbr = true;\n            } else {\n                config.hasVideo = config.manifest.hasVideo;\n                config.hasAudio = config.manifest.hasAudio;\n            }\n        }\n\n        this._loaderConf = {\n            connectionTimeout: this._config.connectionTimeout,\n            transmissionTimeout: this._config.transmissionTimeout,\n            maxRetry: 0,\n            retryDelay: 0,\n            useFetch: true\n        };\n        this._loaderCallbacks = {\n            onProgress: this._onProgress.bind(this),\n            onError: this._onLoaderError.bind(this),\n            onEnd: this._onLoaderEnd.bind(this),\n            onAbort: this._onAbort.bind(this)\n        };\n        this._contiguous = false;\n        this._remuxId = 1;\n\n        const observer = (this._observer = new Observer());\n        const onMessage = this._onMessage;\n        observer.on(LasEvents.PARSING_INIT_SEGMENT, onMessage);\n        observer.on(LasEvents.PARSING_DATA, onMessage);\n        observer.on(LasEvents.ERROR, onMessage);\n        observer.on(LasEvents.SCRIPT_PARSED, onMessage);\n        observer.on(LasEvents.DISCONTINUITY, onMessage);\n        observer.on(LasEvents.FLV_HEAD, onMessage);\n\n        this._tagDump = new FlvTagDump(observer, this._onKeyframe);\n\n        if (this._config.webWorker) {\n            Log.i(tag, 'webWorker');\n            this._onWorkMessage = this._onWorkMessage.bind(this);\n            this._w = work(require.resolve('../demux/flv/flv-demuxer-worker'));\n            if (this._w) {\n                this._w.addEventListener('message', this._onWorkMessage);\n                this._w.postMessage({\n                    cmd: 'init',\n                    config: this._config,\n                    data: { remuxId: this._remuxId },\n                    vendor: navigator.vendor\n                });\n                return;\n            }\n        }\n        this._flv = new FlvDemuxerInline(observer, this._config, { remuxId: this._remuxId }, navigator.vendor);\n        this._flv.init();\n    }\n\n    public init(): void {\n        if (this._isAbr && !this._multirate) {\n            this._multirate = new Multirate(this._config, this._media);\n            this._multirate.on(LasEvents.MANIFEST_PARSED, this._onMessage);\n            this._multirate.init();\n        }\n    }\n\n    private _onWorkMessage(ev: any) {\n        const data = ev.data;\n        if (ev.data.event === LasEvents.PARSING_DATA) {\n            data.data.payload = data.payload;\n        }\n        this._onMessage(ev.data.event, data.data);\n    }\n\n    private _onKeyframe = (timestamp: number): MultirateItem | undefined => {\n        if (this._multirate) {\n            let result = this._multirate.onKeyFrame(timestamp);\n            if (result) {\n                if (this._tagDump) {\n                    this._tagDump.reset();\n                }\n                // \n                let info = Object.assign({}, result);\n                this._baseTimeSec = this._lastDTS;\n                this.emit(LasEvents.LEVEL_SWITCHING, { level: info.level, startSec: this._baseTimeSec, smooth: true });\n                this._media.updateStreamTime(0, 0);\n                return info;\n            }\n        }\n        return;\n    }\n\n    /**\n     * instance ioloader\n     */\n    public loadSource(): void {\n        let mr = this._multirate;\n        if (mr) {\n            let data = mr.levels[mr.currentLevel];\n            if (data) {\n                this._load(abrGetUrl(data.url, this._config.defaultSpts), mr.currentLevel);\n            } else {\n                this.emit(LasEvents.ERROR, {\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.PARSING_ERROR,\n                    fatal: true,\n                    reason: 'manifest parse error'\n                });\n            }\n        } else {\n            this._load(this._config.src);\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n        if (this._w) {\n            this._w.postMessage({ cmd: 'destroy' });\n            this._w.removeEventListener('message', this._onWorkMessage);\n            this._w.terminate();\n        }\n        if (this._flv) {\n            this._flv.destroy();\n            this._flv = undefined;\n        }\n\n        if (this._multirate) {\n            this._multirate.removeAllListeners();\n            this._multirate.destory();\n        }\n\n        const observer = this._observer;\n        if (observer) {\n            observer.removeAllListeners();\n        }\n    }\n\n    public get autoLevelEnabled(): boolean {\n        if (this._multirate) {\n            return this._multirate.autoLevelEnabled;\n        }\n        return false;\n    }\n\n    public get levels() {\n        if (this._multirate) {\n            return this._multirate.levels;\n        }\n        return [];\n    }\n\n    public get nextLevel(): number {\n        if (this._multirate) {\n            return this._multirate.nextLevel;\n        }\n        return 0;\n    }\n\n    public set nextLevel(value: number) {\n        const mr = this._multirate;\n        if (mr) {\n            mr.nextLevel = value;\n        }\n    }\n\n    public get currentLevel(): number {\n        if (this._multirate) {\n            return this._multirate.currentLevel;\n        }\n        return 0;\n    }\n\n    public set currentLevel(value: number) {\n        const mr = this._multirate;\n        if (mr) {\n            let load = value >= 0 || value !== mr.currentLevel;\n            mr.currentLevel = value;\n            const data = mr.levels[mr.currentLevel];\n            if (load && data) {\n                this._currentUrl = abrGetUrl(data.url, this._config.defaultSpts);\n                this._refreshRemuxId();\n                this._contiguous = false;\n                this._discontinuity = true;\n                this._accurateTimeOffset = false;\n                if (this._tagDump) {\n                    this._tagDump.reset();\n                }\n                this._baseTimeSec = this._media.currentTime;\n                this.emit(LasEvents.LEVEL_SWITCHING, { level: mr.currentLevel, startSec: this._baseTimeSec, smooth: false });\n                this._load(this._currentUrl, mr.currentLevel);\n            }\n        }\n    }\n\n\n    private _onMessage = (ev: string, data: any): void => {\n        switch (ev) {\n            case LasEvents.FLV_HEAD:\n                if (this._w) {\n                    this._w.postMessage({ cmd: 'flvHead', hasAudio: data.hasAudio, hasVideo: data.hasVideo });\n                } else if (this._flv) {\n                    this._flv.flvHead(data.hasAudio, data.hasVideo);\n                }\n                break;\n            case LasEvents.PARSING_INIT_SEGMENT:\n                this.emit(LasEvents.PARSING_INIT_SEGMENT, data);\n                break;\n            case LasEvents.PARSING_DATA:\n                {\n                    if (data.extra && data.extra.remuxId !== this._remuxId) {\n                        // \n                        break;\n                    }\n                    if (data.type === 'audio' && data.startDTS > this._baseTimeSec) {\n                        this._media.updateStreamTime(data.streamDTS, data.startDTS);\n                    }\n                    this._lastDTS = data.startDTS;\n                    this.emit(LasEvents.PARSING_DATA, {\n                        data: data.payload,\n                        type: data.type,\n                        startDTS: data.startDTS || 0,\n                        endDTS: data.endDTS || 0,\n                        startPTS: data.startPTS || 0,\n                        endPTS: data.endPTS || 0,\n                        duration: data.endDTS - data.startDTS,\n                        framesInfo: data.framesInfo\n                    });\n                }\n                break;\n            case LasEvents.DISCONTINUITY:\n                if (this._w) {\n                    this._w.postMessage({ cmd: 'flush' });\n                } else if (this._flv) {\n                    this._flv.flush();\n                }\n                this._tagDump.reset();\n                this._discontinuity = true;\n                this._accurateTimeOffset = false;\n                this._contiguous = false;\n                this._baseTimeSec = data;\n                break;\n            default:\n                // LOST_FRAMES SCRIPT_PARSED REPORT ERROR END\n                this.emit(ev, data);\n                break;\n        }\n    }\n\n    private _load(url: string, index: number = 0): void {\n        if (this._loader) {\n            this._loader.destroy();\n            this._loader = null;\n        }\n        if (this._multirate) {\n            this._multirate.onLevelLoad(index);\n        }\n        this._currentUrl = url;\n        let level = this.levels[index]\n        this.emit(LasEvents.REPORT, {\n            type: REPORT_TYPES.START_LOAD_STREAM,\n            url,\n            sync: this._baseTimeSec,\n            index: index,\n            bitrate: level ? level.bitrate : 0\n        });\n        if (!this._loader) {\n            this._loader = new Loader();\n        }\n        const context = {\n            url,\n            progress: true,\n            responseType: 'arraybuffer',\n            credentials: this._config.credentials\n        };\n        if (this._loader instanceof Loader) {\n            this._loader.load(context, this._loaderCallbacks, this._loaderConf);\n        }\n    }\n\n    private _append(\n        tags: FlvTag[],\n        timeOffset: number,\n        discontinuity: boolean,\n        contiguous: boolean,\n        accurateTimeOffset: boolean\n    ): void {\n        if (this._w) {\n            this._w.postMessage({\n                cmd: 'append',\n                tags,\n                timeOffset: timeOffset || 0,\n                discontinuity,\n                contiguous,\n                accurateTimeOffset\n            });\n        } else if (this._flv) {\n            this._flv.append(tags, timeOffset || 0, discontinuity, contiguous, accurateTimeOffset);\n        }\n    }\n\n    private _onProgress(context: ILoaderContext, data: string | ArrayBuffer, stats: ILoaderStats): void {\n        if (!(data instanceof ArrayBuffer)) {\n            return;\n        }\n        if (this._multirate) {\n            this._multirate.onLoaderChunk(data.byteLength);\n        }\n        this.emit(LasEvents.REPORT, {\n            type: REPORT_TYPES.LOADER_CHUNK_ARRIVAL,\n            byteLength: data.byteLength,\n            timeCost: performance.now() - this._progressTime || stats.trequest,\n            header: context.responseHeader\n        });\n        this._progressTime = performance.now();\n        const result = this._tagDump.append(data);\n        this._append(result.list, this._baseTimeSec, this._discontinuity, this._contiguous, this._accurateTimeOffset);\n        this._accurateTimeOffset = true;\n        this._contiguous = true;\n        this._discontinuity = false;\n\n        // \n        if (result.abr) {\n            this._load(result.abr.url, result.abr.level);\n        }\n    }\n\n    private _onAbort(): void { }\n\n    private _onLoaderError(context: ILoaderContext, status: ILoaderStats): void {\n        if (!status.fatal) {\n            return;\n        }\n        const errInfo = {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.LOAD_ERROR,\n            fatal: true,\n            reason: status.text,\n            statusCode: status.code,\n            url: context.url\n        };\n        this.emit(LasEvents.ERROR, errInfo);\n    }\n\n    private _onLoaderEnd(): void {\n        if (this._w) {\n            this._w.postMessage({ cmd: 'end' });\n        } else if (this._flv) {\n            this._flv.end();\n        }\n    }\n\n    private _refreshRemuxId(): void {\n        this._remuxId++;\n        const data = { remuxId: this._remuxId };\n        if (this._w) {\n            this._w.postMessage({ cmd: 'setExtra', data: data });\n        } else if (this._flv) {\n            this._flv.setExtra(data);\n        }\n    }\n}\n","import { ErrorDetails } from '../core/errors';\n\nconst ErrorCodeList: Record<number|string, string> = {\n    400: '01', // http 400\n    401: '02', // http 401\n    403: '03', // http 403\n    404: '04', // http 404\n    other4xx: '05', // http 4xx\n    serverError: '06', // http 5xx\n    timeoutOpen: '07',\n    timeoutIO: '08',\n    200: '09',\n    206: '09'\n};\n\nexport function getErrorCode(detail: ErrorDetails, reason: string, httpStatusCode: number = 0): number {\n    if (detail >= 100) {\n        return detail;\n    }\n    let code = '00';\n    if (reason === 'timeout') {\n        if (!httpStatusCode) {\n            code = ErrorCodeList.timeoutOpen || code;;\n        } else {\n            code = ErrorCodeList.timeoutIO || code;;\n        }\n    } else if (ErrorCodeList.hasOwnProperty(httpStatusCode)) {\n        code = ErrorCodeList[httpStatusCode] || code;\n    } else if ((/^4\\d{2}$/).test(httpStatusCode.toString())) {\n        code = ErrorCodeList.other4xx || code;;\n    } else if ((/^5\\d{2}$/).test(httpStatusCode.toString())) {\n        code = ErrorCodeList.serverError || code;;\n    }\n    return parseInt(detail + code, 10);\n}\n","/*\n * FPS Controller\n */\n\nconst { performance } = window;\n\nclass FPS {\n    private tag: string = 'fps';\n    private _lastDroppedFrames: number = 0;\n    private _lastDecodedFrames: number = 0;\n    private _video: HTMLVideoElement | null = null;\n    private _isVideoPlaybackQualityAvailable: boolean = false;\n    private _lastTime: number = 0;\n    private _decoded: number = 0;\n    private _dropped: number = 0\n\n    constructor() {\n    }\n\n    public attachMedia(media: HTMLVideoElement) {\n        const video = this._video = media instanceof (window as any).HTMLVideoElement ? media : null;\n        if (video) {\n            // seek\n            this._isVideoPlaybackQualityAvailable = typeof video.getVideoPlaybackQuality === 'function';\n        }\n    }\n\n    public destory() {\n    }\n\n    public reset() {\n        this._lastTime = performance.now();\n        this._lastDroppedFrames = this._lastDecodedFrames = this._decoded = this._dropped = 0;\n        const video = this._video;\n        if (video) {\n            try {\n                if (this._isVideoPlaybackQualityAvailable) {\n                    const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                    this._lastDecodedFrames = videoPlaybackQuality.totalVideoFrames;\n                    this._lastDroppedFrames = videoPlaybackQuality.droppedVideoFrames;\n                } else {\n                    this._lastDecodedFrames = (video as any).webkitDecodedFrameCount;\n                    this._lastDroppedFrames = (video as any).webkitDroppedFrameCount;\n                }\n            } catch (e) {\n                return;\n            }\n        }\n    }\n\n    public checkFPSInterval(): null | {\n        decoded: number,\n        dropped: number,\n        decodedFPS: number,\n        droppedFPS: number\n    } {\n        const video = this._video;\n        const currentTime = performance.now();\n        let info: any = null, decoded = 0, dropped = 0;\n\n        if (video) {\n            if (this._isVideoPlaybackQualityAvailable) {\n                const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                decoded = videoPlaybackQuality.totalVideoFrames;\n                dropped = videoPlaybackQuality.droppedVideoFrames;\n            } else {\n                decoded = (video as any).webkitDecodedFrameCount || 0;\n                dropped = (video as any).webkitDroppedFrameCount || 0;\n            }\n        }\n\n        if (decoded) {\n            if (decoded < this._lastDecodedFrames) {\n                this._lastDecodedFrames = 0;\n                this._lastDroppedFrames = 0;\n            }\n            let currentPeriod = currentTime - this._lastTime,\n                currentDropped = dropped - this._lastDroppedFrames,\n                currentDecoded = decoded - this._lastDecodedFrames,\n                droppedFPS = 0,\n                decodedFPS = 0;\n            if (this._lastTime) {\n                droppedFPS = parseFloat((1000 * currentDropped / currentPeriod).toFixed(2)),\n                    decodedFPS = parseFloat((1000 * currentDecoded / currentPeriod).toFixed(2));\n            }\n            this._decoded = this._decoded += currentDecoded;\n            this._dropped = this._dropped += currentDropped;\n            this._lastTime = currentTime;\n            this._lastDroppedFrames = dropped;\n            this._lastDecodedFrames = decoded;\n\n            info = {\n                decoded: this._decoded,\n                dropped: this._dropped,\n                decodedFPS,\n                droppedFPS\n            };\n        }\n        this._lastTime = currentTime;\n        return info;\n    }\n}\n\nexport default FPS;\n","const RECORD_NUM_LIMIT = 10;\nconst RECORD_DOWNLOAD_NUM_LIMIT = 200;\nconst RECORD_SEGMRNT_NUM_LIMIT = 100;\n\ntype StreamQOS = {\n    index: number;\n    startPos: number;\n    url: string;\n    bitrate: number;\n    mediaInfo?: any;\n    traffic: number;\n    loadTimeCost: number;\n    keyFrame: number;\n    videoDataRate: number;\n    audioDataRate: number;\n    segments: Partial<Record<string, { duration: number; dts: number; len: number }[]>>;\n};\ntype DownloadLog = {\n    byteLength: number;\n    timeCost: number;\n    ts: number;\n};\ntype QOS = {\n    traffic: number;\n    streams: StreamQOS[];\n    download: DownloadLog[];\n};\n\n/**\n * remux\n */\nclass StreamMonitor {\n    private _qos!: QOS;\n    constructor() {\n        this.reset();\n    }\n\n    /**\n     * \n     */\n    public reset() {\n        this._qos = {\n            traffic: 0,\n            streams: [],\n            download: []\n        };\n    }\n\n    /**\n     * \n     */\n    public onKeyFrame() {\n        this._qos.streams[this._qos.streams.length - 1].keyFrame++;\n    }\n\n    /**\n     * \n     * @param index id\n     * @param startPos \n     * @param url \n     * @param bitrate \n     */\n    public onStreamOpen(index: number, startPos: number, url: string, bitrate: number): void {\n        if (this._qos.streams.length > RECORD_NUM_LIMIT) {\n            this._qos.streams.shift();\n        }\n        this._qos.streams.push({\n            index,\n            startPos,\n            url,\n            bitrate,\n            traffic: 0,\n            loadTimeCost: 0,\n            keyFrame: 0,\n            videoDataRate: 0,\n            audioDataRate: 0,\n            segments: {}\n        });\n    }\n\n    /**\n     * \n     * @param data \n     */\n    public onMediaInfo(data: any) {\n        const info = this.loadingInfo;\n        if (info) {\n            info.mediaInfo = Object.assign({}, data);\n        }\n    }\n\n    /**\n     * \n     * @param data \n     */\n    public onDataReceive(data: { byteLength: number; timeCost: number; ts: number }): void {\n        this._qos.traffic += data.byteLength;\n        const log = this._qos.download;\n        if (log.length > RECORD_DOWNLOAD_NUM_LIMIT) {\n            log.pop();\n        }\n        log.unshift(data);\n        const info = this._qos.streams[this._qos.streams.length - 1];\n        info.traffic += data.byteLength;\n        info.loadTimeCost += data.timeCost;\n    }\n\n    public onMediaSegment(data: {\n        type: string;\n        duration: number;\n        dts: number;\n        byteLength: number;\n        framesInfo: any[];\n    }): void {\n        const qos = this._qos;\n        const stream = qos.streams[qos.streams.length - 1];\n        const log = stream.segments[data.type] || [];\n        stream.segments[data.type] = log;\n        log.push({ duration: data.duration, dts: data.dts, len: data.byteLength });\n\n        // datarate\n        if (log.length > RECORD_SEGMRNT_NUM_LIMIT) {\n            log.shift();\n        }\n        let duration = 0;\n        let totalLen = 0;\n        for (let i = 0; i < log.length; i++) {\n            totalLen += log[i].len;\n            duration += log[i].duration;\n        }\n        if (duration > 0) {\n            if (data.type === 'video') {\n                stream.videoDataRate = Math.round(totalLen * 8 / duration);\n            } else if (data.type === 'audio') {\n                stream.audioDataRate = Math.round(totalLen * 8 / duration);\n            }\n        }\n    }\n\n    /**\n     * \n     * @param sec \n     */\n    public getInfoByTime(sec: number): StreamQOS | null {\n        for (let i = this._qos.streams.length - 1; i >= 0; i--) {\n            if (this._qos.streams[i].startPos < sec) {\n                return this._qos.streams[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * \n     * @param sec \n     */\n    public updateStartPos(sec: number): void {\n        if (this._qos.streams.length) {\n            this._qos.streams[this._qos.streams.length - 1].startPos = sec;\n        }\n    }\n\n    /**\n     * \n     */\n    public get loadingInfo(): StreamQOS | null {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1];\n        }\n        return null;\n    }\n\n    /**\n     * \n     */\n    public get downloadSpeed() {\n        const qos = this._qos;\n        const tsEnd = performance.now();\n        let len = 0,\n            timeCost = 0;\n        for (let i = 0; i < qos.download.length; i++) {\n            if (qos.download[i].ts > tsEnd - 1000) {\n                len += qos.download[i].byteLength;\n                timeCost += qos.download[i].timeCost;\n            } else {\n                break;\n            }\n        }\n        return Math.round(len / timeCost * 1000) || 0;\n    }\n\n    /**\n     * \n     */\n    public get mediaInfo(): any {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].mediaInfo;\n        }\n        return null;\n    }\n\n    /**\n     * \n     */\n    public get videoDataRate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].videoDataRate;\n        }\n        return 0;\n    }\n\n    /**\n     * \n     */\n    public get audioDataRate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].audioDataRate;\n        }\n        return 0;\n    }\n\n    /**\n     * \n     */\n    public get bitrate(): number {\n        if (this._qos.streams.length) {\n            return this._qos.streams[this._qos.streams.length - 1].bitrate;\n        }\n        return 0;\n    }\n    /**\n     * \n     */\n    public get traffic(): number {\n        return this._qos.traffic;\n    }\n    /**\n     * remux\n     */\n    public get data(): QOS {\n        return this._qos;\n    }\n}\n\nexport { StreamMonitor };\n\n","import { EventEmitter } from 'events';\nimport LasEvents from '../core/events';\nimport Media from '../core/media';\nimport { REPORT_TYPES } from '../core/report-types';\nimport { getNewMonitorData, MonitorData } from '../types/monitor-data';\nimport FPS from './fps';\nimport { StreamMonitor } from './stream-monitor';\n\nconst HEARTBEAT_INTERVAL = 1000;\n\n/**\n * \n */\nclass Monitor extends EventEmitter {\n    private _media: Media;\n    private _fps?: FPS;\n    private _data!: MonitorData;\n    private _playing: boolean = false;\n    private _sm: StreamMonitor;\n    private _hbTimer: any;\n\n    constructor(media: Media) {\n        super();\n        this._sm = new StreamMonitor();\n        this._media = media;\n        this.reset();\n    }\n\n    /**\n     * \n     */\n    public reset(): void {\n        this._data = getNewMonitorData();\n        this._sm.reset();\n        if (this._fps) {\n            this._fps.reset();\n        }\n        this._refresh();\n    }\n\n    /**\n     * \n     * @param {object} event \n     * @param {string} type \n     */\n    public onReport(event: any): void {\n        event.ts = event.ts || performance.now();\n        const data = this._data;\n        switch (event.type) {\n            case REPORT_TYPES.LOADER_CHUNK_ARRIVAL:\n                data.downloadedBytes += event.byteLength;\n                this._sm.onDataReceive(event);\n                break;\n            case REPORT_TYPES.START_LOAD_STREAM:\n                this._sm.onStreamOpen(event.index || 0, event.sync, event.url, event.bitrate);\n                break;\n            case REPORT_TYPES.KEY_FRAME:\n                this._sm.onKeyFrame();\n                break;\n        }\n    }\n\n    public destroy(): void {\n        if (this._fps) {\n            this._fps.destory();\n            this._fps = undefined;\n        }\n        this._stopHeartbeat();\n    }\n\n    public onLoad(): void {\n        this._startHeartbeat();\n        if (this._media.video) {\n            this._fps = new FPS();\n            this._fps.attachMedia(this._media.video);\n        }\n    }\n\n    public onSegmentInit(data: any): void {\n        this._sm.onMediaInfo(data);\n    }\n\n    public onLoadeddata(): void {\n        this._onFirstFrame();\n        this._waitingEnd();\n    }\n\n    public onCanplay(): void {\n        this._onFirstFrame();\n        this._waitingEnd();\n    }\n\n    public onPlaying(): void {\n        this._playing = true;\n        this._waitingEnd();\n    }\n\n    public onEnd(): void {\n        this._waitingEnd();\n    }\n\n    public onWaiting(block: boolean): void {\n        if (this._playing && this._data.firstFrameTime && block) {\n            this._waitingStart();\n        }\n    }\n\n    public onStopLoad(): void {\n        this._stopHeartbeat();\n    }\n\n    public onSegment(data: any) {\n        this._sm.onMediaSegment(data);\n    }\n\n    public get data() {\n        return this._data;\n    }\n\n    private _refresh(): void {\n        let fps;\n        if (this._fps) {\n            fps = this._fps.checkFPSInterval();\n        }\n        const data = this._data;\n        if (fps) {\n            data.decodedFPS = fps.decodedFPS;\n            data.droppedFPS = fps.droppedFPS;\n            data.droppedFrames = fps.dropped;\n            data.decodedFrames = fps.decoded;\n        } else {\n            data.decodedFPS = data.droppedFPS = data.droppedFrames = data.decodedFrames = 0;\n        }\n    }\n\n    private _onFirstFrame(): void {\n        if (!this._data.firstFrameTime) {\n            this._data.firstFrameTime = performance.now();\n        }\n    }\n\n    private _waitingStart() {\n        if (!this._data.bufferingStartMS) {\n            this._data.blockCount++;\n            this._data.bufferingStartMS = this._data.bufferingStartMS || performance.now();\n        }\n    }\n\n    private _waitingEnd() {\n        if (this._data.bufferingStartMS) {\n            this._data.blockDuration += performance.now() - this._data.bufferingStartMS;\n        }\n        this._data.bufferingStartMS = null;\n    }\n\n    private _heartbeat = () => {\n        this._refresh();\n\n        const data = this._data;\n        const sm = this._sm;\n        const hb = {\n            totalReceive: sm.traffic,\n            speed: sm.downloadSpeed,\n            videoDataRate: sm.videoDataRate,\n            audioDataRate: sm.audioDataRate,\n            decodedFPS: data.decodedFPS,\n            droppedFPS: data.droppedFPS,\n            decodedFrames: data.decodedFrames,\n            droppedFrames: data.droppedFrames\n        };\n\n        this.emit(LasEvents.HEARTBEAT, hb);\n    }\n\n    private _startHeartbeat(): void {\n        if (!this._hbTimer) {\n            this._hbTimer = setInterval(this._heartbeat, HEARTBEAT_INTERVAL)\n        }\n    }\n\n    private _stopHeartbeat(): void {\n        if (this._hbTimer) {\n            clearInterval(this._hbTimer);\n            this._hbTimer = undefined;\n        }\n    }\n}\n\nexport default Monitor;\n","export type MonitorData = {\n    decodedFPS: number,\n    droppedFPS: number,\n    decodedFrames: number,\n    droppedFrames: number,\n    loadStartTime: number,\n    firstFrameTime: number,\n    blockDuration: number,\n    blockCount: number,\n    downloadedBytes: number,\n} & Record<string, any>\n\nexport function getNewMonitorData(): MonitorData {\n    return {\n        decodedFPS: 0,\n        droppedFPS: 0,\n        decodedFrames: 0,\n        droppedFrames: 0,\n        loadStartTime: 0,\n        firstFrameTime: 0,\n        blockDuration: 0,\n        blockCount: 0,\n        downloadedBytes: 0,\n    }\n}\n","import { EventEmitter } from 'events';\nimport AbrLevel from './abr/abr-level';\nimport { ConfigHelper } from './config';\nimport { ErrorDetails, ErrorTypes } from './core/errors';\nimport LasEvents from './core/events';\nimport Media from './core/media';\nimport MSEController from './core/mse-controller';\nimport TransFlv from './core/trans-flv';\nimport { LasConfig } from './types/core';\nimport Browser from './utils/browser';\nimport { getErrorCode } from './utils/get-error-code';\nimport { isSupported } from './utils/is-supported';\nimport { Log } from './utils/log';\nimport Monitor from './monitor/monitor';\n\n// \nconst MAIN_TIMER_INTERVAL = 200;\n\nconst BUFFER_THRESHOLD_DEFAULT = 0.5;\nconst BUFFER_THRESHOLD_STEP = 1;\nconst BUFFER_THRESHOLD_MAX = 3.5;\n\nenum STAT {\n    NONE,\n    WAITING,\n    SEEK,\n    SELECT_BITRATE,\n    INIT\n}\n/**\n * Las controller\n * @export\n * @class Las\n */\nexport default class Las extends EventEmitter {\n    private tag: string = 'las';\n    private _config: LasConfig;\n    private _video?: HTMLVideoElement;\n    private _mse!: MSEController;\n    private _trans?: TransFlv;\n\n    private _stat: STAT = STAT.INIT;\n    private _seekOnCanplay: boolean = false;\n    private _audioCodecSwap: boolean = false;\n    private _error: any;\n    private _audioCodec: string = '';\n    private _recoverMediaErrorTime: number = 0;\n    private _mainTimer: any;\n    private _media: Media;\n\n    private _nextLevel: any[] = [];\n    private _mediaInfo: any;\n    // ()buffer\n    private _bufferThreshold: number = BUFFER_THRESHOLD_DEFAULT;\n    private _loadStopped: boolean = false;\n    private _seekOnUpdateEnd: boolean = false;\n    private _playingLevel?: number;\n    private _startLevel?: number;\n    private _monitor!: Monitor;\n\n    static isSupport(): boolean {\n        return isSupported();\n    }\n\n    static get version() {\n        return __VERSION__;\n    }\n\n\n    static get Events() {\n        return LasEvents;\n    }\n\n    static get ErrorTypes() {\n        return ErrorTypes;\n    }\n\n    static get ErrorDetails() {\n        return ErrorDetails;\n    }\n\n    constructor(config?: LasConfig) {\n        super();\n        if (!this.off) {\n            this.off = this.removeListener;\n        }\n        this._config = ConfigHelper.processConfig(config);\n        this._media = new Media();\n        if (!this._config) {\n            setTimeout(() => {\n                this._onError({\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.CONFIG_ERROR,\n                    fatal: true,\n                    reason: 'config data error'\n                });\n            }, 0);\n            return;\n        }\n        if (!Las.isSupport()) {\n            setTimeout(() => {\n                this._onError({\n                    type: ErrorTypes.OTHER_ERROR,\n                    details: ErrorDetails.UNSUPPORTED,\n                    fatal: true,\n                    reason: 'unsupported'\n                });\n            }, 0);\n            return;\n        }\n        this._mainTimer = null;\n        this._stat = STAT.INIT;\n        this._startMainTimer();\n        this._initMonitor();\n        Log.i(this.tag, Las.version, this._config);\n    }\n\n    /**\n     * videoMSE\n     */\n    public attachMedia(video: HTMLVideoElement): void {\n        this._video = video;\n        this._media.attachVideo(this._video);\n        this._initMSE(video);\n        this._bindVideoEvents();\n    }\n\n    /**\n     * load\n     * @param {string} src src\n     */\n    public load(src: any = undefined): void {\n        this._playingLevel = undefined;\n        this._monitor.reset();\n        if (src) {\n            ConfigHelper.setSrc(this._config, src);\n        }\n        if (!this._config.src && !this._config.manifest) {\n            this._onError({\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.CONFIG_ERROR,\n                fatal: true,\n                reason: 'url empty'\n            });\n            return;\n        }\n        this._load();\n    }\n\n    /**\n     * \n     */\n    public resume() {\n        Log.i(this.tag, 'call resume');\n        if (this._loadStopped) {\n            this._loadStopped = false;\n            this._load();\n        }\n        if (this._video && this._video.paused) {\n            this._video.play();\n        }\n    }\n\n    /**\n     * destroy\n     */\n    public destroy(): void {\n        this._stopMonitor();\n        this._stopMainTimer();\n        this._unbindVideoEvents();\n        this._stopVideo();\n    }\n\n    public refresh(): void {\n        Log.i(this.tag, 'call refresh');\n        if (this._trans && this._mse && this._video) {\n            this._startLevel = this._trans.currentLevel;\n\n            this._nextLevel = [];\n\n            this._stopVideo();\n            this._initMSE(this._video);\n\n            this._initTrans();\n            if (this._trans) {\n                this._trans.loadSource();\n            }\n\n        } else {\n            Log.v(this.tag, 'transmuxer & mediaSource not ready');\n        }\n    }\n\n    /**\n     * \n     */\n    public stopLoad(): void {\n        Log.i(this.tag, 'call stopLoad');\n        if (this._trans) {\n            this._destroyTrans();\n            this._mse.endOfData();\n            this._loadStopped = true;\n            this._monitor.onStopLoad();\n        }\n    }\n\n    public getMediaInfo(): any {\n        return Object.assign({}, this._mediaInfo);\n    }\n\n    public get autoLevelEnabled(): boolean {\n        if (this._trans) {\n            return this._trans.autoLevelEnabled;\n        }\n        return false;\n    }\n\n    public get levels(): AbrLevel[] {\n        if (this._trans) {\n            return this._trans.levels;\n        }\n        return [];\n    }\n\n    public get nextLevel(): number {\n        if (this._trans) {\n            return this._trans.nextLevel;\n        }\n        return 0;\n    }\n\n    public set nextLevel(value: number) {\n        if (!this._verifyLevel(value) || !this._trans) {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, { level: value });\n            return;\n        }\n        this._trans.nextLevel = value;\n    }\n\n    public get currentLevel(): number {\n        if (this._trans) {\n            return this._trans.currentLevel;\n        }\n        return 0;\n    }\n\n    public set currentLevel(value: number) {\n        if (!this._verifyLevel(value) || !this._trans) {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, { level: value });\n            return;\n        }\n\n        if (value === -1) {\n            this._trans.nextLevel = value;\n        } else {\n            this._stat = STAT.SELECT_BITRATE;\n            this._bufferThreshold = BUFFER_THRESHOLD_DEFAULT;\n            this._seekOnCanplay = true;\n            if (this._mse) {\n                this._mse.flush();\n            }\n            this._trans.currentLevel = value;\n        }\n    }\n\n    public get startLevel(): number {\n        return typeof this._startLevel === 'undefined' ? -1 : this._startLevel;\n    }\n\n    public set startLevel(value: number) {\n        this._startLevel = value;\n    }\n\n    public get monitorData() {\n        if (this._monitor) {\n            return this._monitor.data;\n        }\n        return;\n    }\n\n    private _bindVideoEvents(): void {\n        if (this._video) {\n            this._video.addEventListener('loadeddata', this._onVideoLoadeddata);\n            this._video.addEventListener('canplay', this._onVideoCanplay);\n            this._video.addEventListener('waiting', this._onVideoWaiting);\n            this._video.addEventListener('playing', this._onVideoPlaying);\n            this._video.addEventListener('play', this._onVideoPlay);\n            this._video.addEventListener('error', this._onVideoError);\n            this._video.addEventListener('ended', this._onVideoEnded);\n        }\n    }\n\n    private _unbindVideoEvents(): void {\n        if (this._video) {\n            this._video.removeEventListener('loadeddata', this._onVideoLoadeddata);\n            this._video.removeEventListener('canplay', this._onVideoCanplay);\n            this._video.removeEventListener('waiting', this._onVideoWaiting);\n            this._video.removeEventListener('playing', this._onVideoPlaying);\n            this._video.removeEventListener('play', this._onVideoPlay);\n            this._video.removeEventListener('error', this._onVideoError);\n            this._video.removeEventListener('ended', this._onVideoEnded);\n        }\n    }\n    /**\n     * mediasource\n     * @param {MSEController} mediaSource MSEController\n     */\n    private _unbindMediaSourceEvent(mediaSource: MSEController): void {\n        mediaSource.removeAllListeners();\n    }\n\n    private _onVideoPlay = (): void => {\n        if (!this._error) {\n            if (!this._trans) {\n                this.load();\n            }\n        }\n    };\n\n    private _onVideoEnded = (): void => {\n        this._monitor.onEnd();\n        if (this._mse) {\n            this._mse.flush();\n        }\n    };\n\n    /**\n     * new mediaSource\n     */\n    private _initMSE(video: HTMLVideoElement) {\n        this._mse = new MSEController(this._config);\n        this._mse.attach(video);\n        this._media.attachMSE(this._mse);\n\n        this._mse.on(LasEvents.ERROR, (errorMessage: any) => {\n            this._onError(errorMessage);\n        });\n        this._mse.on('updateend', () => {\n            if (this._seekOnUpdateEnd && video.buffered.length) {\n                Log.i(this.tag, 'seek on updateend');\n                this._internalSeek(video.buffered.start(0));\n                this._seekOnUpdateEnd = false;\n            }\n        });\n        this._mse.on('resetDone', () => {\n            this._seekOnUpdateEnd = true;\n        });\n    }\n\n    /**\n     * \n     */\n    private _load() {\n        this._loadStopped = false;\n        this._error = false;\n        this._stat = STAT.INIT;\n        this._bufferThreshold = BUFFER_THRESHOLD_DEFAULT;\n        this._nextLevel = [];\n        this._media.reset();\n\n        this._monitor.onLoad();\n        if (this._trans) {\n            this._destroyTrans();\n        }\n        if (this._mse.hasSourceBuffer() || (this._video && this._video.error)) {\n            this._resetMSE();\n        }\n        this._initTrans();\n        if (this._trans) {\n            this._trans.loadSource();\n        }\n    }\n\n    /**\n     * reset MSE\n     */\n    private _resetMSE = () => {\n        this._seekOnUpdateEnd = false;\n        if (this._video) {\n            Log.i(this.tag, 'rebuild mse');\n            URL.revokeObjectURL(this._video.src);\n            this._video.src = '';\n            this._video.removeAttribute('src');\n            this._destroyMSE();\n            this._initMSE(this._video);\n        }\n    }\n\n    private _verifyLevel(value: number): boolean {\n        return !!(this._trans &&\n            this._trans.levels.length > 0 &&\n            value < this._trans.levels.length &&\n            value >= -1 &&\n            this._video && !this._video.ended);\n    }\n\n    private _transmuxerEvent(trans: TransFlv): void {\n        const mse = this._mse;\n        trans.on(LasEvents.PARSING_DATA, data => {\n            if (mse) {\n                mse.mediaSegment(data);\n            }\n            if (this._monitor) {\n                this._monitor.onSegment({\n                    type: data.type,\n                    byteLength: data.data.byteLength,\n                    dts: Math.floor(data.startDTS * 1000),\n                    duration: Math.floor(data.duration * 1000),\n                    framesInfo: data.framesInfo\n                });\n            }\n        });\n\n        trans.on(LasEvents.PARSING_INIT_SEGMENT, data => {\n            const video = data.tracks.video,\n                audio = data.tracks.audio,\n                audiovideo = data.tracks.audiovideo;\n            const info: any = {\n                segments: [],\n                audiovideo: !!audiovideo,\n                hasVideo: !!(video || audiovideo),\n                hasAudio: !!(audio || audiovideo)\n            };\n            for (const key in data.tracks) {\n                const track = data.tracks[key];\n                Object.assign(info, track.metadata);\n                if (track.initSegment) {\n                    info.segments.push({ type: key, data: new Uint8Array(track.initSegment) });\n                }\n            }\n            info.videoCodec = video ? video.codec : null;\n            info.audioCodec = audio ? audio.codec : null;\n            this._audioCodec = data.manifestAudioCodec || info.audioCodec;\n            const mediaInfo = Object.assign({}, info);\n            delete mediaInfo.segments;\n            this._monitor.onSegmentInit(mediaInfo);\n            this.emit(LasEvents.MEDIA_INFO, mediaInfo);\n            this._mediaInfo = mediaInfo;\n            if (mse) {\n                mse.trackInfo(info);\n            }\n        });\n\n        trans.on(LasEvents.ERROR, errorMessage => {\n            this._onError(errorMessage);\n        });\n\n        trans.on(LasEvents.LOAD_END, () => {\n            if (mse) {\n                mse.endOfData();\n            }\n            this.emit(LasEvents.LOAD_END);\n        });\n        trans.on(LasEvents.LEVEL_SWITCH_FAILED, data => {\n            this.emit(LasEvents.LEVEL_SWITCH_FAILED, data);\n        });\n        trans.on(LasEvents.LEVEL_SWITCHING, data => {\n            if (!data.smooth && this._mse) {\n                this._mse.flush();\n            }\n            this.emit(LasEvents.LEVEL_SWITCHING, { level: data.level });\n            this._nextLevel = this._nextLevel\n                .sort((a, b) => {\n                    return a.startSec - b.startSec;\n                })\n                .filter(value => {\n                    return value.startSec < data.startSec;\n                });\n            this._nextLevel.push(data);\n        });\n        trans.on(LasEvents.BUFFER_FLUSHING, data => {\n            if (this._mse && this._video) {\n                this._mse.flush(data.startSec, this._video.duration);\n            }\n        });\n        trans.on(LasEvents.SCRIPT_PARSED, data => {\n            this.emit(LasEvents.SCRIPT_PARSED, data);\n        });\n        trans.on(LasEvents.MANIFEST_PARSED, data => {\n            if (typeof this._playingLevel === 'number') {\n                trans.currentLevel = this._playingLevel;\n                return;\n            }\n\n            if (typeof this._startLevel === 'number') {\n                trans.currentLevel = this._startLevel;\n            }\n            data = Object.assign({ levels: this.levels.slice(0), currentLevel: this.currentLevel }, data);\n            this._playingLevel = trans.currentLevel;\n            Log.i(this.tag, LasEvents.MANIFEST_PARSED, data);\n            this.emit(LasEvents.MANIFEST_PARSED, data);\n        });\n        trans.on(LasEvents.REPORT, data => {\n            if (this._monitor) {\n                this._monitor.onReport(data);\n            }\n        });\n    }\n\n    private _internalSeek(time: number): void {\n        if (this._video) {\n            this._video.currentTime = time;\n        }\n    }\n\n    /**\n     * Check buffer length regularly and apply various policies to avoid buffering\n     */\n    private _mainLoop = (): void => {\n        const EPS = 1e-3;\n        const video = this._video;\n\n        /**\n         * Ibufferbuffer\n         * seekbuffer\n         * 1. bufferseekWAITING_STAT.WAITING && !video.seeking\n         * 2. bufferseekWAITING_SEEK || WAITING_SELECT_BITRATE || WAITING_INIT\n         * 3. buffer\n         */\n        if (video &&\n            ((this._stat === STAT.WAITING && !video.seeking) ||\n                this._stat === STAT.INIT ||\n                this._stat === STAT.SEEK ||\n                this._stat === STAT.SELECT_BITRATE) &&\n\n            this._mse &&\n            !this._mse.hasCleanUpTask() &&\n            !video.ended\n        ) {\n            const currentTime = video.currentTime;\n            const currentBuffer = this._media.currentBuffer(currentTime);\n            let jumpTo: number | undefined = undefined;\n            // buffer\n            if (!currentBuffer || currentBuffer.end - currentTime < 1) {\n                const nextBuffer = this._media.nextBuffer(currentTime);\n                if (nextBuffer) {\n                    Log.i(this.tag, 'try fix block-A');\n                    jumpTo = nextBuffer.start;\n                }\n            } else if (video.buffered.length > 1 && currentBuffer.end - currentTime > 1) {\n                // buffer\n                Log.i(this.tag, 'try fix block-B');\n                jumpTo = currentBuffer.start;\n            }\n\n            if (jumpTo) {\n                jumpTo = jumpTo + (Browser.safari ? 0.3 : EPS);\n                this._internalSeek(jumpTo);\n                Log.i(this.tag, `jump to ${jumpTo}`);\n            }\n        }\n        if (this._nextLevel.length) {\n            this._checkLevelChange();\n        }\n    };\n\n    private _onVideoLoadeddata = (): void => {\n        Log.i(this.tag, 'loadeddata');\n        this._monitor.onLoadeddata();\n    }\n\n    /**\n     * canplay event listener\n     */\n    private _onVideoCanplay = (): void => {\n        Log.v(this.tag, `canplay ${!!this._stat}`);\n        this._monitor.onCanplay();\n        if (this._video && this._stat !== STAT.NONE) {\n            this._stat = STAT.NONE;\n            this._detectSeekOnCanplay();\n            this._checkLevelChange();\n            if (!this._video.paused) {\n                // waitingplaying\n                this._onVideoPlaying();\n            }\n        }\n    };\n\n    private _detectSeekOnCanplay(): void {\n        if (this._video && this._seekOnCanplay && this._mse && !this._mse.hasCleanUpTask()) {\n            let EPS = 1 / 30;\n            const mediaInfo = this._mediaInfo;\n            if (mediaInfo && mediaInfo.fps && mediaInfo.fps > 0) {\n                EPS = 1 / mediaInfo.fps;\n            }\n            if (this._media.isTimeinBuffered(this._video.currentTime + EPS)) {\n                Log.i(this.tag, `seek on canplay ${this._video.currentTime} + ${EPS}`);\n                this._seekOnCanplay = false;\n                this._internalSeek(this._video.currentTime + EPS);\n            }\n        }\n    }\n\n    /**\n     * 'waiting' event listener\n     */\n    private _onVideoWaiting = (): void => {\n        if (!this._video) {\n            return;\n        }\n        this._stat = this._stat || STAT.WAITING;\n        const block = !this._video.seeking && this._stat === STAT.WAITING;\n        if (block) {\n            this._bufferThreshold = Math.min(this._bufferThreshold + BUFFER_THRESHOLD_STEP, BUFFER_THRESHOLD_MAX);\n        }\n        if (block) {\n            Log.i(this.tag, 'waiting currentTime:', this._video.currentTime);\n        }\n        this._monitor.onWaiting(block);\n    };\n\n    /**\n     * 'playing' event listener\n     * playing\n     */\n    private _onVideoPlaying = (): void => {\n        Log.i(this.tag, 'playing');\n        if (!this._error) {\n            this._stat = STAT.NONE;\n            this._monitor.onPlaying();\n        }\n    };\n\n    private _onVideoError = (error: any): void => {\n        Log.e(this.tag, 'video error', error);\n        if (this._error) {\n            return;\n        }\n        const now = performance.now();\n        if (!this._recoverMediaErrorTime || now - this._recoverMediaErrorTime > 3000) {\n            this._recoverMediaErrorTime = now;\n            this._config.gopRemux = true;\n            this._recoverMediaError();\n            return;\n        }\n        if (!this._audioCodecSwap && this._audioCodec) {\n            this._audioCodecSwap = true;\n            this._recoverSwapAudioCodec();\n            this._recoverMediaError();\n            return;\n        }\n\n        let reason = 'video error';\n        if (this._video && this._video.error) {\n            reason += ` code:${this._video.error.code} message:${this._video.error.message}`;\n        }\n        this._onError({\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.VIDEO_ERROR,\n            fatal: true,\n            reason\n        });\n    };\n\n    /**\n     * \n     * @param {*} data \n     */\n    private _onError(data: any): void {\n        Log.i(this.tag, `on error ${JSON.stringify(data)}`);\n        const errInfo: any = {};\n        if (data.type === ErrorTypes.NETWORK_ERROR) {\n            errInfo.statusCode = data.statusCode;\n            errInfo.url = data.url;\n        }\n        if (data.fatal) {\n            const errorCode = getErrorCode(data.details, data.reason, data.statusCode || 0);\n            this.stopLoad();\n            this._stopMainTimer();\n            if (data.details === ErrorDetails.VIDEO_ERROR || (this._video && this._video.error)) {\n                this._destroyMSE();\n            }\n            errInfo.code = errorCode;\n            errInfo.type = data.type;\n            errInfo.reason = data.reason;\n            if (!this._error) {\n                this._error = errInfo;\n                this.emit(LasEvents.ERROR, errInfo);\n            }\n        }\n    }\n\n    private _startMainTimer(): void {\n        if (this._mainTimer === null) {\n            this._mainTimer = setInterval(this._mainLoop, MAIN_TIMER_INTERVAL);\n        }\n    }\n\n    private _stopMainTimer(): void {\n        if (this._mainTimer) {\n            clearInterval(this._mainTimer);\n            this._mainTimer = null;\n        }\n    }\n\n    private _checkLevelChange(): void {\n        const d = this._nextLevel[0];\n        if (this._video && d && this._video.currentTime >= d.startSec && this._media.isTimeinBuffered(this._video.currentTime)) {\n            this.emit(LasEvents.LEVEL_SWITCHED, { level: d.level });\n            this._playingLevel = d.level;\n            this._nextLevel.shift();\n        }\n    }\n\n    private _stopVideo(): void {\n        if (this._video) {\n            URL.revokeObjectURL(this._video.src);\n            this._video.src = '';\n            this._video.removeAttribute('src');\n            this._destroyTrans();\n            this._destroyMSE();\n        }\n    }\n\n    private _destroyTrans(): void {\n        if (this._trans) {\n            this._trans.removeAllListeners();\n            this._trans.destroy();\n            this._trans = undefined;\n        }\n    }\n\n    private _destroyMSE(): void {\n        if (this._mse) {\n            this._unbindMediaSourceEvent(this._mse);\n            this._mse.destroy();\n        }\n    }\n\n    private _initTrans(): void {\n        this._trans = new TransFlv(this._config, this._media);\n        this._transmuxerEvent(this._trans);\n        this._trans.init();\n    }\n\n    private _initMonitor(): void {\n        if (!this._monitor) {\n            this._monitor = new Monitor(this._media);\n            this._monitor.on(LasEvents.HEARTBEAT, value => {\n                this.emit(LasEvents.HEARTBEAT, value);\n            })\n        }\n    }\n\n    private _stopMonitor(): void {\n        if (this._monitor) {\n            this._monitor.destroy();\n            this._monitor.removeAllListeners();\n        }\n    }\n\n    /**\n     * audio codec string\n     */\n    private _recoverSwapAudioCodec(): void {\n        let audioCodec = this._audioCodec;\n        if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n        } else {\n            audioCodec = 'mp4a.40.5';\n        }\n        this._config.audioCodec = audioCodec;\n        this._config.audioCodecSwap = true;\n    }\n\n    /**\n     * video errorvideo\n     */\n    private _recoverMediaError(): void {\n        if (!this._video) {\n            return;\n        }\n        this._nextLevel = [];\n\n        this._stopVideo();\n        this._initMSE(this._video);\n\n        this._initTrans();\n        if (this._trans) {\n            this._trans.loadSource();\n        }\n\n    }\n}\n","import { getMediaSource } from './mediasource-helper';\nimport FetchLoader from '../io/fetch';\nimport { XHR, XHR_TYPE } from '../io/xhr';\n\nexport function isSupported(): boolean {\n    const mediaSource = getMediaSource();\n    const sourceBuffer = (window as any).SourceBuffer || (window as any).WebKitSourceBuffer;\n    const isTypeSupported: boolean =\n        mediaSource &&\n        typeof mediaSource.isTypeSupported === 'function' &&\n        mediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n\n    const sourceBufferValidAPI =\n        !sourceBuffer ||\n        (sourceBuffer.prototype &&\n            typeof sourceBuffer.prototype.appendBuffer === 'function' &&\n            typeof sourceBuffer.prototype.remove === 'function');\n\n    let streaming = FetchLoader.isSupport() || XHR.isSupportChunk() === XHR_TYPE.MOZ_CHUNK;\n    return isTypeSupported && sourceBufferValidAPI && streaming;\n}\n"],"sourceRoot":""}